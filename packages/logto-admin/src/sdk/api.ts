/* tslint:disable */
/* eslint-disable */
/**
 * Logto API references
 * API references for Logto services. To learn more about how to interact with Logto APIs, see [Interact with Management API](https://docs.logto.io/docs/recipes/interact-with-management-api/).  Note: The documentation is for Logto Cloud. If you are using Logto OSS, please refer to the response of `/api/swagger.json` endpoint on your Logto instance.
 *
 * The version of the OpenAPI document: Cloud
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ApiApplicationsApplicationIdRolesGet200ResponseInner
 */
export interface ApiApplicationsApplicationIdRolesGet200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsApplicationIdRolesGet200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsApplicationIdRolesGet200ResponseInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsApplicationIdRolesGet200ResponseInner
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsApplicationIdRolesGet200ResponseInner
     */
    'type': ApiApplicationsApplicationIdRolesGet200ResponseInnerTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ApiApplicationsApplicationIdRolesGet200ResponseInner
     */
    'isDefault': boolean;
}

export const ApiApplicationsApplicationIdRolesGet200ResponseInnerTypeEnum = {
    User: 'User',
    MachineToMachine: 'MachineToMachine'
} as const;

export type ApiApplicationsApplicationIdRolesGet200ResponseInnerTypeEnum = typeof ApiApplicationsApplicationIdRolesGet200ResponseInnerTypeEnum[keyof typeof ApiApplicationsApplicationIdRolesGet200ResponseInnerTypeEnum];

/**
 * 
 * @export
 * @interface ApiApplicationsApplicationIdRolesPostRequest
 */
export interface ApiApplicationsApplicationIdRolesPostRequest {
    /**
     * An array of API resource role IDs to assign.
     * @type {Array<string>}
     * @memberof ApiApplicationsApplicationIdRolesPostRequest
     */
    'roleIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ApiApplicationsApplicationIdRolesPutRequest
 */
export interface ApiApplicationsApplicationIdRolesPutRequest {
    /**
     * An array of API resource role IDs to update for the application.
     * @type {Array<string>}
     * @memberof ApiApplicationsApplicationIdRolesPutRequest
     */
    'roleIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ApiApplicationsApplicationIdSignInExperienceGet200Response
 */
export interface ApiApplicationsApplicationIdSignInExperienceGet200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsApplicationIdSignInExperienceGet200Response
     */
    'applicationId': string;
    /**
     * 
     * @type {ApiInteractionConsentGet200ResponseApplicationBranding}
     * @memberof ApiApplicationsApplicationIdSignInExperienceGet200Response
     */
    'branding': ApiInteractionConsentGet200ResponseApplicationBranding;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsApplicationIdSignInExperienceGet200Response
     */
    'termsOfUseUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsApplicationIdSignInExperienceGet200Response
     */
    'privacyPolicyUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsApplicationIdSignInExperienceGet200Response
     */
    'displayName': string | null;
}
/**
 * 
 * @export
 * @interface ApiApplicationsApplicationIdSignInExperiencePutRequest
 */
export interface ApiApplicationsApplicationIdSignInExperiencePutRequest {
    /**
     * 
     * @type {ApiInteractionConsentGet200ResponseApplicationBranding}
     * @memberof ApiApplicationsApplicationIdSignInExperiencePutRequest
     */
    'branding'?: ApiInteractionConsentGet200ResponseApplicationBranding;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsApplicationIdSignInExperiencePutRequest
     */
    'displayName'?: string | null;
    /**
     * 
     * @type {ApiApplicationsApplicationIdSignInExperiencePutRequestTermsOfUseUrl}
     * @memberof ApiApplicationsApplicationIdSignInExperiencePutRequest
     */
    'termsOfUseUrl': ApiApplicationsApplicationIdSignInExperiencePutRequestTermsOfUseUrl;
    /**
     * 
     * @type {ApiApplicationsApplicationIdSignInExperiencePutRequestTermsOfUseUrl}
     * @memberof ApiApplicationsApplicationIdSignInExperiencePutRequest
     */
    'privacyPolicyUrl': ApiApplicationsApplicationIdSignInExperiencePutRequestTermsOfUseUrl;
}
/**
 * @type ApiApplicationsApplicationIdSignInExperiencePutRequestTermsOfUseUrl
 * @export
 */
export type ApiApplicationsApplicationIdSignInExperiencePutRequestTermsOfUseUrl = string;

/**
 * 
 * @export
 * @interface ApiApplicationsApplicationIdUserConsentScopesGet200Response
 */
export interface ApiApplicationsApplicationIdUserConsentScopesGet200Response {
    /**
     * A list of organization scope details assigned to the application.
     * @type {Array<ApiApplicationsApplicationIdUserConsentScopesGet200ResponseOrganizationScopesInner>}
     * @memberof ApiApplicationsApplicationIdUserConsentScopesGet200Response
     */
    'organizationScopes': Array<ApiApplicationsApplicationIdUserConsentScopesGet200ResponseOrganizationScopesInner>;
    /**
     * A list of resource scope details grouped by resource id assigned to the application.
     * @type {Array<ApiApplicationsApplicationIdUserConsentScopesGet200ResponseResourceScopesInner>}
     * @memberof ApiApplicationsApplicationIdUserConsentScopesGet200Response
     */
    'resourceScopes': Array<ApiApplicationsApplicationIdUserConsentScopesGet200ResponseResourceScopesInner>;
    /**
     * A list of organization resource scope details grouped by resource id assigned to the application.
     * @type {Array<ApiApplicationsApplicationIdUserConsentScopesGet200ResponseResourceScopesInner>}
     * @memberof ApiApplicationsApplicationIdUserConsentScopesGet200Response
     */
    'organizationResourceScopes': Array<ApiApplicationsApplicationIdUserConsentScopesGet200ResponseResourceScopesInner>;
    /**
     * A list of user scope enum value assigned to the application.
     * @type {Array<string>}
     * @memberof ApiApplicationsApplicationIdUserConsentScopesGet200Response
     */
    'userScopes': Array<ApiApplicationsApplicationIdUserConsentScopesGet200ResponseUserScopesEnum>;
}

export const ApiApplicationsApplicationIdUserConsentScopesGet200ResponseUserScopesEnum = {
    Profile: 'profile',
    Email: 'email',
    Phone: 'phone',
    Address: 'address',
    CustomData: 'custom_data',
    Identities: 'identities',
    Roles: 'roles',
    Urnlogtoscopeorganizations: 'urn:logto:scope:organizations',
    UrnlogtoscopeorganizationRoles: 'urn:logto:scope:organization_roles'
} as const;

export type ApiApplicationsApplicationIdUserConsentScopesGet200ResponseUserScopesEnum = typeof ApiApplicationsApplicationIdUserConsentScopesGet200ResponseUserScopesEnum[keyof typeof ApiApplicationsApplicationIdUserConsentScopesGet200ResponseUserScopesEnum];

/**
 * 
 * @export
 * @interface ApiApplicationsApplicationIdUserConsentScopesGet200ResponseOrganizationScopesInner
 */
export interface ApiApplicationsApplicationIdUserConsentScopesGet200ResponseOrganizationScopesInner {
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsApplicationIdUserConsentScopesGet200ResponseOrganizationScopesInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsApplicationIdUserConsentScopesGet200ResponseOrganizationScopesInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsApplicationIdUserConsentScopesGet200ResponseOrganizationScopesInner
     */
    'description': string | null;
}
/**
 * 
 * @export
 * @interface ApiApplicationsApplicationIdUserConsentScopesGet200ResponseResourceScopesInner
 */
export interface ApiApplicationsApplicationIdUserConsentScopesGet200ResponseResourceScopesInner {
    /**
     * 
     * @type {ApiApplicationsApplicationIdUserConsentScopesGet200ResponseResourceScopesInnerResource}
     * @memberof ApiApplicationsApplicationIdUserConsentScopesGet200ResponseResourceScopesInner
     */
    'resource': ApiApplicationsApplicationIdUserConsentScopesGet200ResponseResourceScopesInnerResource;
    /**
     * 
     * @type {Array<ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerScopesInner>}
     * @memberof ApiApplicationsApplicationIdUserConsentScopesGet200ResponseResourceScopesInner
     */
    'scopes': Array<ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerScopesInner>;
}
/**
 * 
 * @export
 * @interface ApiApplicationsApplicationIdUserConsentScopesGet200ResponseResourceScopesInnerResource
 */
export interface ApiApplicationsApplicationIdUserConsentScopesGet200ResponseResourceScopesInnerResource {
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsApplicationIdUserConsentScopesGet200ResponseResourceScopesInnerResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsApplicationIdUserConsentScopesGet200ResponseResourceScopesInnerResource
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsApplicationIdUserConsentScopesGet200ResponseResourceScopesInnerResource
     */
    'indicator': string;
}
/**
 * 
 * @export
 * @interface ApiApplicationsApplicationIdUserConsentScopesPostRequest
 */
export interface ApiApplicationsApplicationIdUserConsentScopesPostRequest {
    /**
     * A list of organization scope id to assign to the application. Throws error if any given organization scope is not found.
     * @type {Array<string>}
     * @memberof ApiApplicationsApplicationIdUserConsentScopesPostRequest
     */
    'organizationScopes'?: Array<string>;
    /**
     * A list of resource scope id to assign to the application. Throws error if any given resource scope is not found.
     * @type {Array<string>}
     * @memberof ApiApplicationsApplicationIdUserConsentScopesPostRequest
     */
    'resourceScopes'?: Array<string>;
    /**
     * A list of organization resource scope id to assign to the application. Throws error if any given resource scope is not found.
     * @type {Array<string>}
     * @memberof ApiApplicationsApplicationIdUserConsentScopesPostRequest
     */
    'organizationResourceScopes'?: Array<string>;
    /**
     * A list of user scope enum value to assign to the application.
     * @type {Array<string>}
     * @memberof ApiApplicationsApplicationIdUserConsentScopesPostRequest
     */
    'userScopes'?: Array<ApiApplicationsApplicationIdUserConsentScopesPostRequestUserScopesEnum>;
}

export const ApiApplicationsApplicationIdUserConsentScopesPostRequestUserScopesEnum = {
    Profile: 'profile',
    Email: 'email',
    Phone: 'phone',
    Address: 'address',
    CustomData: 'custom_data',
    Identities: 'identities',
    Roles: 'roles',
    Urnlogtoscopeorganizations: 'urn:logto:scope:organizations',
    UrnlogtoscopeorganizationRoles: 'urn:logto:scope:organization_roles'
} as const;

export type ApiApplicationsApplicationIdUserConsentScopesPostRequestUserScopesEnum = typeof ApiApplicationsApplicationIdUserConsentScopesPostRequestUserScopesEnum[keyof typeof ApiApplicationsApplicationIdUserConsentScopesPostRequestUserScopesEnum];

/**
 * 
 * @export
 * @interface ApiApplicationsGet200ResponseInner
 */
export interface ApiApplicationsGet200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsGet200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsGet200ResponseInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsGet200ResponseInner
     */
    'secret': string;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsGet200ResponseInner
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsGet200ResponseInner
     */
    'type': ApiApplicationsGet200ResponseInnerTypeEnum;
    /**
     * 
     * @type {ApiApplicationsGet200ResponseInnerOidcClientMetadata}
     * @memberof ApiApplicationsGet200ResponseInner
     */
    'oidcClientMetadata': ApiApplicationsGet200ResponseInnerOidcClientMetadata;
    /**
     * 
     * @type {ApiApplicationsGet200ResponseInnerCustomClientMetadata}
     * @memberof ApiApplicationsGet200ResponseInner
     */
    'customClientMetadata': ApiApplicationsGet200ResponseInnerCustomClientMetadata;
    /**
     * 
     * @type {ApiApplicationsGet200ResponseInnerProtectedAppMetadata}
     * @memberof ApiApplicationsGet200ResponseInner
     */
    'protectedAppMetadata': ApiApplicationsGet200ResponseInnerProtectedAppMetadata | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApiApplicationsGet200ResponseInner
     */
    'isThirdParty': boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiApplicationsGet200ResponseInner
     */
    'createdAt': number;
}

export const ApiApplicationsGet200ResponseInnerTypeEnum = {
    Native: 'Native',
    Spa: 'SPA',
    Traditional: 'Traditional',
    MachineToMachine: 'MachineToMachine',
    Protected: 'Protected'
} as const;

export type ApiApplicationsGet200ResponseInnerTypeEnum = typeof ApiApplicationsGet200ResponseInnerTypeEnum[keyof typeof ApiApplicationsGet200ResponseInnerTypeEnum];

/**
 * 
 * @export
 * @interface ApiApplicationsGet200ResponseInnerCustomClientMetadata
 */
export interface ApiApplicationsGet200ResponseInnerCustomClientMetadata {
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiApplicationsGet200ResponseInnerCustomClientMetadata
     */
    'corsAllowedOrigins'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ApiApplicationsGet200ResponseInnerCustomClientMetadata
     */
    'idTokenTtl'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiApplicationsGet200ResponseInnerCustomClientMetadata
     */
    'refreshTokenTtl'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiApplicationsGet200ResponseInnerCustomClientMetadata
     */
    'refreshTokenTtlInDays'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ApiApplicationsGet200ResponseInnerCustomClientMetadata
     */
    'alwaysIssueRefreshToken'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApiApplicationsGet200ResponseInnerCustomClientMetadata
     */
    'rotateRefreshToken'?: boolean;
}
/**
 * 
 * @export
 * @interface ApiApplicationsGet200ResponseInnerOidcClientMetadata
 */
export interface ApiApplicationsGet200ResponseInnerOidcClientMetadata {
    /**
     * 
     * @type {Array<ApiApplicationsGet200ResponseInnerOidcClientMetadataRedirectUrisInner>}
     * @memberof ApiApplicationsGet200ResponseInnerOidcClientMetadata
     */
    'redirectUris': Array<ApiApplicationsGet200ResponseInnerOidcClientMetadataRedirectUrisInner>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiApplicationsGet200ResponseInnerOidcClientMetadata
     */
    'postLogoutRedirectUris': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsGet200ResponseInnerOidcClientMetadata
     */
    'backchannelLogoutUri'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiApplicationsGet200ResponseInnerOidcClientMetadata
     */
    'backchannelLogoutSessionRequired'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsGet200ResponseInnerOidcClientMetadata
     */
    'logoUri'?: string;
}
/**
 * @type ApiApplicationsGet200ResponseInnerOidcClientMetadataRedirectUrisInner
 * @export
 */
export type ApiApplicationsGet200ResponseInnerOidcClientMetadataRedirectUrisInner = object;

/**
 * 
 * @export
 * @interface ApiApplicationsGet200ResponseInnerProtectedAppMetadata
 */
export interface ApiApplicationsGet200ResponseInnerProtectedAppMetadata {
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsGet200ResponseInnerProtectedAppMetadata
     */
    'host': string;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsGet200ResponseInnerProtectedAppMetadata
     */
    'origin': string;
    /**
     * 
     * @type {number}
     * @memberof ApiApplicationsGet200ResponseInnerProtectedAppMetadata
     */
    'sessionDuration': number;
    /**
     * 
     * @type {Array<ApiApplicationsGet200ResponseInnerProtectedAppMetadataPageRulesInner>}
     * @memberof ApiApplicationsGet200ResponseInnerProtectedAppMetadata
     */
    'pageRules': Array<ApiApplicationsGet200ResponseInnerProtectedAppMetadataPageRulesInner>;
    /**
     * 
     * @type {Array<ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInner>}
     * @memberof ApiApplicationsGet200ResponseInnerProtectedAppMetadata
     */
    'customDomains'?: Array<ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInner>;
}
/**
 * 
 * @export
 * @interface ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInner
 */
export interface ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInner {
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInner
     */
    'domain': string;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInner
     */
    'status': ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInner
     */
    'errorMessage': string | null;
    /**
     * 
     * @type {Array<ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerDnsRecordsInner>}
     * @memberof ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInner
     */
    'dnsRecords': Array<ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerDnsRecordsInner>;
    /**
     * 
     * @type {ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareData}
     * @memberof ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInner
     */
    'cloudflareData': ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareData | null;
}

export const ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerStatusEnum = {
    PendingVerification: 'PendingVerification',
    PendingSsl: 'PendingSsl',
    Active: 'Active',
    Error: 'Error'
} as const;

export type ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerStatusEnum = typeof ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerStatusEnum[keyof typeof ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerStatusEnum];

/**
 * 
 * @export
 * @interface ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareData
 */
export interface ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareData {
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareData
     */
    'status': string;
    /**
     * 
     * @type {ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareDataSsl}
     * @memberof ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareData
     */
    'ssl': ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareDataSsl;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareData
     */
    'verification_errors'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareDataSsl
 */
export interface ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareDataSsl {
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareDataSsl
     */
    'status': string;
    /**
     * 
     * @type {Array<ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareDataSslValidationErrorsInner>}
     * @memberof ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareDataSsl
     */
    'validation_errors'?: Array<ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareDataSslValidationErrorsInner>;
}
/**
 * 
 * @export
 * @interface ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareDataSslValidationErrorsInner
 */
export interface ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareDataSslValidationErrorsInner {
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareDataSslValidationErrorsInner
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerDnsRecordsInner
 */
export interface ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerDnsRecordsInner {
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerDnsRecordsInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerDnsRecordsInner
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerDnsRecordsInner
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface ApiApplicationsGet200ResponseInnerProtectedAppMetadataPageRulesInner
 */
export interface ApiApplicationsGet200ResponseInnerProtectedAppMetadataPageRulesInner {
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsGet200ResponseInnerProtectedAppMetadataPageRulesInner
     */
    'path': string;
}
/**
 * @type ApiApplicationsGetIsThirdPartyParameter
 * @export
 */
export type ApiApplicationsGetIsThirdPartyParameter = string;

/**
 * @type ApiApplicationsGetTypesParameter
 * @export
 */
export type ApiApplicationsGetTypesParameter = Array<string> | string;

/**
 * 
 * @export
 * @interface ApiApplicationsIdGet200Response
 */
export interface ApiApplicationsIdGet200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsIdGet200Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsIdGet200Response
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsIdGet200Response
     */
    'secret': string;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsIdGet200Response
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsIdGet200Response
     */
    'type': ApiApplicationsIdGet200ResponseTypeEnum;
    /**
     * 
     * @type {ApiApplicationsGet200ResponseInnerOidcClientMetadata}
     * @memberof ApiApplicationsIdGet200Response
     */
    'oidcClientMetadata': ApiApplicationsGet200ResponseInnerOidcClientMetadata;
    /**
     * 
     * @type {ApiApplicationsGet200ResponseInnerCustomClientMetadata}
     * @memberof ApiApplicationsIdGet200Response
     */
    'customClientMetadata': ApiApplicationsGet200ResponseInnerCustomClientMetadata;
    /**
     * 
     * @type {ApiApplicationsGet200ResponseInnerProtectedAppMetadata}
     * @memberof ApiApplicationsIdGet200Response
     */
    'protectedAppMetadata': ApiApplicationsGet200ResponseInnerProtectedAppMetadata | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApiApplicationsIdGet200Response
     */
    'isThirdParty': boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiApplicationsIdGet200Response
     */
    'createdAt': number;
    /**
     * 
     * @type {boolean}
     * @memberof ApiApplicationsIdGet200Response
     */
    'isAdmin': boolean;
}

export const ApiApplicationsIdGet200ResponseTypeEnum = {
    Native: 'Native',
    Spa: 'SPA',
    Traditional: 'Traditional',
    MachineToMachine: 'MachineToMachine',
    Protected: 'Protected'
} as const;

export type ApiApplicationsIdGet200ResponseTypeEnum = typeof ApiApplicationsIdGet200ResponseTypeEnum[keyof typeof ApiApplicationsIdGet200ResponseTypeEnum];

/**
 * 
 * @export
 * @interface ApiApplicationsIdPatchRequest
 */
export interface ApiApplicationsIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsIdPatchRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsIdPatchRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {ApiApplicationsIdPatchRequestOidcClientMetadata}
     * @memberof ApiApplicationsIdPatchRequest
     */
    'oidcClientMetadata'?: ApiApplicationsIdPatchRequestOidcClientMetadata;
    /**
     * 
     * @type {ApiApplicationsGet200ResponseInnerCustomClientMetadata}
     * @memberof ApiApplicationsIdPatchRequest
     */
    'customClientMetadata'?: ApiApplicationsGet200ResponseInnerCustomClientMetadata;
    /**
     * 
     * @type {ApiApplicationsIdPatchRequestProtectedAppMetadata}
     * @memberof ApiApplicationsIdPatchRequest
     */
    'protectedAppMetadata'?: ApiApplicationsIdPatchRequestProtectedAppMetadata;
    /**
     * Whether the application has admin access. User can enable the admin access for Machine-to-Machine apps.
     * @type {boolean}
     * @memberof ApiApplicationsIdPatchRequest
     */
    'isAdmin'?: boolean;
}
/**
 * 
 * @export
 * @interface ApiApplicationsIdPatchRequestOidcClientMetadata
 */
export interface ApiApplicationsIdPatchRequestOidcClientMetadata {
    /**
     * 
     * @type {Array<ApiApplicationsGet200ResponseInnerOidcClientMetadataRedirectUrisInner>}
     * @memberof ApiApplicationsIdPatchRequestOidcClientMetadata
     */
    'redirectUris'?: Array<ApiApplicationsGet200ResponseInnerOidcClientMetadataRedirectUrisInner>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiApplicationsIdPatchRequestOidcClientMetadata
     */
    'postLogoutRedirectUris'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsIdPatchRequestOidcClientMetadata
     */
    'backchannelLogoutUri'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiApplicationsIdPatchRequestOidcClientMetadata
     */
    'backchannelLogoutSessionRequired'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsIdPatchRequestOidcClientMetadata
     */
    'logoUri'?: string;
}
/**
 * 
 * @export
 * @interface ApiApplicationsIdPatchRequestProtectedAppMetadata
 */
export interface ApiApplicationsIdPatchRequestProtectedAppMetadata {
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsIdPatchRequestProtectedAppMetadata
     */
    'origin'?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiApplicationsIdPatchRequestProtectedAppMetadata
     */
    'sessionDuration'?: number;
    /**
     * 
     * @type {Array<ApiApplicationsGet200ResponseInnerProtectedAppMetadataPageRulesInner>}
     * @memberof ApiApplicationsIdPatchRequestProtectedAppMetadata
     */
    'pageRules'?: Array<ApiApplicationsGet200ResponseInnerProtectedAppMetadataPageRulesInner>;
}
/**
 * 
 * @export
 * @interface ApiApplicationsIdProtectedAppMetadataCustomDomainsPostRequest
 */
export interface ApiApplicationsIdProtectedAppMetadataCustomDomainsPostRequest {
    /**
     * The domain to be added to the application.
     * @type {string}
     * @memberof ApiApplicationsIdProtectedAppMetadataCustomDomainsPostRequest
     */
    'domain': string;
}
/**
 * 
 * @export
 * @interface ApiApplicationsIdUsersUserIdConsentOrganizationsGet200Response
 */
export interface ApiApplicationsIdUsersUserIdConsentOrganizationsGet200Response {
    /**
     * A list of organization entities granted by the user for the application.
     * @type {Array<ApiApplicationsIdUsersUserIdConsentOrganizationsGet200ResponseOrganizationsInner>}
     * @memberof ApiApplicationsIdUsersUserIdConsentOrganizationsGet200Response
     */
    'organizations': Array<ApiApplicationsIdUsersUserIdConsentOrganizationsGet200ResponseOrganizationsInner>;
}
/**
 * 
 * @export
 * @interface ApiApplicationsIdUsersUserIdConsentOrganizationsGet200ResponseOrganizationsInner
 */
export interface ApiApplicationsIdUsersUserIdConsentOrganizationsGet200ResponseOrganizationsInner {
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsIdUsersUserIdConsentOrganizationsGet200ResponseOrganizationsInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsIdUsersUserIdConsentOrganizationsGet200ResponseOrganizationsInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsIdUsersUserIdConsentOrganizationsGet200ResponseOrganizationsInner
     */
    'description': string | null;
    /**
     * arbitrary
     * @type {object}
     * @memberof ApiApplicationsIdUsersUserIdConsentOrganizationsGet200ResponseOrganizationsInner
     */
    'customData': object;
    /**
     * 
     * @type {boolean}
     * @memberof ApiApplicationsIdUsersUserIdConsentOrganizationsGet200ResponseOrganizationsInner
     */
    'isMfaRequired': boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiApplicationsIdUsersUserIdConsentOrganizationsGet200ResponseOrganizationsInner
     */
    'createdAt': number;
}
/**
 * 
 * @export
 * @interface ApiApplicationsIdUsersUserIdConsentOrganizationsPostRequest
 */
export interface ApiApplicationsIdUsersUserIdConsentOrganizationsPostRequest {
    /**
     * A list of organization ids to be granted.
     * @type {Array<string>}
     * @memberof ApiApplicationsIdUsersUserIdConsentOrganizationsPostRequest
     */
    'organizationIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ApiApplicationsIdUsersUserIdConsentOrganizationsPutRequest
 */
export interface ApiApplicationsIdUsersUserIdConsentOrganizationsPutRequest {
    /**
     * A list of organization ids to be granted. <br/> All the existing organizations\' access will be revoked if not in the list. <br/> If the list is empty, all the organizations\' access will be revoked.
     * @type {Array<string>}
     * @memberof ApiApplicationsIdUsersUserIdConsentOrganizationsPutRequest
     */
    'organizationIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ApiApplicationsPostRequest
 */
export interface ApiApplicationsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsPostRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsPostRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiApplicationsPostRequest
     */
    'type': ApiApplicationsPostRequestTypeEnum;
    /**
     * 
     * @type {ApiApplicationsGet200ResponseInnerOidcClientMetadata}
     * @memberof ApiApplicationsPostRequest
     */
    'oidcClientMetadata'?: ApiApplicationsGet200ResponseInnerOidcClientMetadata;
    /**
     * 
     * @type {ApiApplicationsGet200ResponseInnerCustomClientMetadata}
     * @memberof ApiApplicationsPostRequest
     */
    'customClientMetadata'?: ApiApplicationsGet200ResponseInnerCustomClientMetadata;
    /**
     * 
     * @type {boolean}
     * @memberof ApiApplicationsPostRequest
     */
    'isThirdParty'?: boolean;
    /**
     * 
     * @type {ApiApplicationsPostRequestProtectedAppMetadata}
     * @memberof ApiApplicationsPostRequest
     */
    'protectedAppMetadata'?: ApiApplicationsPostRequestProtectedAppMetadata;
}

export const ApiApplicationsPostRequestTypeEnum = {
    Native: 'Native',
    Spa: 'SPA',
    Traditional: 'Traditional',
    MachineToMachine: 'MachineToMachine',
    Protected: 'Protected'
} as const;

export type ApiApplicationsPostRequestTypeEnum = typeof ApiApplicationsPostRequestTypeEnum[keyof typeof ApiApplicationsPostRequestTypeEnum];

/**
 * The data for protected app, this feature is not available for open source version.
 * @export
 * @interface ApiApplicationsPostRequestProtectedAppMetadata
 */
export interface ApiApplicationsPostRequestProtectedAppMetadata {
    /**
     * The subdomain prefix, e.g., my-site.
     * @type {string}
     * @memberof ApiApplicationsPostRequestProtectedAppMetadata
     */
    'subDomain': string;
    /**
     * The origin of target website, e.g., https://example.com.
     * @type {string}
     * @memberof ApiApplicationsPostRequestProtectedAppMetadata
     */
    'origin': string;
}
/**
 * 
 * @export
 * @interface ApiAuthnHasuraGet200Response
 */
export interface ApiAuthnHasuraGet200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiAuthnHasuraGet200Response
     */
    'X-Hasura-User-Id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiAuthnHasuraGet200Response
     */
    'X-Hasura-Role'?: string;
}
/**
 * 
 * @export
 * @interface ApiAuthnSingleSignOnSamlConnectorIdPostRequest
 */
export interface ApiAuthnSingleSignOnSamlConnectorIdPostRequest {
    /**
     * SAML standard parameter that will be transmitted between the identity provider and the service provider. It will be used as the session ID (jti) of the user\'s Logto authentication session. This API will use this session ID to retrieve the SSO connector authentication session from the database.
     * @type {string}
     * @memberof ApiAuthnSingleSignOnSamlConnectorIdPostRequest
     */
    'RelayState': string;
    /**
     * The SAML assertion response from the identity provider (IdP).
     * @type {string}
     * @memberof ApiAuthnSingleSignOnSamlConnectorIdPostRequest
     */
    'SAMLResponse': string;
}
/**
 * 
 * @export
 * @interface ApiConfigsAdminConsoleGet200Response
 */
export interface ApiConfigsAdminConsoleGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiConfigsAdminConsoleGet200Response
     */
    'signInExperienceCustomized': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApiConfigsAdminConsoleGet200Response
     */
    'organizationCreated': boolean;
    /**
     * 
     * @type {ApiConfigsAdminConsoleGet200ResponseDevelopmentTenantMigrationNotification}
     * @memberof ApiConfigsAdminConsoleGet200Response
     */
    'developmentTenantMigrationNotification'?: ApiConfigsAdminConsoleGet200ResponseDevelopmentTenantMigrationNotification;
    /**
     * 
     * @type {ApiConfigsAdminConsoleGet200ResponseCheckedChargeNotification}
     * @memberof ApiConfigsAdminConsoleGet200Response
     */
    'checkedChargeNotification'?: ApiConfigsAdminConsoleGet200ResponseCheckedChargeNotification;
}
/**
 * 
 * @export
 * @interface ApiConfigsAdminConsoleGet200ResponseCheckedChargeNotification
 */
export interface ApiConfigsAdminConsoleGet200ResponseCheckedChargeNotification {
    /**
     * 
     * @type {boolean}
     * @memberof ApiConfigsAdminConsoleGet200ResponseCheckedChargeNotification
     */
    'token'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApiConfigsAdminConsoleGet200ResponseCheckedChargeNotification
     */
    'apiResource'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApiConfigsAdminConsoleGet200ResponseCheckedChargeNotification
     */
    'machineToMachineApp'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApiConfigsAdminConsoleGet200ResponseCheckedChargeNotification
     */
    'tenantMember'?: boolean;
}
/**
 * 
 * @export
 * @interface ApiConfigsAdminConsoleGet200ResponseDevelopmentTenantMigrationNotification
 */
export interface ApiConfigsAdminConsoleGet200ResponseDevelopmentTenantMigrationNotification {
    /**
     * 
     * @type {boolean}
     * @memberof ApiConfigsAdminConsoleGet200ResponseDevelopmentTenantMigrationNotification
     */
    'isPaidTenant': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsAdminConsoleGet200ResponseDevelopmentTenantMigrationNotification
     */
    'tag': string;
    /**
     * 
     * @type {number}
     * @memberof ApiConfigsAdminConsoleGet200ResponseDevelopmentTenantMigrationNotification
     */
    'readAt'?: number;
}
/**
 * 
 * @export
 * @interface ApiConfigsAdminConsolePatchRequest
 */
export interface ApiConfigsAdminConsolePatchRequest {
    /**
     * 
     * @type {boolean}
     * @memberof ApiConfigsAdminConsolePatchRequest
     */
    'signInExperienceCustomized'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApiConfigsAdminConsolePatchRequest
     */
    'organizationCreated'?: boolean;
    /**
     * 
     * @type {ApiConfigsAdminConsoleGet200ResponseDevelopmentTenantMigrationNotification}
     * @memberof ApiConfigsAdminConsolePatchRequest
     */
    'developmentTenantMigrationNotification'?: ApiConfigsAdminConsoleGet200ResponseDevelopmentTenantMigrationNotification;
    /**
     * 
     * @type {ApiConfigsAdminConsoleGet200ResponseCheckedChargeNotification}
     * @memberof ApiConfigsAdminConsolePatchRequest
     */
    'checkedChargeNotification'?: ApiConfigsAdminConsoleGet200ResponseCheckedChargeNotification;
}
/**
 * @type ApiConfigsJwtCustomizerGet200ResponseInner
 * @export
 */
export type ApiConfigsJwtCustomizerGet200ResponseInner = ApiConfigsJwtCustomizerGet200ResponseInnerOneOf | ApiConfigsJwtCustomizerGet200ResponseInnerOneOf1;

/**
 * 
 * @export
 * @interface ApiConfigsJwtCustomizerGet200ResponseInnerOneOf
 */
export interface ApiConfigsJwtCustomizerGet200ResponseInnerOneOf {
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerGet200ResponseInnerOneOf
     */
    'key': string;
    /**
     * 
     * @type {ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOf}
     * @memberof ApiConfigsJwtCustomizerGet200ResponseInnerOneOf
     */
    'value': ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOf;
}
/**
 * 
 * @export
 * @interface ApiConfigsJwtCustomizerGet200ResponseInnerOneOf1
 */
export interface ApiConfigsJwtCustomizerGet200ResponseInnerOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerGet200ResponseInnerOneOf1
     */
    'key': string;
    /**
     * 
     * @type {ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOf1}
     * @memberof ApiConfigsJwtCustomizerGet200ResponseInnerOneOf1
     */
    'value': ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOf1;
}
/**
 * @type ApiConfigsJwtCustomizerTestPostRequest
 * @export
 */
export type ApiConfigsJwtCustomizerTestPostRequest = ApiConfigsJwtCustomizerTestPostRequestOneOf | ApiConfigsJwtCustomizerTestPostRequestOneOf1;

/**
 * 
 * @export
 * @interface ApiConfigsJwtCustomizerTestPostRequestOneOf
 */
export interface ApiConfigsJwtCustomizerTestPostRequestOneOf {
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTestPostRequestOneOf
     */
    'tokenType': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiConfigsJwtCustomizerTestPostRequestOneOf
     */
    'environmentVariables'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTestPostRequestOneOf
     */
    'script': string;
    /**
     * 
     * @type {ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfTokenSample}
     * @memberof ApiConfigsJwtCustomizerTestPostRequestOneOf
     */
    'token': ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfTokenSample;
    /**
     * 
     * @type {ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSample}
     * @memberof ApiConfigsJwtCustomizerTestPostRequestOneOf
     */
    'context': ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSample;
}
/**
 * 
 * @export
 * @interface ApiConfigsJwtCustomizerTestPostRequestOneOf1
 */
export interface ApiConfigsJwtCustomizerTestPostRequestOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTestPostRequestOneOf1
     */
    'tokenType': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiConfigsJwtCustomizerTestPostRequestOneOf1
     */
    'environmentVariables'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTestPostRequestOneOf1
     */
    'script': string;
    /**
     * 
     * @type {ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOf1TokenSample}
     * @memberof ApiConfigsJwtCustomizerTestPostRequestOneOf1
     */
    'token': ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOf1TokenSample;
}
/**
 * 
 * @export
 * @interface ApiConfigsJwtCustomizerTestPostRequestPayload
 */
export interface ApiConfigsJwtCustomizerTestPostRequestPayload {
    /**
     * The code snippet of the JWT customizer.
     * @type {any}
     * @memberof ApiConfigsJwtCustomizerTestPostRequestPayload
     */
    'script'?: any;
    /**
     * The environment variables for the JWT customizer.
     * @type {any}
     * @memberof ApiConfigsJwtCustomizerTestPostRequestPayload
     */
    'environmentVariables'?: any;
    /**
     * The sample context for the JWT customizer script testing purpose.
     * @type {any}
     * @memberof ApiConfigsJwtCustomizerTestPostRequestPayload
     */
    'contextSample'?: any;
    /**
     * The sample token payload for the JWT customizer script testing purpose.
     * @type {any}
     * @memberof ApiConfigsJwtCustomizerTestPostRequestPayload
     */
    'tokenSample'?: any;
}
/**
 * @type ApiConfigsJwtCustomizerTokenTypePathGet200Response
 * @export
 */
export type ApiConfigsJwtCustomizerTokenTypePathGet200Response = ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOf | ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOf1;

/**
 * 
 * @export
 * @interface ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOf
 */
export interface ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOf {
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOf
     */
    'script': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOf
     */
    'environmentVariables'?: { [key: string]: string; };
    /**
     * 
     * @type {ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSample}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOf
     */
    'contextSample'?: ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSample;
    /**
     * 
     * @type {ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfTokenSample}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOf
     */
    'tokenSample'?: ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfTokenSample;
}
/**
 * 
 * @export
 * @interface ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOf1
 */
export interface ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOf1
     */
    'script': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOf1
     */
    'environmentVariables'?: { [key: string]: string; };
    /**
     * arbitrary
     * @type {object}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOf1
     */
    'contextSample'?: object;
    /**
     * 
     * @type {ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOf1TokenSample}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOf1
     */
    'tokenSample'?: ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOf1TokenSample;
}
/**
 * 
 * @export
 * @interface ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOf1TokenSample
 */
export interface ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOf1TokenSample {
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOf1TokenSample
     */
    'jti'?: string;
    /**
     * 
     * @type {ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfTokenSampleAud}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOf1TokenSample
     */
    'aud'?: ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfTokenSampleAud;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOf1TokenSample
     */
    'scope'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOf1TokenSample
     */
    'clientId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOf1TokenSample
     */
    'kind'?: string;
}
/**
 * 
 * @export
 * @interface ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSample
 */
export interface ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSample {
    /**
     * 
     * @type {ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUser}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSample
     */
    'user': ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUser;
}
/**
 * 
 * @export
 * @interface ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUser
 */
export interface ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUser {
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUser
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUser
     */
    'username'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUser
     */
    'primaryEmail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUser
     */
    'primaryPhone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUser
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUser
     */
    'avatar'?: string | null;
    /**
     * arbitrary
     * @type {object}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUser
     */
    'customData'?: object;
    /**
     * 
     * @type {{ [key: string]: ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserIdentitiesValue; }}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUser
     */
    'identities'?: { [key: string]: ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserIdentitiesValue; };
    /**
     * 
     * @type {number}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUser
     */
    'lastSignInAt'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUser
     */
    'createdAt'?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUser
     */
    'updatedAt'?: number;
    /**
     * 
     * @type {ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfile}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUser
     */
    'profile'?: ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfile;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUser
     */
    'applicationId'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUser
     */
    'isSuspended'?: boolean;
    /**
     * 
     * @type {Array<ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserSsoIdentitiesInner>}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUser
     */
    'ssoIdentities'?: Array<ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserSsoIdentitiesInner>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUser
     */
    'mfaVerificationFactors'?: Array<ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserMfaVerificationFactorsEnum>;
    /**
     * 
     * @type {Array<ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInner>}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUser
     */
    'roles'?: Array<ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInner>;
    /**
     * 
     * @type {Array<ApiApplicationsApplicationIdUserConsentScopesGet200ResponseOrganizationScopesInner>}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUser
     */
    'organizations'?: Array<ApiApplicationsApplicationIdUserConsentScopesGet200ResponseOrganizationScopesInner>;
    /**
     * 
     * @type {Array<ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserOrganizationRolesInner>}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUser
     */
    'organizationRoles'?: Array<ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserOrganizationRolesInner>;
}

export const ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserMfaVerificationFactorsEnum = {
    Totp: 'Totp',
    WebAuthn: 'WebAuthn',
    BackupCode: 'BackupCode'
} as const;

export type ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserMfaVerificationFactorsEnum = typeof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserMfaVerificationFactorsEnum[keyof typeof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserMfaVerificationFactorsEnum];

/**
 * 
 * @export
 * @interface ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserIdentitiesValue
 */
export interface ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserIdentitiesValue {
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserIdentitiesValue
     */
    'userId': string;
    /**
     * arbitrary
     * @type {object}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserIdentitiesValue
     */
    'details'?: object;
}
/**
 * 
 * @export
 * @interface ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserOrganizationRolesInner
 */
export interface ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserOrganizationRolesInner {
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserOrganizationRolesInner
     */
    'organizationId': string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserOrganizationRolesInner
     */
    'roleId': string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserOrganizationRolesInner
     */
    'roleName': string;
}
/**
 * 
 * @export
 * @interface ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfile
 */
export interface ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfile {
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfile
     */
    'familyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfile
     */
    'givenName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfile
     */
    'middleName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfile
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfile
     */
    'preferredUsername'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfile
     */
    'profile'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfile
     */
    'website'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfile
     */
    'gender'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfile
     */
    'birthdate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfile
     */
    'zoneinfo'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfile
     */
    'locale'?: string;
    /**
     * 
     * @type {ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfileAddress}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfile
     */
    'address'?: ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfileAddress;
}
/**
 * 
 * @export
 * @interface ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfileAddress
 */
export interface ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfileAddress {
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfileAddress
     */
    'formatted'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfileAddress
     */
    'streetAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfileAddress
     */
    'locality'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfileAddress
     */
    'region'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfileAddress
     */
    'postalCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfileAddress
     */
    'country'?: string;
}
/**
 * 
 * @export
 * @interface ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInner
 */
export interface ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInner {
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInner
     */
    'description': string;
    /**
     * 
     * @type {Array<ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInnerScopesInner>}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInner
     */
    'scopes': Array<ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInnerScopesInner>;
}
/**
 * 
 * @export
 * @interface ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInnerScopesInner
 */
export interface ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInnerScopesInner {
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInnerScopesInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInnerScopesInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInnerScopesInner
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInnerScopesInner
     */
    'resourceId': string;
    /**
     * 
     * @type {ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInnerScopesInner
     */
    'resource': ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource;
}
/**
 * 
 * @export
 * @interface ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource
 */
export interface ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource {
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource
     */
    'indicator': string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource
     */
    'isDefault': boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource
     */
    'accessTokenTtl': number;
}
/**
 * 
 * @export
 * @interface ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserSsoIdentitiesInner
 */
export interface ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserSsoIdentitiesInner {
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserSsoIdentitiesInner
     */
    'issuer': string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserSsoIdentitiesInner
     */
    'identityId': string;
    /**
     * arbitrary
     * @type {object}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserSsoIdentitiesInner
     */
    'detail': object;
}
/**
 * 
 * @export
 * @interface ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfTokenSample
 */
export interface ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfTokenSample {
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfTokenSample
     */
    'jti'?: string;
    /**
     * 
     * @type {ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfTokenSampleAud}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfTokenSample
     */
    'aud'?: ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfTokenSampleAud;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfTokenSample
     */
    'scope'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfTokenSample
     */
    'clientId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfTokenSample
     */
    'accountId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfTokenSample
     */
    'expiresWithSession'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfTokenSample
     */
    'grantId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfTokenSample
     */
    'gty'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfTokenSample
     */
    'sessionUid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfTokenSample
     */
    'sid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfTokenSample
     */
    'kind'?: string;
}
/**
 * @type ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfTokenSampleAud
 * @export
 */
export type ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfTokenSampleAud = Array<string> | string;

/**
 * 
 * @export
 * @interface ApiConfigsJwtCustomizerTokenTypePathPutRequest
 */
export interface ApiConfigsJwtCustomizerTokenTypePathPutRequest {
    /**
     * The script of the JWT customizer.
     * @type {any}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathPutRequest
     */
    'script'?: any;
    /**
     * The environment variables for the JWT customizer.
     * @type {any}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathPutRequest
     */
    'environmentVariables'?: any;
    /**
     * The sample context for the JWT customizer script testing purpose.
     * @type {any}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathPutRequest
     */
    'contextSample'?: any;
    /**
     * The sample raw token payload for the JWT customizer script testing purpose.
     * @type {any}
     * @memberof ApiConfigsJwtCustomizerTokenTypePathPutRequest
     */
    'tokenSample'?: any;
}
/**
 * 
 * @export
 * @interface ApiConfigsOidcKeyTypeGet200ResponseInner
 */
export interface ApiConfigsOidcKeyTypeGet200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsOidcKeyTypeGet200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof ApiConfigsOidcKeyTypeGet200ResponseInner
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof ApiConfigsOidcKeyTypeGet200ResponseInner
     */
    'signingKeyAlgorithm'?: ApiConfigsOidcKeyTypeGet200ResponseInnerSigningKeyAlgorithmEnum;
}

export const ApiConfigsOidcKeyTypeGet200ResponseInnerSigningKeyAlgorithmEnum = {
    Rsa: 'RSA',
    Ec: 'EC'
} as const;

export type ApiConfigsOidcKeyTypeGet200ResponseInnerSigningKeyAlgorithmEnum = typeof ApiConfigsOidcKeyTypeGet200ResponseInnerSigningKeyAlgorithmEnum[keyof typeof ApiConfigsOidcKeyTypeGet200ResponseInnerSigningKeyAlgorithmEnum];

/**
 * 
 * @export
 * @interface ApiConfigsOidcKeyTypeRotatePostRequest
 */
export interface ApiConfigsOidcKeyTypeRotatePostRequest {
    /**
     * The signing key algorithm the new generated private key is using.  Only applicable when `keyType` is `private-keys`.
     * @type {string}
     * @memberof ApiConfigsOidcKeyTypeRotatePostRequest
     */
    'signingKeyAlgorithm'?: ApiConfigsOidcKeyTypeRotatePostRequestSigningKeyAlgorithmEnum;
}

export const ApiConfigsOidcKeyTypeRotatePostRequestSigningKeyAlgorithmEnum = {
    Rsa: 'RSA',
    Ec: 'EC'
} as const;

export type ApiConfigsOidcKeyTypeRotatePostRequestSigningKeyAlgorithmEnum = typeof ApiConfigsOidcKeyTypeRotatePostRequestSigningKeyAlgorithmEnum[keyof typeof ApiConfigsOidcKeyTypeRotatePostRequestSigningKeyAlgorithmEnum];

/**
 * 
 * @export
 * @interface ApiConnectorFactoriesGet200ResponseInner
 */
export interface ApiConnectorFactoriesGet200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorFactoriesGet200ResponseInner
     */
    'type': ApiConnectorFactoriesGet200ResponseInnerTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ApiConnectorFactoriesGet200ResponseInner
     */
    'isDemo'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorFactoriesGet200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorFactoriesGet200ResponseInner
     */
    'target': string;
    /**
     * Validator function
     * @type {object}
     * @memberof ApiConnectorFactoriesGet200ResponseInner
     */
    'name': object;
    /**
     * Validator function
     * @type {object}
     * @memberof ApiConnectorFactoriesGet200ResponseInner
     */
    'description': object;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorFactoriesGet200ResponseInner
     */
    'logo': string;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorFactoriesGet200ResponseInner
     */
    'logoDark': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorFactoriesGet200ResponseInner
     */
    'readme': string;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorFactoriesGet200ResponseInner
     */
    'configTemplate'?: string;
    /**
     * 
     * @type {Array<ApiConnectorsGet200ResponseInnerFormItemsInner>}
     * @memberof ApiConnectorFactoriesGet200ResponseInner
     */
    'formItems'?: Array<ApiConnectorsGet200ResponseInnerFormItemsInner>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ApiConnectorFactoriesGet200ResponseInner
     */
    'customData'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorFactoriesGet200ResponseInner
     */
    'fromEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorFactoriesGet200ResponseInner
     */
    'platform': ApiConnectorFactoriesGet200ResponseInnerPlatformEnum | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApiConnectorFactoriesGet200ResponseInner
     */
    'isStandard'?: boolean;
}

export const ApiConnectorFactoriesGet200ResponseInnerTypeEnum = {
    Email: 'Email',
    Sms: 'Sms',
    Social: 'Social'
} as const;

export type ApiConnectorFactoriesGet200ResponseInnerTypeEnum = typeof ApiConnectorFactoriesGet200ResponseInnerTypeEnum[keyof typeof ApiConnectorFactoriesGet200ResponseInnerTypeEnum];
export const ApiConnectorFactoriesGet200ResponseInnerPlatformEnum = {
    Native: 'Native',
    Universal: 'Universal',
    Web: 'Web'
} as const;

export type ApiConnectorFactoriesGet200ResponseInnerPlatformEnum = typeof ApiConnectorFactoriesGet200ResponseInnerPlatformEnum[keyof typeof ApiConnectorFactoriesGet200ResponseInnerPlatformEnum];

/**
 * 
 * @export
 * @interface ApiConnectorsConnectorIdAuthorizationUriPost200Response
 */
export interface ApiConnectorsConnectorIdAuthorizationUriPost200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsConnectorIdAuthorizationUriPost200Response
     */
    'redirectTo': string;
    /**
     * The URI to navigate for authentication and authorization in the connected social identity provider.
     * @type {any}
     * @memberof ApiConnectorsConnectorIdAuthorizationUriPost200Response
     */
    'redirectUri'?: any;
}
/**
 * 
 * @export
 * @interface ApiConnectorsConnectorIdAuthorizationUriPostRequest
 */
export interface ApiConnectorsConnectorIdAuthorizationUriPostRequest {
    /**
     * A random string generated on the client side to prevent CSRF (Cross-Site Request Forgery) attacks.
     * @type {string}
     * @memberof ApiConnectorsConnectorIdAuthorizationUriPostRequest
     */
    'state': string;
    /**
     * The URI to navigate back to after the user is authenticated by the connected social identity provider and has granted access to the connector.
     * @type {string}
     * @memberof ApiConnectorsConnectorIdAuthorizationUriPostRequest
     */
    'redirectUri': string;
}
/**
 * 
 * @export
 * @interface ApiConnectorsFactoryIdTestPostRequest
 */
export interface ApiConnectorsFactoryIdTestPostRequest {
    /**
     * Phone number to send test message to. If this is set, email will be ignored.
     * @type {string}
     * @memberof ApiConnectorsFactoryIdTestPostRequest
     */
    'phone'?: string;
    /**
     * Email address to send test message to. If phone is set, this will be ignored.
     * @type {string}
     * @memberof ApiConnectorsFactoryIdTestPostRequest
     */
    'email'?: string;
    /**
     * Connector configuration object for testing.
     * @type {object}
     * @memberof ApiConnectorsFactoryIdTestPostRequest
     */
    'config': object;
}
/**
 * 
 * @export
 * @interface ApiConnectorsGet200ResponseInner
 */
export interface ApiConnectorsGet200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsGet200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiConnectorsGet200ResponseInner
     */
    'syncProfile': boolean;
    /**
     * arbitrary
     * @type {object}
     * @memberof ApiConnectorsGet200ResponseInner
     */
    'config': object;
    /**
     * 
     * @type {ApiConnectorsGet200ResponseInnerMetadata}
     * @memberof ApiConnectorsGet200ResponseInner
     */
    'metadata': ApiConnectorsGet200ResponseInnerMetadata;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsGet200ResponseInner
     */
    'connectorId': string;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsGet200ResponseInner
     */
    'target': string;
    /**
     * Validator function
     * @type {object}
     * @memberof ApiConnectorsGet200ResponseInner
     */
    'name': object;
    /**
     * Validator function
     * @type {object}
     * @memberof ApiConnectorsGet200ResponseInner
     */
    'description': object;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsGet200ResponseInner
     */
    'logo': string;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsGet200ResponseInner
     */
    'logoDark': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsGet200ResponseInner
     */
    'readme': string;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsGet200ResponseInner
     */
    'configTemplate'?: string;
    /**
     * 
     * @type {Array<ApiConnectorsGet200ResponseInnerFormItemsInner>}
     * @memberof ApiConnectorsGet200ResponseInner
     */
    'formItems'?: Array<ApiConnectorsGet200ResponseInnerFormItemsInner>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ApiConnectorsGet200ResponseInner
     */
    'customData'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsGet200ResponseInner
     */
    'fromEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsGet200ResponseInner
     */
    'platform': ApiConnectorsGet200ResponseInnerPlatformEnum | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApiConnectorsGet200ResponseInner
     */
    'isStandard'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsGet200ResponseInner
     */
    'type': ApiConnectorsGet200ResponseInnerTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ApiConnectorsGet200ResponseInner
     */
    'isDemo'?: boolean;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ApiConnectorsGet200ResponseInner
     */
    'extraInfo'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof ApiConnectorsGet200ResponseInner
     */
    'usage'?: number;
}

export const ApiConnectorsGet200ResponseInnerPlatformEnum = {
    Native: 'Native',
    Universal: 'Universal',
    Web: 'Web'
} as const;

export type ApiConnectorsGet200ResponseInnerPlatformEnum = typeof ApiConnectorsGet200ResponseInnerPlatformEnum[keyof typeof ApiConnectorsGet200ResponseInnerPlatformEnum];
export const ApiConnectorsGet200ResponseInnerTypeEnum = {
    Email: 'Email',
    Sms: 'Sms',
    Social: 'Social'
} as const;

export type ApiConnectorsGet200ResponseInnerTypeEnum = typeof ApiConnectorsGet200ResponseInnerTypeEnum[keyof typeof ApiConnectorsGet200ResponseInnerTypeEnum];

/**
 * @type ApiConnectorsGet200ResponseInnerFormItemsInner
 * @export
 */
export type ApiConnectorsGet200ResponseInnerFormItemsInner = ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf | ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf1;

/**
 * 
 * @export
 * @interface ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf
 */
export interface ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf {
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf
     */
    'type': string;
    /**
     * 
     * @type {Array<ApiConnectorsGet200ResponseInnerFormItemsInnerOneOfSelectItemsInner>}
     * @memberof ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf
     */
    'selectItems': Array<ApiConnectorsGet200ResponseInnerFormItemsInnerOneOfSelectItemsInner>;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf
     */
    'placeholder'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf
     */
    'required'?: boolean;
    /**
     * 
     * @type {any}
     * @memberof ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf
     */
    'defaultValue'?: any;
    /**
     * 
     * @type {Array<ApiConnectorsGet200ResponseInnerFormItemsInnerOneOfShowConditionsInner>}
     * @memberof ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf
     */
    'showConditions'?: Array<ApiConnectorsGet200ResponseInnerFormItemsInnerOneOfShowConditionsInner>;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf
     */
    'tooltip'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf
     */
    'isConfidential'?: boolean;
}
/**
 * 
 * @export
 * @interface ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf1
 */
export interface ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf1
     */
    'type': ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf1TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf1
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf1
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf1
     */
    'placeholder'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf1
     */
    'required'?: boolean;
    /**
     * 
     * @type {any}
     * @memberof ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf1
     */
    'defaultValue'?: any;
    /**
     * 
     * @type {Array<ApiConnectorsGet200ResponseInnerFormItemsInnerOneOfShowConditionsInner>}
     * @memberof ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf1
     */
    'showConditions'?: Array<ApiConnectorsGet200ResponseInnerFormItemsInnerOneOfShowConditionsInner>;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf1
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf1
     */
    'tooltip'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf1
     */
    'isConfidential'?: boolean;
}

export const ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf1TypeEnum = {
    Text: 'Text',
    Number: 'Number',
    MultilineText: 'MultilineText',
    Switch: 'Switch',
    Json: 'Json'
} as const;

export type ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf1TypeEnum = typeof ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf1TypeEnum[keyof typeof ApiConnectorsGet200ResponseInnerFormItemsInnerOneOf1TypeEnum];

/**
 * 
 * @export
 * @interface ApiConnectorsGet200ResponseInnerFormItemsInnerOneOfSelectItemsInner
 */
export interface ApiConnectorsGet200ResponseInnerFormItemsInnerOneOfSelectItemsInner {
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsGet200ResponseInnerFormItemsInnerOneOfSelectItemsInner
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsGet200ResponseInnerFormItemsInnerOneOfSelectItemsInner
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface ApiConnectorsGet200ResponseInnerFormItemsInnerOneOfShowConditionsInner
 */
export interface ApiConnectorsGet200ResponseInnerFormItemsInnerOneOfShowConditionsInner {
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsGet200ResponseInnerFormItemsInnerOneOfShowConditionsInner
     */
    'targetKey': string;
    /**
     * 
     * @type {any}
     * @memberof ApiConnectorsGet200ResponseInnerFormItemsInnerOneOfShowConditionsInner
     */
    'expectValue'?: any;
}
/**
 * 
 * @export
 * @interface ApiConnectorsGet200ResponseInnerMetadata
 */
export interface ApiConnectorsGet200ResponseInnerMetadata {
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsGet200ResponseInnerMetadata
     */
    'target'?: string;
    /**
     * Validator function
     * @type {object}
     * @memberof ApiConnectorsGet200ResponseInnerMetadata
     */
    'name'?: object;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsGet200ResponseInnerMetadata
     */
    'logo'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsGet200ResponseInnerMetadata
     */
    'logoDark'?: string | null;
}
/**
 * 
 * @export
 * @interface ApiConnectorsIdPatchRequest
 */
export interface ApiConnectorsIdPatchRequest {
    /**
     * The connector config object that will be passed to the connector. The config object should be compatible with the connector factory.
     * @type {object}
     * @memberof ApiConnectorsIdPatchRequest
     */
    'config'?: object;
    /**
     * 
     * @type {ApiConnectorsIdPatchRequestMetadata}
     * @memberof ApiConnectorsIdPatchRequest
     */
    'metadata'?: ApiConnectorsIdPatchRequestMetadata;
    /**
     * Whether to sync user profile from the identity provider to Logto at each sign-in. If `false`, the user profile will only be synced when the user is created.
     * @type {boolean}
     * @memberof ApiConnectorsIdPatchRequest
     */
    'syncProfile'?: boolean;
}
/**
 * Custom connector metadata, will be used to overwrite the default connector metadata.
 * @export
 * @interface ApiConnectorsIdPatchRequestMetadata
 */
export interface ApiConnectorsIdPatchRequestMetadata {
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsIdPatchRequestMetadata
     */
    'target'?: string;
    /**
     * Validator function
     * @type {object}
     * @memberof ApiConnectorsIdPatchRequestMetadata
     */
    'name'?: object;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsIdPatchRequestMetadata
     */
    'logo'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsIdPatchRequestMetadata
     */
    'logoDark'?: string | null;
}
/**
 * 
 * @export
 * @interface ApiConnectorsPostRequest
 */
export interface ApiConnectorsPostRequest {
    /**
     * The connector config object that will be passed to the connector. The config object should be compatible with the connector factory.
     * @type {object}
     * @memberof ApiConnectorsPostRequest
     */
    'config'?: object;
    /**
     * The connector factory ID for creating the connector.
     * @type {string}
     * @memberof ApiConnectorsPostRequest
     */
    'connectorId': string;
    /**
     * 
     * @type {ApiConnectorsPostRequestMetadata}
     * @memberof ApiConnectorsPostRequest
     */
    'metadata'?: ApiConnectorsPostRequestMetadata;
    /**
     * Whether to sync user profile from the identity provider to Logto at each sign-in. If `false`, the user profile will only be synced when the user is created.
     * @type {boolean}
     * @memberof ApiConnectorsPostRequest
     */
    'syncProfile'?: boolean;
    /**
     * The unique ID for the connector. If not provided, a random ID will be generated.
     * @type {string}
     * @memberof ApiConnectorsPostRequest
     */
    'id'?: string;
}
/**
 * Custom connector metadata, will be used to overwrite the default connector factory metadata.
 * @export
 * @interface ApiConnectorsPostRequestMetadata
 */
export interface ApiConnectorsPostRequestMetadata {
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsPostRequestMetadata
     */
    'target'?: string;
    /**
     * Validator function
     * @type {object}
     * @memberof ApiConnectorsPostRequestMetadata
     */
    'name'?: object;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsPostRequestMetadata
     */
    'logo'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiConnectorsPostRequestMetadata
     */
    'logoDark'?: string | null;
}
/**
 * 
 * @export
 * @interface ApiCustomPhrasesGet200ResponseInner
 */
export interface ApiCustomPhrasesGet200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ApiCustomPhrasesGet200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiCustomPhrasesGet200ResponseInner
     */
    'languageTag': string;
    /**
     * 
     * @type {TranslationObject}
     * @memberof ApiCustomPhrasesGet200ResponseInner
     */
    'translation': TranslationObject;
}
/**
 * 
 * @export
 * @interface ApiDashboardUsersActiveGet200Response
 */
export interface ApiDashboardUsersActiveGet200Response {
    /**
     * 
     * @type {Array<ApiDashboardUsersActiveGet200ResponseDauCurveInner>}
     * @memberof ApiDashboardUsersActiveGet200Response
     */
    'dauCurve': Array<ApiDashboardUsersActiveGet200ResponseDauCurveInner>;
    /**
     * 
     * @type {ApiDashboardUsersNewGet200ResponseToday}
     * @memberof ApiDashboardUsersActiveGet200Response
     */
    'dau': ApiDashboardUsersNewGet200ResponseToday;
    /**
     * 
     * @type {ApiDashboardUsersNewGet200ResponseToday}
     * @memberof ApiDashboardUsersActiveGet200Response
     */
    'wau': ApiDashboardUsersNewGet200ResponseToday;
    /**
     * 
     * @type {ApiDashboardUsersNewGet200ResponseToday}
     * @memberof ApiDashboardUsersActiveGet200Response
     */
    'mau': ApiDashboardUsersNewGet200ResponseToday;
}
/**
 * 
 * @export
 * @interface ApiDashboardUsersActiveGet200ResponseDauCurveInner
 */
export interface ApiDashboardUsersActiveGet200ResponseDauCurveInner {
    /**
     * 
     * @type {string}
     * @memberof ApiDashboardUsersActiveGet200ResponseDauCurveInner
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof ApiDashboardUsersActiveGet200ResponseDauCurveInner
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface ApiDashboardUsersNewGet200Response
 */
export interface ApiDashboardUsersNewGet200Response {
    /**
     * 
     * @type {ApiDashboardUsersNewGet200ResponseToday}
     * @memberof ApiDashboardUsersNewGet200Response
     */
    'today': ApiDashboardUsersNewGet200ResponseToday;
    /**
     * 
     * @type {ApiDashboardUsersNewGet200ResponseToday}
     * @memberof ApiDashboardUsersNewGet200Response
     */
    'last7Days': ApiDashboardUsersNewGet200ResponseToday;
}
/**
 * 
 * @export
 * @interface ApiDashboardUsersNewGet200ResponseToday
 */
export interface ApiDashboardUsersNewGet200ResponseToday {
    /**
     * 
     * @type {number}
     * @memberof ApiDashboardUsersNewGet200ResponseToday
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof ApiDashboardUsersNewGet200ResponseToday
     */
    'delta': number;
}
/**
 * 
 * @export
 * @interface ApiDashboardUsersTotalGet200Response
 */
export interface ApiDashboardUsersTotalGet200Response {
    /**
     * 
     * @type {number}
     * @memberof ApiDashboardUsersTotalGet200Response
     */
    'totalUserCount': number;
}
/**
 * 
 * @export
 * @interface ApiDomainsGet200ResponseInner
 */
export interface ApiDomainsGet200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ApiDomainsGet200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiDomainsGet200ResponseInner
     */
    'domain': string;
    /**
     * 
     * @type {string}
     * @memberof ApiDomainsGet200ResponseInner
     */
    'status': ApiDomainsGet200ResponseInnerStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiDomainsGet200ResponseInner
     */
    'errorMessage': string | null;
    /**
     * 
     * @type {Array<ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerDnsRecordsInner>}
     * @memberof ApiDomainsGet200ResponseInner
     */
    'dnsRecords': Array<ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInnerDnsRecordsInner>;
}

export const ApiDomainsGet200ResponseInnerStatusEnum = {
    PendingVerification: 'PendingVerification',
    PendingSsl: 'PendingSsl',
    Active: 'Active',
    Error: 'Error'
} as const;

export type ApiDomainsGet200ResponseInnerStatusEnum = typeof ApiDomainsGet200ResponseInnerStatusEnum[keyof typeof ApiDomainsGet200ResponseInnerStatusEnum];

/**
 * 
 * @export
 * @interface ApiDomainsPostRequest
 */
export interface ApiDomainsPostRequest {
    /**
     * The domain name, e.g. `example.com`.
     * @type {string}
     * @memberof ApiDomainsPostRequest
     */
    'domain': string;
}
/**
 * 
 * @export
 * @interface ApiHooksGet200ResponseInner
 */
export interface ApiHooksGet200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ApiHooksGet200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiHooksGet200ResponseInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiHooksGet200ResponseInner
     */
    'event': ApiHooksGet200ResponseInnerEventEnum | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiHooksGet200ResponseInner
     */
    'events': Array<ApiHooksGet200ResponseInnerEventsEnum>;
    /**
     * 
     * @type {ApiHooksGet200ResponseInnerConfig}
     * @memberof ApiHooksGet200ResponseInner
     */
    'config': ApiHooksGet200ResponseInnerConfig;
    /**
     * 
     * @type {string}
     * @memberof ApiHooksGet200ResponseInner
     */
    'signingKey': string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiHooksGet200ResponseInner
     */
    'enabled': boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiHooksGet200ResponseInner
     */
    'createdAt': number;
    /**
     * 
     * @type {ApiHooksGet200ResponseInnerExecutionStats}
     * @memberof ApiHooksGet200ResponseInner
     */
    'executionStats'?: ApiHooksGet200ResponseInnerExecutionStats;
}

export const ApiHooksGet200ResponseInnerEventEnum = {
    PostRegister: 'PostRegister',
    PostSignIn: 'PostSignIn',
    PostResetPassword: 'PostResetPassword',
    UserCreated: 'User.Created',
    UserDeleted: 'User.Deleted',
    UserDataUpdated: 'User.Data.Updated',
    UserSuspensionStatusUpdated: 'User.SuspensionStatus.Updated',
    RoleCreated: 'Role.Created',
    RoleDeleted: 'Role.Deleted',
    RoleDataUpdated: 'Role.Data.Updated',
    RoleScopesUpdated: 'Role.Scopes.Updated',
    ScopeCreated: 'Scope.Created',
    ScopeDeleted: 'Scope.Deleted',
    ScopeDataUpdated: 'Scope.Data.Updated',
    OrganizationCreated: 'Organization.Created',
    OrganizationDeleted: 'Organization.Deleted',
    OrganizationDataUpdated: 'Organization.Data.Updated',
    OrganizationMembershipUpdated: 'Organization.Membership.Updated',
    OrganizationRoleCreated: 'OrganizationRole.Created',
    OrganizationRoleDeleted: 'OrganizationRole.Deleted',
    OrganizationRoleDataUpdated: 'OrganizationRole.Data.Updated',
    OrganizationRoleScopesUpdated: 'OrganizationRole.Scopes.Updated',
    OrganizationScopeCreated: 'OrganizationScope.Created',
    OrganizationScopeDeleted: 'OrganizationScope.Deleted',
    OrganizationScopeDataUpdated: 'OrganizationScope.Data.Updated'
} as const;

export type ApiHooksGet200ResponseInnerEventEnum = typeof ApiHooksGet200ResponseInnerEventEnum[keyof typeof ApiHooksGet200ResponseInnerEventEnum];
export const ApiHooksGet200ResponseInnerEventsEnum = {
    PostRegister: 'PostRegister',
    PostSignIn: 'PostSignIn',
    PostResetPassword: 'PostResetPassword',
    UserCreated: 'User.Created',
    UserDeleted: 'User.Deleted',
    UserDataUpdated: 'User.Data.Updated',
    UserSuspensionStatusUpdated: 'User.SuspensionStatus.Updated',
    RoleCreated: 'Role.Created',
    RoleDeleted: 'Role.Deleted',
    RoleDataUpdated: 'Role.Data.Updated',
    RoleScopesUpdated: 'Role.Scopes.Updated',
    ScopeCreated: 'Scope.Created',
    ScopeDeleted: 'Scope.Deleted',
    ScopeDataUpdated: 'Scope.Data.Updated',
    OrganizationCreated: 'Organization.Created',
    OrganizationDeleted: 'Organization.Deleted',
    OrganizationDataUpdated: 'Organization.Data.Updated',
    OrganizationMembershipUpdated: 'Organization.Membership.Updated',
    OrganizationRoleCreated: 'OrganizationRole.Created',
    OrganizationRoleDeleted: 'OrganizationRole.Deleted',
    OrganizationRoleDataUpdated: 'OrganizationRole.Data.Updated',
    OrganizationRoleScopesUpdated: 'OrganizationRole.Scopes.Updated',
    OrganizationScopeCreated: 'OrganizationScope.Created',
    OrganizationScopeDeleted: 'OrganizationScope.Deleted',
    OrganizationScopeDataUpdated: 'OrganizationScope.Data.Updated'
} as const;

export type ApiHooksGet200ResponseInnerEventsEnum = typeof ApiHooksGet200ResponseInnerEventsEnum[keyof typeof ApiHooksGet200ResponseInnerEventsEnum];

/**
 * 
 * @export
 * @interface ApiHooksGet200ResponseInnerConfig
 */
export interface ApiHooksGet200ResponseInnerConfig {
    /**
     * 
     * @type {string}
     * @memberof ApiHooksGet200ResponseInnerConfig
     */
    'url': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiHooksGet200ResponseInnerConfig
     */
    'headers'?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof ApiHooksGet200ResponseInnerConfig
     */
    'retries'?: number;
}
/**
 * 
 * @export
 * @interface ApiHooksGet200ResponseInnerExecutionStats
 */
export interface ApiHooksGet200ResponseInnerExecutionStats {
    /**
     * 
     * @type {number}
     * @memberof ApiHooksGet200ResponseInnerExecutionStats
     */
    'successCount': number;
    /**
     * 
     * @type {number}
     * @memberof ApiHooksGet200ResponseInnerExecutionStats
     */
    'requestCount': number;
}
/**
 * 
 * @export
 * @interface ApiHooksIdPatch200Response
 */
export interface ApiHooksIdPatch200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiHooksIdPatch200Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiHooksIdPatch200Response
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiHooksIdPatch200Response
     */
    'event': ApiHooksIdPatch200ResponseEventEnum | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiHooksIdPatch200Response
     */
    'events': Array<ApiHooksIdPatch200ResponseEventsEnum>;
    /**
     * 
     * @type {ApiHooksGet200ResponseInnerConfig}
     * @memberof ApiHooksIdPatch200Response
     */
    'config': ApiHooksGet200ResponseInnerConfig;
    /**
     * 
     * @type {string}
     * @memberof ApiHooksIdPatch200Response
     */
    'signingKey': string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiHooksIdPatch200Response
     */
    'enabled': boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiHooksIdPatch200Response
     */
    'createdAt': number;
}

export const ApiHooksIdPatch200ResponseEventEnum = {
    PostRegister: 'PostRegister',
    PostSignIn: 'PostSignIn',
    PostResetPassword: 'PostResetPassword',
    UserCreated: 'User.Created',
    UserDeleted: 'User.Deleted',
    UserDataUpdated: 'User.Data.Updated',
    UserSuspensionStatusUpdated: 'User.SuspensionStatus.Updated',
    RoleCreated: 'Role.Created',
    RoleDeleted: 'Role.Deleted',
    RoleDataUpdated: 'Role.Data.Updated',
    RoleScopesUpdated: 'Role.Scopes.Updated',
    ScopeCreated: 'Scope.Created',
    ScopeDeleted: 'Scope.Deleted',
    ScopeDataUpdated: 'Scope.Data.Updated',
    OrganizationCreated: 'Organization.Created',
    OrganizationDeleted: 'Organization.Deleted',
    OrganizationDataUpdated: 'Organization.Data.Updated',
    OrganizationMembershipUpdated: 'Organization.Membership.Updated',
    OrganizationRoleCreated: 'OrganizationRole.Created',
    OrganizationRoleDeleted: 'OrganizationRole.Deleted',
    OrganizationRoleDataUpdated: 'OrganizationRole.Data.Updated',
    OrganizationRoleScopesUpdated: 'OrganizationRole.Scopes.Updated',
    OrganizationScopeCreated: 'OrganizationScope.Created',
    OrganizationScopeDeleted: 'OrganizationScope.Deleted',
    OrganizationScopeDataUpdated: 'OrganizationScope.Data.Updated'
} as const;

export type ApiHooksIdPatch200ResponseEventEnum = typeof ApiHooksIdPatch200ResponseEventEnum[keyof typeof ApiHooksIdPatch200ResponseEventEnum];
export const ApiHooksIdPatch200ResponseEventsEnum = {
    PostRegister: 'PostRegister',
    PostSignIn: 'PostSignIn',
    PostResetPassword: 'PostResetPassword',
    UserCreated: 'User.Created',
    UserDeleted: 'User.Deleted',
    UserDataUpdated: 'User.Data.Updated',
    UserSuspensionStatusUpdated: 'User.SuspensionStatus.Updated',
    RoleCreated: 'Role.Created',
    RoleDeleted: 'Role.Deleted',
    RoleDataUpdated: 'Role.Data.Updated',
    RoleScopesUpdated: 'Role.Scopes.Updated',
    ScopeCreated: 'Scope.Created',
    ScopeDeleted: 'Scope.Deleted',
    ScopeDataUpdated: 'Scope.Data.Updated',
    OrganizationCreated: 'Organization.Created',
    OrganizationDeleted: 'Organization.Deleted',
    OrganizationDataUpdated: 'Organization.Data.Updated',
    OrganizationMembershipUpdated: 'Organization.Membership.Updated',
    OrganizationRoleCreated: 'OrganizationRole.Created',
    OrganizationRoleDeleted: 'OrganizationRole.Deleted',
    OrganizationRoleDataUpdated: 'OrganizationRole.Data.Updated',
    OrganizationRoleScopesUpdated: 'OrganizationRole.Scopes.Updated',
    OrganizationScopeCreated: 'OrganizationScope.Created',
    OrganizationScopeDeleted: 'OrganizationScope.Deleted',
    OrganizationScopeDataUpdated: 'OrganizationScope.Data.Updated'
} as const;

export type ApiHooksIdPatch200ResponseEventsEnum = typeof ApiHooksIdPatch200ResponseEventsEnum[keyof typeof ApiHooksIdPatch200ResponseEventsEnum];

/**
 * 
 * @export
 * @interface ApiHooksIdPatchRequest
 */
export interface ApiHooksIdPatchRequest {
    /**
     * The updated name of the hook.
     * @type {string}
     * @memberof ApiHooksIdPatchRequest
     */
    'name'?: string;
    /**
     * Use `events` instead.
     * @type {string}
     * @memberof ApiHooksIdPatchRequest
     * @deprecated
     */
    'event'?: ApiHooksIdPatchRequestEventEnum | null;
    /**
     * An array of updated hook events.
     * @type {Array<string>}
     * @memberof ApiHooksIdPatchRequest
     */
    'events'?: Array<ApiHooksIdPatchRequestEventsEnum>;
    /**
     * 
     * @type {ApiHooksPostRequestConfig}
     * @memberof ApiHooksIdPatchRequest
     */
    'config'?: ApiHooksPostRequestConfig;
    /**
     * 
     * @type {boolean}
     * @memberof ApiHooksIdPatchRequest
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiHooksIdPatchRequest
     */
    'createdAt'?: number;
}

export const ApiHooksIdPatchRequestEventEnum = {
    PostRegister: 'PostRegister',
    PostSignIn: 'PostSignIn',
    PostResetPassword: 'PostResetPassword',
    UserCreated: 'User.Created',
    UserDeleted: 'User.Deleted',
    UserDataUpdated: 'User.Data.Updated',
    UserSuspensionStatusUpdated: 'User.SuspensionStatus.Updated',
    RoleCreated: 'Role.Created',
    RoleDeleted: 'Role.Deleted',
    RoleDataUpdated: 'Role.Data.Updated',
    RoleScopesUpdated: 'Role.Scopes.Updated',
    ScopeCreated: 'Scope.Created',
    ScopeDeleted: 'Scope.Deleted',
    ScopeDataUpdated: 'Scope.Data.Updated',
    OrganizationCreated: 'Organization.Created',
    OrganizationDeleted: 'Organization.Deleted',
    OrganizationDataUpdated: 'Organization.Data.Updated',
    OrganizationMembershipUpdated: 'Organization.Membership.Updated',
    OrganizationRoleCreated: 'OrganizationRole.Created',
    OrganizationRoleDeleted: 'OrganizationRole.Deleted',
    OrganizationRoleDataUpdated: 'OrganizationRole.Data.Updated',
    OrganizationRoleScopesUpdated: 'OrganizationRole.Scopes.Updated',
    OrganizationScopeCreated: 'OrganizationScope.Created',
    OrganizationScopeDeleted: 'OrganizationScope.Deleted',
    OrganizationScopeDataUpdated: 'OrganizationScope.Data.Updated'
} as const;

export type ApiHooksIdPatchRequestEventEnum = typeof ApiHooksIdPatchRequestEventEnum[keyof typeof ApiHooksIdPatchRequestEventEnum];
export const ApiHooksIdPatchRequestEventsEnum = {
    PostRegister: 'PostRegister',
    PostSignIn: 'PostSignIn',
    PostResetPassword: 'PostResetPassword',
    UserCreated: 'User.Created',
    UserDeleted: 'User.Deleted',
    UserDataUpdated: 'User.Data.Updated',
    UserSuspensionStatusUpdated: 'User.SuspensionStatus.Updated',
    RoleCreated: 'Role.Created',
    RoleDeleted: 'Role.Deleted',
    RoleDataUpdated: 'Role.Data.Updated',
    RoleScopesUpdated: 'Role.Scopes.Updated',
    ScopeCreated: 'Scope.Created',
    ScopeDeleted: 'Scope.Deleted',
    ScopeDataUpdated: 'Scope.Data.Updated',
    OrganizationCreated: 'Organization.Created',
    OrganizationDeleted: 'Organization.Deleted',
    OrganizationDataUpdated: 'Organization.Data.Updated',
    OrganizationMembershipUpdated: 'Organization.Membership.Updated',
    OrganizationRoleCreated: 'OrganizationRole.Created',
    OrganizationRoleDeleted: 'OrganizationRole.Deleted',
    OrganizationRoleDataUpdated: 'OrganizationRole.Data.Updated',
    OrganizationRoleScopesUpdated: 'OrganizationRole.Scopes.Updated',
    OrganizationScopeCreated: 'OrganizationScope.Created',
    OrganizationScopeDeleted: 'OrganizationScope.Deleted',
    OrganizationScopeDataUpdated: 'OrganizationScope.Data.Updated'
} as const;

export type ApiHooksIdPatchRequestEventsEnum = typeof ApiHooksIdPatchRequestEventsEnum[keyof typeof ApiHooksIdPatchRequestEventsEnum];

/**
 * 
 * @export
 * @interface ApiHooksIdTestPostRequest
 */
export interface ApiHooksIdTestPostRequest {
    /**
     * An array of hook events for testing.
     * @type {Array<string>}
     * @memberof ApiHooksIdTestPostRequest
     */
    'events': Array<ApiHooksIdTestPostRequestEventsEnum>;
    /**
     * 
     * @type {ApiHooksIdTestPostRequestConfig}
     * @memberof ApiHooksIdTestPostRequest
     */
    'config': ApiHooksIdTestPostRequestConfig;
    /**
     * Use `events` instead.
     * @type {any}
     * @memberof ApiHooksIdTestPostRequest
     * @deprecated
     */
    'event'?: any;
}

export const ApiHooksIdTestPostRequestEventsEnum = {
    PostRegister: 'PostRegister',
    PostSignIn: 'PostSignIn',
    PostResetPassword: 'PostResetPassword',
    UserCreated: 'User.Created',
    UserDeleted: 'User.Deleted',
    UserDataUpdated: 'User.Data.Updated',
    UserSuspensionStatusUpdated: 'User.SuspensionStatus.Updated',
    RoleCreated: 'Role.Created',
    RoleDeleted: 'Role.Deleted',
    RoleDataUpdated: 'Role.Data.Updated',
    RoleScopesUpdated: 'Role.Scopes.Updated',
    ScopeCreated: 'Scope.Created',
    ScopeDeleted: 'Scope.Deleted',
    ScopeDataUpdated: 'Scope.Data.Updated',
    OrganizationCreated: 'Organization.Created',
    OrganizationDeleted: 'Organization.Deleted',
    OrganizationDataUpdated: 'Organization.Data.Updated',
    OrganizationMembershipUpdated: 'Organization.Membership.Updated',
    OrganizationRoleCreated: 'OrganizationRole.Created',
    OrganizationRoleDeleted: 'OrganizationRole.Deleted',
    OrganizationRoleDataUpdated: 'OrganizationRole.Data.Updated',
    OrganizationRoleScopesUpdated: 'OrganizationRole.Scopes.Updated',
    OrganizationScopeCreated: 'OrganizationScope.Created',
    OrganizationScopeDeleted: 'OrganizationScope.Deleted',
    OrganizationScopeDataUpdated: 'OrganizationScope.Data.Updated'
} as const;

export type ApiHooksIdTestPostRequestEventsEnum = typeof ApiHooksIdTestPostRequestEventsEnum[keyof typeof ApiHooksIdTestPostRequestEventsEnum];

/**
 * The hook configuration for testing.
 * @export
 * @interface ApiHooksIdTestPostRequestConfig
 */
export interface ApiHooksIdTestPostRequestConfig {
    /**
     * 
     * @type {string}
     * @memberof ApiHooksIdTestPostRequestConfig
     */
    'url': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiHooksIdTestPostRequestConfig
     */
    'headers'?: { [key: string]: string; };
    /**
     * Now the retry times is fixed to 3. Keep for backward compatibility.
     * @type {number}
     * @memberof ApiHooksIdTestPostRequestConfig
     * @deprecated
     */
    'retries'?: number;
}
/**
 * 
 * @export
 * @interface ApiHooksPostRequest
 */
export interface ApiHooksPostRequest {
    /**
     * The name of the hook.
     * @type {string}
     * @memberof ApiHooksPostRequest
     */
    'name'?: string;
    /**
     * Use `events` instead.
     * @type {string}
     * @memberof ApiHooksPostRequest
     * @deprecated
     */
    'event'?: ApiHooksPostRequestEventEnum;
    /**
     * An array of hook events.
     * @type {Array<string>}
     * @memberof ApiHooksPostRequest
     */
    'events'?: Array<ApiHooksPostRequestEventsEnum>;
    /**
     * 
     * @type {ApiHooksPostRequestConfig}
     * @memberof ApiHooksPostRequest
     */
    'config': ApiHooksPostRequestConfig;
    /**
     * 
     * @type {boolean}
     * @memberof ApiHooksPostRequest
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiHooksPostRequest
     */
    'createdAt'?: number;
}

export const ApiHooksPostRequestEventEnum = {
    PostRegister: 'PostRegister',
    PostSignIn: 'PostSignIn',
    PostResetPassword: 'PostResetPassword',
    UserCreated: 'User.Created',
    UserDeleted: 'User.Deleted',
    UserDataUpdated: 'User.Data.Updated',
    UserSuspensionStatusUpdated: 'User.SuspensionStatus.Updated',
    RoleCreated: 'Role.Created',
    RoleDeleted: 'Role.Deleted',
    RoleDataUpdated: 'Role.Data.Updated',
    RoleScopesUpdated: 'Role.Scopes.Updated',
    ScopeCreated: 'Scope.Created',
    ScopeDeleted: 'Scope.Deleted',
    ScopeDataUpdated: 'Scope.Data.Updated',
    OrganizationCreated: 'Organization.Created',
    OrganizationDeleted: 'Organization.Deleted',
    OrganizationDataUpdated: 'Organization.Data.Updated',
    OrganizationMembershipUpdated: 'Organization.Membership.Updated',
    OrganizationRoleCreated: 'OrganizationRole.Created',
    OrganizationRoleDeleted: 'OrganizationRole.Deleted',
    OrganizationRoleDataUpdated: 'OrganizationRole.Data.Updated',
    OrganizationRoleScopesUpdated: 'OrganizationRole.Scopes.Updated',
    OrganizationScopeCreated: 'OrganizationScope.Created',
    OrganizationScopeDeleted: 'OrganizationScope.Deleted',
    OrganizationScopeDataUpdated: 'OrganizationScope.Data.Updated'
} as const;

export type ApiHooksPostRequestEventEnum = typeof ApiHooksPostRequestEventEnum[keyof typeof ApiHooksPostRequestEventEnum];
export const ApiHooksPostRequestEventsEnum = {
    PostRegister: 'PostRegister',
    PostSignIn: 'PostSignIn',
    PostResetPassword: 'PostResetPassword',
    UserCreated: 'User.Created',
    UserDeleted: 'User.Deleted',
    UserDataUpdated: 'User.Data.Updated',
    UserSuspensionStatusUpdated: 'User.SuspensionStatus.Updated',
    RoleCreated: 'Role.Created',
    RoleDeleted: 'Role.Deleted',
    RoleDataUpdated: 'Role.Data.Updated',
    RoleScopesUpdated: 'Role.Scopes.Updated',
    ScopeCreated: 'Scope.Created',
    ScopeDeleted: 'Scope.Deleted',
    ScopeDataUpdated: 'Scope.Data.Updated',
    OrganizationCreated: 'Organization.Created',
    OrganizationDeleted: 'Organization.Deleted',
    OrganizationDataUpdated: 'Organization.Data.Updated',
    OrganizationMembershipUpdated: 'Organization.Membership.Updated',
    OrganizationRoleCreated: 'OrganizationRole.Created',
    OrganizationRoleDeleted: 'OrganizationRole.Deleted',
    OrganizationRoleDataUpdated: 'OrganizationRole.Data.Updated',
    OrganizationRoleScopesUpdated: 'OrganizationRole.Scopes.Updated',
    OrganizationScopeCreated: 'OrganizationScope.Created',
    OrganizationScopeDeleted: 'OrganizationScope.Deleted',
    OrganizationScopeDataUpdated: 'OrganizationScope.Data.Updated'
} as const;

export type ApiHooksPostRequestEventsEnum = typeof ApiHooksPostRequestEventsEnum[keyof typeof ApiHooksPostRequestEventsEnum];

/**
 * 
 * @export
 * @interface ApiHooksPostRequestConfig
 */
export interface ApiHooksPostRequestConfig {
    /**
     * 
     * @type {string}
     * @memberof ApiHooksPostRequestConfig
     */
    'url': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiHooksPostRequestConfig
     */
    'headers'?: { [key: string]: string; };
    /**
     * Now the retry times is fixed to 3. Keep for backward compatibility.
     * @type {number}
     * @memberof ApiHooksPostRequestConfig
     * @deprecated
     */
    'retries'?: number;
}
/**
 * @type ApiInteractionBindMfaPostRequest
 * @export
 */
export type ApiInteractionBindMfaPostRequest = ApiInteractionBindMfaPostRequestOneOf | ApiInteractionBindMfaPostRequestOneOf1 | ApiInteractionBindMfaPostRequestOneOf2;

/**
 * 
 * @export
 * @interface ApiInteractionBindMfaPostRequestOneOf
 */
export interface ApiInteractionBindMfaPostRequestOneOf {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionBindMfaPostRequestOneOf
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionBindMfaPostRequestOneOf
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface ApiInteractionBindMfaPostRequestOneOf1
 */
export interface ApiInteractionBindMfaPostRequestOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1
     */
    'rawId': string;
    /**
     * 
     * @type {ApiInteractionBindMfaPostRequestOneOf1Response}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1
     */
    'response': ApiInteractionBindMfaPostRequestOneOf1Response;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1
     */
    'authenticatorAttachment'?: ApiInteractionBindMfaPostRequestOneOf1AuthenticatorAttachmentEnum;
    /**
     * 
     * @type {ApiInteractionBindMfaPostRequestOneOf1ClientExtensionResults}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1
     */
    'clientExtensionResults': ApiInteractionBindMfaPostRequestOneOf1ClientExtensionResults;
}

export const ApiInteractionBindMfaPostRequestOneOf1AuthenticatorAttachmentEnum = {
    CrossPlatform: 'cross-platform',
    Platform: 'platform'
} as const;

export type ApiInteractionBindMfaPostRequestOneOf1AuthenticatorAttachmentEnum = typeof ApiInteractionBindMfaPostRequestOneOf1AuthenticatorAttachmentEnum[keyof typeof ApiInteractionBindMfaPostRequestOneOf1AuthenticatorAttachmentEnum];

/**
 * 
 * @export
 * @interface ApiInteractionBindMfaPostRequestOneOf1ClientExtensionResults
 */
export interface ApiInteractionBindMfaPostRequestOneOf1ClientExtensionResults {
    /**
     * 
     * @type {boolean}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1ClientExtensionResults
     */
    'appid'?: boolean;
    /**
     * 
     * @type {ApiInteractionBindMfaPostRequestOneOf1ClientExtensionResultsCrepProps}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1ClientExtensionResults
     */
    'crepProps'?: ApiInteractionBindMfaPostRequestOneOf1ClientExtensionResultsCrepProps;
    /**
     * 
     * @type {boolean}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1ClientExtensionResults
     */
    'hmacCreateSecret'?: boolean;
}
/**
 * 
 * @export
 * @interface ApiInteractionBindMfaPostRequestOneOf1ClientExtensionResultsCrepProps
 */
export interface ApiInteractionBindMfaPostRequestOneOf1ClientExtensionResultsCrepProps {
    /**
     * 
     * @type {boolean}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1ClientExtensionResultsCrepProps
     */
    'rk'?: boolean;
}
/**
 * 
 * @export
 * @interface ApiInteractionBindMfaPostRequestOneOf1Response
 */
export interface ApiInteractionBindMfaPostRequestOneOf1Response {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1Response
     */
    'clientDataJSON': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1Response
     */
    'attestationObject': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1Response
     */
    'authenticatorData'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1Response
     */
    'transports'?: Array<ApiInteractionBindMfaPostRequestOneOf1ResponseTransportsEnum>;
    /**
     * 
     * @type {number}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1Response
     */
    'publicKeyAlgorithm'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1Response
     */
    'publicKey'?: string;
}

export const ApiInteractionBindMfaPostRequestOneOf1ResponseTransportsEnum = {
    Usb: 'usb',
    Nfc: 'nfc',
    Ble: 'ble',
    Internal: 'internal',
    Cable: 'cable',
    Hybrid: 'hybrid',
    SmartCard: 'smart-card'
} as const;

export type ApiInteractionBindMfaPostRequestOneOf1ResponseTransportsEnum = typeof ApiInteractionBindMfaPostRequestOneOf1ResponseTransportsEnum[keyof typeof ApiInteractionBindMfaPostRequestOneOf1ResponseTransportsEnum];

/**
 * 
 * @export
 * @interface ApiInteractionBindMfaPostRequestOneOf2
 */
export interface ApiInteractionBindMfaPostRequestOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionBindMfaPostRequestOneOf2
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ApiInteractionConsentGet200Response
 */
export interface ApiInteractionConsentGet200Response {
    /**
     * 
     * @type {ApiInteractionConsentGet200ResponseApplication}
     * @memberof ApiInteractionConsentGet200Response
     */
    'application': ApiInteractionConsentGet200ResponseApplication;
    /**
     * 
     * @type {ApiInteractionConsentGet200ResponseUser}
     * @memberof ApiInteractionConsentGet200Response
     */
    'user': ApiInteractionConsentGet200ResponseUser;
    /**
     * 
     * @type {Array<ApiInteractionConsentGet200ResponseOrganizationsInner>}
     * @memberof ApiInteractionConsentGet200Response
     */
    'organizations'?: Array<ApiInteractionConsentGet200ResponseOrganizationsInner>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiInteractionConsentGet200Response
     */
    'missingOIDCScope'?: Array<string>;
    /**
     * 
     * @type {Array<ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInner>}
     * @memberof ApiInteractionConsentGet200Response
     */
    'missingResourceScopes'?: Array<ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInner>;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200Response
     */
    'redirectUri': string;
}
/**
 * 
 * @export
 * @interface ApiInteractionConsentGet200ResponseApplication
 */
export interface ApiInteractionConsentGet200ResponseApplication {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseApplication
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseApplication
     */
    'name': string;
    /**
     * 
     * @type {ApiInteractionConsentGet200ResponseApplicationBranding}
     * @memberof ApiInteractionConsentGet200ResponseApplication
     */
    'branding'?: ApiInteractionConsentGet200ResponseApplicationBranding;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseApplication
     */
    'displayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseApplication
     */
    'privacyPolicyUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseApplication
     */
    'termsOfUseUrl'?: string | null;
}
/**
 * 
 * @export
 * @interface ApiInteractionConsentGet200ResponseApplicationBranding
 */
export interface ApiInteractionConsentGet200ResponseApplicationBranding {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseApplicationBranding
     */
    'logoUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseApplicationBranding
     */
    'darkLogoUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseApplicationBranding
     */
    'favicon'?: string;
}
/**
 * 
 * @export
 * @interface ApiInteractionConsentGet200ResponseOrganizationsInner
 */
export interface ApiInteractionConsentGet200ResponseOrganizationsInner {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseOrganizationsInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseOrganizationsInner
     */
    'name': string;
    /**
     * 
     * @type {Array<ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInner>}
     * @memberof ApiInteractionConsentGet200ResponseOrganizationsInner
     */
    'missingResourceScopes'?: Array<ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInner>;
}
/**
 * 
 * @export
 * @interface ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInner
 */
export interface ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInner {
    /**
     * 
     * @type {ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerResource}
     * @memberof ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInner
     */
    'resource': ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerResource;
    /**
     * 
     * @type {Array<ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerScopesInner>}
     * @memberof ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInner
     */
    'scopes': Array<ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerScopesInner>;
}
/**
 * 
 * @export
 * @interface ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerResource
 */
export interface ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerResource {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerResource
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerResource
     */
    'indicator': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerResource
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerScopesInner
 */
export interface ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerScopesInner {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerScopesInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerScopesInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerScopesInner
     */
    'description': string | null;
}
/**
 * 
 * @export
 * @interface ApiInteractionConsentGet200ResponseUser
 */
export interface ApiInteractionConsentGet200ResponseUser {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseUser
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseUser
     */
    'name': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseUser
     */
    'avatar': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseUser
     */
    'username': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseUser
     */
    'primaryEmail': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseUser
     */
    'primaryPhone': string | null;
}
/**
 * 
 * @export
 * @interface ApiInteractionConsentPostRequest
 */
export interface ApiInteractionConsentPostRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiInteractionConsentPostRequest
     */
    'organizationIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ApiInteractionEventPutRequest
 */
export interface ApiInteractionEventPutRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionEventPutRequest
     */
    'event': ApiInteractionEventPutRequestEventEnum;
}

export const ApiInteractionEventPutRequestEventEnum = {
    SignIn: 'SignIn',
    Register: 'Register',
    ForgotPassword: 'ForgotPassword'
} as const;

export type ApiInteractionEventPutRequestEventEnum = typeof ApiInteractionEventPutRequestEventEnum[keyof typeof ApiInteractionEventPutRequestEventEnum];

/**
 * @type ApiInteractionMfaPutRequest
 * @export
 */
export type ApiInteractionMfaPutRequest = ApiInteractionBindMfaPostRequestOneOf | ApiInteractionMfaPutRequestOneOf | ApiInteractionMfaPutRequestOneOf1;

/**
 * 
 * @export
 * @interface ApiInteractionMfaPutRequestOneOf
 */
export interface ApiInteractionMfaPutRequestOneOf {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionMfaPutRequestOneOf
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionMfaPutRequestOneOf
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionMfaPutRequestOneOf
     */
    'rawId': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionMfaPutRequestOneOf
     */
    'authenticatorAttachment'?: ApiInteractionMfaPutRequestOneOfAuthenticatorAttachmentEnum;
    /**
     * 
     * @type {ApiInteractionBindMfaPostRequestOneOf1ClientExtensionResults}
     * @memberof ApiInteractionMfaPutRequestOneOf
     */
    'clientExtensionResults': ApiInteractionBindMfaPostRequestOneOf1ClientExtensionResults;
    /**
     * 
     * @type {ApiInteractionMfaPutRequestOneOfResponse}
     * @memberof ApiInteractionMfaPutRequestOneOf
     */
    'response': ApiInteractionMfaPutRequestOneOfResponse;
}

export const ApiInteractionMfaPutRequestOneOfAuthenticatorAttachmentEnum = {
    CrossPlatform: 'cross-platform',
    Platform: 'platform'
} as const;

export type ApiInteractionMfaPutRequestOneOfAuthenticatorAttachmentEnum = typeof ApiInteractionMfaPutRequestOneOfAuthenticatorAttachmentEnum[keyof typeof ApiInteractionMfaPutRequestOneOfAuthenticatorAttachmentEnum];

/**
 * 
 * @export
 * @interface ApiInteractionMfaPutRequestOneOf1
 */
export interface ApiInteractionMfaPutRequestOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionMfaPutRequestOneOf1
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionMfaPutRequestOneOf1
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface ApiInteractionMfaPutRequestOneOfResponse
 */
export interface ApiInteractionMfaPutRequestOneOfResponse {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionMfaPutRequestOneOfResponse
     */
    'clientDataJSON': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionMfaPutRequestOneOfResponse
     */
    'authenticatorData': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionMfaPutRequestOneOfResponse
     */
    'signature': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionMfaPutRequestOneOfResponse
     */
    'userHandle'?: string;
}
/**
 * 
 * @export
 * @interface ApiInteractionMfaSkippedPutRequest
 */
export interface ApiInteractionMfaSkippedPutRequest {
    /**
     * 
     * @type {boolean}
     * @memberof ApiInteractionMfaSkippedPutRequest
     */
    'mfaSkipped': boolean;
}
/**
 * 
 * @export
 * @interface ApiInteractionPutRequest
 */
export interface ApiInteractionPutRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequest
     */
    'event': ApiInteractionPutRequestEventEnum;
    /**
     * 
     * @type {ApiInteractionPutRequestIdentifier}
     * @memberof ApiInteractionPutRequest
     */
    'identifier'?: ApiInteractionPutRequestIdentifier;
    /**
     * 
     * @type {ApiInteractionPutRequestProfile}
     * @memberof ApiInteractionPutRequest
     */
    'profile'?: ApiInteractionPutRequestProfile;
}

export const ApiInteractionPutRequestEventEnum = {
    SignIn: 'SignIn',
    Register: 'Register',
    ForgotPassword: 'ForgotPassword'
} as const;

export type ApiInteractionPutRequestEventEnum = typeof ApiInteractionPutRequestEventEnum[keyof typeof ApiInteractionPutRequestEventEnum];

/**
 * @type ApiInteractionPutRequestIdentifier
 * @export
 */
export type ApiInteractionPutRequestIdentifier = ApiInteractionPutRequestIdentifierOneOf | ApiInteractionPutRequestIdentifierOneOf1 | ApiInteractionPutRequestIdentifierOneOf2 | ApiInteractionPutRequestIdentifierOneOf3 | ApiInteractionPutRequestIdentifierOneOf4 | ApiInteractionPutRequestIdentifierOneOf5 | ApiInteractionPutRequestIdentifierOneOf6 | ApiInteractionPutRequestIdentifierOneOf7;

/**
 * 
 * @export
 * @interface ApiInteractionPutRequestIdentifierOneOf
 */
export interface ApiInteractionPutRequestIdentifierOneOf {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestIdentifierOneOf
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestIdentifierOneOf
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface ApiInteractionPutRequestIdentifierOneOf1
 */
export interface ApiInteractionPutRequestIdentifierOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestIdentifierOneOf1
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestIdentifierOneOf1
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface ApiInteractionPutRequestIdentifierOneOf2
 */
export interface ApiInteractionPutRequestIdentifierOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestIdentifierOneOf2
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestIdentifierOneOf2
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface ApiInteractionPutRequestIdentifierOneOf3
 */
export interface ApiInteractionPutRequestIdentifierOneOf3 {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestIdentifierOneOf3
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestIdentifierOneOf3
     */
    'verificationCode': string;
}
/**
 * 
 * @export
 * @interface ApiInteractionPutRequestIdentifierOneOf4
 */
export interface ApiInteractionPutRequestIdentifierOneOf4 {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestIdentifierOneOf4
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestIdentifierOneOf4
     */
    'verificationCode': string;
}
/**
 * 
 * @export
 * @interface ApiInteractionPutRequestIdentifierOneOf5
 */
export interface ApiInteractionPutRequestIdentifierOneOf5 {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestIdentifierOneOf5
     */
    'connectorId': string;
    /**
     * arbitrary
     * @type {object}
     * @memberof ApiInteractionPutRequestIdentifierOneOf5
     */
    'connectorData': object;
}
/**
 * 
 * @export
 * @interface ApiInteractionPutRequestIdentifierOneOf6
 */
export interface ApiInteractionPutRequestIdentifierOneOf6 {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestIdentifierOneOf6
     */
    'connectorId': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestIdentifierOneOf6
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface ApiInteractionPutRequestIdentifierOneOf7
 */
export interface ApiInteractionPutRequestIdentifierOneOf7 {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestIdentifierOneOf7
     */
    'connectorId': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestIdentifierOneOf7
     */
    'phone': string;
}
/**
 * 
 * @export
 * @interface ApiInteractionPutRequestProfile
 */
export interface ApiInteractionPutRequestProfile {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestProfile
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestProfile
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestProfile
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestProfile
     */
    'connectorId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestProfile
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest
 */
export interface ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest
     */
    'state': string;
    /**
     * Validator function
     * @type {object}
     * @memberof ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest
     */
    'redirectUri': object;
}
/**
 * 
 * @export
 * @interface ApiInteractionSubmitPost200Response
 */
export interface ApiInteractionSubmitPost200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionSubmitPost200Response
     */
    'redirectTo': string;
}
/**
 * 
 * @export
 * @interface ApiInteractionVerificationSocialAuthorizationUriPostRequest
 */
export interface ApiInteractionVerificationSocialAuthorizationUriPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationSocialAuthorizationUriPostRequest
     */
    'connectorId': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationSocialAuthorizationUriPostRequest
     */
    'state': string;
    /**
     * Validator function
     * @type {object}
     * @memberof ApiInteractionVerificationSocialAuthorizationUriPostRequest
     */
    'redirectUri': object;
}
/**
 * 
 * @export
 * @interface ApiInteractionVerificationTotpPost200Response
 */
export interface ApiInteractionVerificationTotpPost200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationTotpPost200Response
     */
    'secret': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationTotpPost200Response
     */
    'secretQrCode': string;
}
/**
 * @type ApiInteractionVerificationVerificationCodePostRequest
 * @export
 */
export type ApiInteractionVerificationVerificationCodePostRequest = ApiInteractionVerificationVerificationCodePostRequestOneOf | ApiInteractionVerificationVerificationCodePostRequestOneOf1;

/**
 * 
 * @export
 * @interface ApiInteractionVerificationVerificationCodePostRequestOneOf
 */
export interface ApiInteractionVerificationVerificationCodePostRequestOneOf {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationVerificationCodePostRequestOneOf
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface ApiInteractionVerificationVerificationCodePostRequestOneOf1
 */
export interface ApiInteractionVerificationVerificationCodePostRequestOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationVerificationCodePostRequestOneOf1
     */
    'phone': string;
}
/**
 * 
 * @export
 * @interface ApiInteractionVerificationWebauthnAuthenticationPost200Response
 */
export interface ApiInteractionVerificationWebauthnAuthenticationPost200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnAuthenticationPost200Response
     */
    'challenge': string;
    /**
     * 
     * @type {number}
     * @memberof ApiInteractionVerificationWebauthnAuthenticationPost200Response
     */
    'timeout'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnAuthenticationPost200Response
     */
    'rpId'?: string;
    /**
     * 
     * @type {Array<ApiInteractionVerificationWebauthnRegistrationPost200ResponseExcludeCredentialsInner>}
     * @memberof ApiInteractionVerificationWebauthnAuthenticationPost200Response
     */
    'allowCredentials'?: Array<ApiInteractionVerificationWebauthnRegistrationPost200ResponseExcludeCredentialsInner>;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnAuthenticationPost200Response
     */
    'userVerification'?: ApiInteractionVerificationWebauthnAuthenticationPost200ResponseUserVerificationEnum;
    /**
     * 
     * @type {ApiInteractionVerificationWebauthnRegistrationPost200ResponseExtensions}
     * @memberof ApiInteractionVerificationWebauthnAuthenticationPost200Response
     */
    'extensions'?: ApiInteractionVerificationWebauthnRegistrationPost200ResponseExtensions;
}

export const ApiInteractionVerificationWebauthnAuthenticationPost200ResponseUserVerificationEnum = {
    Required: 'required',
    Preferred: 'preferred',
    Discouraged: 'discouraged'
} as const;

export type ApiInteractionVerificationWebauthnAuthenticationPost200ResponseUserVerificationEnum = typeof ApiInteractionVerificationWebauthnAuthenticationPost200ResponseUserVerificationEnum[keyof typeof ApiInteractionVerificationWebauthnAuthenticationPost200ResponseUserVerificationEnum];

/**
 * 
 * @export
 * @interface ApiInteractionVerificationWebauthnRegistrationPost200Response
 */
export interface ApiInteractionVerificationWebauthnRegistrationPost200Response {
    /**
     * 
     * @type {ApiInteractionVerificationWebauthnRegistrationPost200ResponseRp}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200Response
     */
    'rp': ApiInteractionVerificationWebauthnRegistrationPost200ResponseRp;
    /**
     * 
     * @type {ApiInteractionVerificationWebauthnRegistrationPost200ResponseUser}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200Response
     */
    'user': ApiInteractionVerificationWebauthnRegistrationPost200ResponseUser;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200Response
     */
    'challenge': string;
    /**
     * 
     * @type {Array<ApiInteractionVerificationWebauthnRegistrationPost200ResponsePubKeyCredParamsInner>}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200Response
     */
    'pubKeyCredParams': Array<ApiInteractionVerificationWebauthnRegistrationPost200ResponsePubKeyCredParamsInner>;
    /**
     * 
     * @type {number}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200Response
     */
    'timeout'?: number;
    /**
     * 
     * @type {Array<ApiInteractionVerificationWebauthnRegistrationPost200ResponseExcludeCredentialsInner>}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200Response
     */
    'excludeCredentials'?: Array<ApiInteractionVerificationWebauthnRegistrationPost200ResponseExcludeCredentialsInner>;
    /**
     * 
     * @type {ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelection}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200Response
     */
    'authenticatorSelection'?: ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelection;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200Response
     */
    'attestation'?: ApiInteractionVerificationWebauthnRegistrationPost200ResponseAttestationEnum;
    /**
     * 
     * @type {ApiInteractionVerificationWebauthnRegistrationPost200ResponseExtensions}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200Response
     */
    'extensions'?: ApiInteractionVerificationWebauthnRegistrationPost200ResponseExtensions;
}

export const ApiInteractionVerificationWebauthnRegistrationPost200ResponseAttestationEnum = {
    None: 'none',
    Indirect: 'indirect',
    Direct: 'direct',
    Enterprise: 'enterprise'
} as const;

export type ApiInteractionVerificationWebauthnRegistrationPost200ResponseAttestationEnum = typeof ApiInteractionVerificationWebauthnRegistrationPost200ResponseAttestationEnum[keyof typeof ApiInteractionVerificationWebauthnRegistrationPost200ResponseAttestationEnum];

/**
 * 
 * @export
 * @interface ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelection
 */
export interface ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelection {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelection
     */
    'authenticatorAttachment'?: ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelectionAuthenticatorAttachmentEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelection
     */
    'requireResidentKey'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelection
     */
    'residentKey'?: ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelectionResidentKeyEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelection
     */
    'userVerification'?: ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelectionUserVerificationEnum;
}

export const ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelectionAuthenticatorAttachmentEnum = {
    Platform: 'platform',
    CrossPlatform: 'cross-platform'
} as const;

export type ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelectionAuthenticatorAttachmentEnum = typeof ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelectionAuthenticatorAttachmentEnum[keyof typeof ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelectionAuthenticatorAttachmentEnum];
export const ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelectionResidentKeyEnum = {
    Discouraged: 'discouraged',
    Preferred: 'preferred',
    Required: 'required'
} as const;

export type ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelectionResidentKeyEnum = typeof ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelectionResidentKeyEnum[keyof typeof ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelectionResidentKeyEnum];
export const ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelectionUserVerificationEnum = {
    Required: 'required',
    Preferred: 'preferred',
    Discouraged: 'discouraged'
} as const;

export type ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelectionUserVerificationEnum = typeof ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelectionUserVerificationEnum[keyof typeof ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelectionUserVerificationEnum];

/**
 * 
 * @export
 * @interface ApiInteractionVerificationWebauthnRegistrationPost200ResponseExcludeCredentialsInner
 */
export interface ApiInteractionVerificationWebauthnRegistrationPost200ResponseExcludeCredentialsInner {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponseExcludeCredentialsInner
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponseExcludeCredentialsInner
     */
    'id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponseExcludeCredentialsInner
     */
    'transports'?: Array<ApiInteractionVerificationWebauthnRegistrationPost200ResponseExcludeCredentialsInnerTransportsEnum>;
}

export const ApiInteractionVerificationWebauthnRegistrationPost200ResponseExcludeCredentialsInnerTransportsEnum = {
    Usb: 'usb',
    Nfc: 'nfc',
    Ble: 'ble',
    Internal: 'internal',
    Cable: 'cable',
    Hybrid: 'hybrid',
    SmartCard: 'smart-card'
} as const;

export type ApiInteractionVerificationWebauthnRegistrationPost200ResponseExcludeCredentialsInnerTransportsEnum = typeof ApiInteractionVerificationWebauthnRegistrationPost200ResponseExcludeCredentialsInnerTransportsEnum[keyof typeof ApiInteractionVerificationWebauthnRegistrationPost200ResponseExcludeCredentialsInnerTransportsEnum];

/**
 * 
 * @export
 * @interface ApiInteractionVerificationWebauthnRegistrationPost200ResponseExtensions
 */
export interface ApiInteractionVerificationWebauthnRegistrationPost200ResponseExtensions {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponseExtensions
     */
    'appid'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponseExtensions
     */
    'credProps'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponseExtensions
     */
    'hmacCreateSecret'?: boolean;
}
/**
 * 
 * @export
 * @interface ApiInteractionVerificationWebauthnRegistrationPost200ResponsePubKeyCredParamsInner
 */
export interface ApiInteractionVerificationWebauthnRegistrationPost200ResponsePubKeyCredParamsInner {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponsePubKeyCredParamsInner
     */
    'type': string;
    /**
     * 
     * @type {number}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponsePubKeyCredParamsInner
     */
    'alg': number;
}
/**
 * 
 * @export
 * @interface ApiInteractionVerificationWebauthnRegistrationPost200ResponseRp
 */
export interface ApiInteractionVerificationWebauthnRegistrationPost200ResponseRp {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponseRp
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponseRp
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface ApiInteractionVerificationWebauthnRegistrationPost200ResponseUser
 */
export interface ApiInteractionVerificationWebauthnRegistrationPost200ResponseUser {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponseUser
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponseUser
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponseUser
     */
    'displayName': string;
}
/**
 * 
 * @export
 * @interface ApiLogsGet200ResponseInner
 */
export interface ApiLogsGet200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ApiLogsGet200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiLogsGet200ResponseInner
     */
    'key': string;
    /**
     * 
     * @type {ApiLogsGet200ResponseInnerPayload}
     * @memberof ApiLogsGet200ResponseInner
     */
    'payload': ApiLogsGet200ResponseInnerPayload;
    /**
     * 
     * @type {number}
     * @memberof ApiLogsGet200ResponseInner
     */
    'createdAt': number;
}
/**
 * 
 * @export
 * @interface ApiLogsGet200ResponseInnerPayload
 */
export interface ApiLogsGet200ResponseInnerPayload {
    /**
     * 
     * @type {string}
     * @memberof ApiLogsGet200ResponseInnerPayload
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ApiLogsGet200ResponseInnerPayload
     */
    'result': ApiLogsGet200ResponseInnerPayloadResultEnum;
    /**
     * 
     * @type {ApiLogsGet200ResponseInnerPayloadError}
     * @memberof ApiLogsGet200ResponseInnerPayload
     */
    'error'?: ApiLogsGet200ResponseInnerPayloadError;
    /**
     * 
     * @type {string}
     * @memberof ApiLogsGet200ResponseInnerPayload
     */
    'ip'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiLogsGet200ResponseInnerPayload
     */
    'userAgent'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiLogsGet200ResponseInnerPayload
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiLogsGet200ResponseInnerPayload
     */
    'applicationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiLogsGet200ResponseInnerPayload
     */
    'sessionId'?: string;
}

export const ApiLogsGet200ResponseInnerPayloadResultEnum = {
    Success: 'Success',
    Error: 'Error'
} as const;

export type ApiLogsGet200ResponseInnerPayloadResultEnum = typeof ApiLogsGet200ResponseInnerPayloadResultEnum[keyof typeof ApiLogsGet200ResponseInnerPayloadResultEnum];

/**
 * @type ApiLogsGet200ResponseInnerPayloadError
 * @export
 */
export type ApiLogsGet200ResponseInnerPayloadError = string | { [key: string]: any; };

/**
 * 
 * @export
 * @interface ApiOrganizationInvitationsIdGet200Response
 */
export interface ApiOrganizationInvitationsIdGet200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiOrganizationInvitationsIdGet200Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiOrganizationInvitationsIdGet200Response
     */
    'inviterId': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiOrganizationInvitationsIdGet200Response
     */
    'invitee': string;
    /**
     * 
     * @type {string}
     * @memberof ApiOrganizationInvitationsIdGet200Response
     */
    'acceptedUserId': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiOrganizationInvitationsIdGet200Response
     */
    'organizationId': string;
    /**
     * 
     * @type {string}
     * @memberof ApiOrganizationInvitationsIdGet200Response
     */
    'status': ApiOrganizationInvitationsIdGet200ResponseStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof ApiOrganizationInvitationsIdGet200Response
     */
    'createdAt': number;
    /**
     * 
     * @type {number}
     * @memberof ApiOrganizationInvitationsIdGet200Response
     */
    'updatedAt': number;
    /**
     * 
     * @type {number}
     * @memberof ApiOrganizationInvitationsIdGet200Response
     */
    'expiresAt': number;
    /**
     * 
     * @type {Array<ApiUsersUserIdOrganizationsGet200ResponseInnerOrganizationRolesInner>}
     * @memberof ApiOrganizationInvitationsIdGet200Response
     */
    'organizationRoles': Array<ApiUsersUserIdOrganizationsGet200ResponseInnerOrganizationRolesInner>;
}

export const ApiOrganizationInvitationsIdGet200ResponseStatusEnum = {
    Pending: 'Pending',
    Accepted: 'Accepted',
    Expired: 'Expired',
    Revoked: 'Revoked'
} as const;

export type ApiOrganizationInvitationsIdGet200ResponseStatusEnum = typeof ApiOrganizationInvitationsIdGet200ResponseStatusEnum[keyof typeof ApiOrganizationInvitationsIdGet200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface ApiOrganizationInvitationsIdStatusPutRequest
 */
export interface ApiOrganizationInvitationsIdStatusPutRequest {
    /**
     * The ID of the user who accepted the organization invitation. Required if the status is \"Accepted\".
     * @type {string}
     * @memberof ApiOrganizationInvitationsIdStatusPutRequest
     */
    'acceptedUserId'?: string | null;
    /**
     * The status of the organization invitation.
     * @type {string}
     * @memberof ApiOrganizationInvitationsIdStatusPutRequest
     */
    'status': ApiOrganizationInvitationsIdStatusPutRequestStatusEnum;
}

export const ApiOrganizationInvitationsIdStatusPutRequestStatusEnum = {
    Accepted: 'Accepted',
    Revoked: 'Revoked'
} as const;

export type ApiOrganizationInvitationsIdStatusPutRequestStatusEnum = typeof ApiOrganizationInvitationsIdStatusPutRequestStatusEnum[keyof typeof ApiOrganizationInvitationsIdStatusPutRequestStatusEnum];

/**
 * 
 * @export
 * @interface ApiOrganizationInvitationsPostRequest
 */
export interface ApiOrganizationInvitationsPostRequest {
    /**
     * The ID of the user who is inviting the user to join the organization.
     * @type {string}
     * @memberof ApiOrganizationInvitationsPostRequest
     */
    'inviterId'?: string | null;
    /**
     * The email address of the user to invite to join the organization.
     * @type {string}
     * @memberof ApiOrganizationInvitationsPostRequest
     */
    'invitee': string;
    /**
     * The ID of the organization to invite the user to join.
     * @type {string}
     * @memberof ApiOrganizationInvitationsPostRequest
     */
    'organizationId': string;
    /**
     * The epoch time in milliseconds when the invitation expires.
     * @type {number}
     * @memberof ApiOrganizationInvitationsPostRequest
     */
    'expiresAt': number;
    /**
     * The IDs of the organization roles to assign to the user when they accept the invitation.
     * @type {Array<string>}
     * @memberof ApiOrganizationInvitationsPostRequest
     */
    'organizationRoleIds'?: Array<string>;
    /**
     * 
     * @type {ApiOrganizationInvitationsPostRequestMessagePayload}
     * @memberof ApiOrganizationInvitationsPostRequest
     */
    'messagePayload': ApiOrganizationInvitationsPostRequestMessagePayload;
}
/**
 * @type ApiOrganizationInvitationsPostRequestMessagePayload
 * The message payload for the \"OrganizationInvitation\" template to use when sending the invitation via email. If it is `false`, the invitation will not be sent via email.
 * @export
 */
export type ApiOrganizationInvitationsPostRequestMessagePayload = ApiOrganizationInvitationsPostRequestMessagePayloadOneOf | boolean;

/**
 * 
 * @export
 * @interface ApiOrganizationInvitationsPostRequestMessagePayloadOneOf
 */
export interface ApiOrganizationInvitationsPostRequestMessagePayloadOneOf {
    /**
     * 
     * @type {string}
     * @memberof ApiOrganizationInvitationsPostRequestMessagePayloadOneOf
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiOrganizationInvitationsPostRequestMessagePayloadOneOf
     */
    'link'?: string;
}
/**
 * 
 * @export
 * @interface ApiOrganizationRolesGet200ResponseInner
 */
export interface ApiOrganizationRolesGet200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ApiOrganizationRolesGet200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiOrganizationRolesGet200ResponseInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiOrganizationRolesGet200ResponseInner
     */
    'description': string | null;
    /**
     * 
     * @type {Array<ApiUsersUserIdOrganizationsGet200ResponseInnerOrganizationRolesInner>}
     * @memberof ApiOrganizationRolesGet200ResponseInner
     */
    'scopes': Array<ApiUsersUserIdOrganizationsGet200ResponseInnerOrganizationRolesInner>;
    /**
     * 
     * @type {Array<ApiOrganizationRolesGet200ResponseInnerResourceScopesInner>}
     * @memberof ApiOrganizationRolesGet200ResponseInner
     */
    'resourceScopes': Array<ApiOrganizationRolesGet200ResponseInnerResourceScopesInner>;
}
/**
 * 
 * @export
 * @interface ApiOrganizationRolesGet200ResponseInnerResourceScopesInner
 */
export interface ApiOrganizationRolesGet200ResponseInnerResourceScopesInner {
    /**
     * 
     * @type {string}
     * @memberof ApiOrganizationRolesGet200ResponseInnerResourceScopesInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiOrganizationRolesGet200ResponseInnerResourceScopesInner
     */
    'name': string;
    /**
     * 
     * @type {ApiUsersUserIdOrganizationsGet200ResponseInnerOrganizationRolesInner}
     * @memberof ApiOrganizationRolesGet200ResponseInnerResourceScopesInner
     */
    'resource': ApiUsersUserIdOrganizationsGet200ResponseInnerOrganizationRolesInner;
}
/**
 * 
 * @export
 * @interface ApiOrganizationRolesIdPatchRequest
 */
export interface ApiOrganizationRolesIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiOrganizationRolesIdPatchRequest
     */
    'id'?: string;
    /**
     * The updated name of the organization role. It must be unique within the organization template.
     * @type {string}
     * @memberof ApiOrganizationRolesIdPatchRequest
     */
    'name'?: string;
    /**
     * The updated description of the organization role.
     * @type {string}
     * @memberof ApiOrganizationRolesIdPatchRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface ApiOrganizationRolesIdResourceScopesPostRequest
 */
export interface ApiOrganizationRolesIdResourceScopesPostRequest {
    /**
     * An array of resource scope IDs to be assigned. Existed scope IDs assignments will be ignored.
     * @type {Array<string>}
     * @memberof ApiOrganizationRolesIdResourceScopesPostRequest
     */
    'scopeIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ApiOrganizationRolesIdResourceScopesPutRequest
 */
export interface ApiOrganizationRolesIdResourceScopesPutRequest {
    /**
     * An array of resource scope IDs to replace existing scopes.
     * @type {Array<string>}
     * @memberof ApiOrganizationRolesIdResourceScopesPutRequest
     */
    'scopeIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ApiOrganizationRolesIdScopesPostRequest
 */
export interface ApiOrganizationRolesIdScopesPostRequest {
    /**
     * An array of organization scope IDs to be assigned. Existed scope IDs assignments will be ignored.
     * @type {Array<string>}
     * @memberof ApiOrganizationRolesIdScopesPostRequest
     */
    'organizationScopeIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ApiOrganizationRolesIdScopesPutRequest
 */
export interface ApiOrganizationRolesIdScopesPutRequest {
    /**
     * An array of organization scope IDs to replace existing scopes.
     * @type {Array<string>}
     * @memberof ApiOrganizationRolesIdScopesPutRequest
     */
    'organizationScopeIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ApiOrganizationRolesPostRequest
 */
export interface ApiOrganizationRolesPostRequest {
    /**
     * The name of the organization role. It must be unique within the organization template.
     * @type {string}
     * @memberof ApiOrganizationRolesPostRequest
     */
    'name': string;
    /**
     * The description of the organization role.
     * @type {string}
     * @memberof ApiOrganizationRolesPostRequest
     */
    'description'?: string | null;
    /**
     * An array of organization scope IDs to be assigned to the organization role.
     * @type {Array<string>}
     * @memberof ApiOrganizationRolesPostRequest
     */
    'organizationScopeIds': Array<string>;
    /**
     * An array of resource scope IDs to be assigned to the organization role.
     * @type {Array<string>}
     * @memberof ApiOrganizationRolesPostRequest
     */
    'resourceScopeIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ApiOrganizationScopesIdPatchRequest
 */
export interface ApiOrganizationScopesIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiOrganizationScopesIdPatchRequest
     */
    'id'?: string;
    /**
     * The updated name of the organization scope. It must be unique within the organization template.
     * @type {string}
     * @memberof ApiOrganizationScopesIdPatchRequest
     */
    'name'?: string;
    /**
     * The updated description of the organization scope.
     * @type {string}
     * @memberof ApiOrganizationScopesIdPatchRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface ApiOrganizationScopesPostRequest
 */
export interface ApiOrganizationScopesPostRequest {
    /**
     * The name of the organization scope. It must be unique within the organization template.
     * @type {string}
     * @memberof ApiOrganizationScopesPostRequest
     */
    'name': string;
    /**
     * The description of the organization scope.
     * @type {string}
     * @memberof ApiOrganizationScopesPostRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface ApiOrganizationsGet200ResponseInner
 */
export interface ApiOrganizationsGet200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ApiOrganizationsGet200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiOrganizationsGet200ResponseInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiOrganizationsGet200ResponseInner
     */
    'description': string | null;
    /**
     * arbitrary
     * @type {object}
     * @memberof ApiOrganizationsGet200ResponseInner
     */
    'customData': object;
    /**
     * 
     * @type {boolean}
     * @memberof ApiOrganizationsGet200ResponseInner
     */
    'isMfaRequired': boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiOrganizationsGet200ResponseInner
     */
    'createdAt': number;
    /**
     * 
     * @type {number}
     * @memberof ApiOrganizationsGet200ResponseInner
     */
    'usersCount'?: number;
    /**
     * 
     * @type {Array<ApiRolesGet200ResponseInnerFeaturedUsersInner>}
     * @memberof ApiOrganizationsGet200ResponseInner
     */
    'featuredUsers'?: Array<ApiRolesGet200ResponseInnerFeaturedUsersInner>;
}
/**
 * 
 * @export
 * @interface ApiOrganizationsIdJitEmailDomainsGet200ResponseInner
 */
export interface ApiOrganizationsIdJitEmailDomainsGet200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ApiOrganizationsIdJitEmailDomainsGet200ResponseInner
     */
    'organizationId': string;
    /**
     * 
     * @type {string}
     * @memberof ApiOrganizationsIdJitEmailDomainsGet200ResponseInner
     */
    'emailDomain': string;
}
/**
 * 
 * @export
 * @interface ApiOrganizationsIdJitEmailDomainsPostRequest
 */
export interface ApiOrganizationsIdJitEmailDomainsPostRequest {
    /**
     * The email domain to add.
     * @type {string}
     * @memberof ApiOrganizationsIdJitEmailDomainsPostRequest
     */
    'emailDomain': string;
}
/**
 * 
 * @export
 * @interface ApiOrganizationsIdJitEmailDomainsPutRequest
 */
export interface ApiOrganizationsIdJitEmailDomainsPutRequest {
    /**
     * An array of email domains to replace existing email domains.
     * @type {Array<string>}
     * @memberof ApiOrganizationsIdJitEmailDomainsPutRequest
     */
    'emailDomains': Array<string>;
}
/**
 * 
 * @export
 * @interface ApiOrganizationsIdJitRolesPostRequest
 */
export interface ApiOrganizationsIdJitRolesPostRequest {
    /**
     * The organization role IDs to add.
     * @type {Array<string>}
     * @memberof ApiOrganizationsIdJitRolesPostRequest
     */
    'organizationRoleIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ApiOrganizationsIdJitRolesPutRequest
 */
export interface ApiOrganizationsIdJitRolesPutRequest {
    /**
     * An array of organization role IDs to replace existing organization roles.
     * @type {Array<string>}
     * @memberof ApiOrganizationsIdJitRolesPutRequest
     */
    'organizationRoleIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ApiOrganizationsIdPatchRequest
 */
export interface ApiOrganizationsIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiOrganizationsIdPatchRequest
     */
    'id'?: string;
    /**
     * The updated name of the organization.
     * @type {string}
     * @memberof ApiOrganizationsIdPatchRequest
     */
    'name'?: string;
    /**
     * The updated description of the organization.
     * @type {string}
     * @memberof ApiOrganizationsIdPatchRequest
     */
    'description'?: string | null;
    /**
     * arbitrary
     * @type {object}
     * @memberof ApiOrganizationsIdPatchRequest
     */
    'customData'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof ApiOrganizationsIdPatchRequest
     */
    'isMfaRequired'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiOrganizationsIdPatchRequest
     */
    'createdAt'?: number;
}
/**
 * 
 * @export
 * @interface ApiOrganizationsIdUsersGet200ResponseInner
 */
export interface ApiOrganizationsIdUsersGet200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ApiOrganizationsIdUsersGet200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiOrganizationsIdUsersGet200ResponseInner
     */
    'username': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiOrganizationsIdUsersGet200ResponseInner
     */
    'primaryEmail': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiOrganizationsIdUsersGet200ResponseInner
     */
    'primaryPhone': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiOrganizationsIdUsersGet200ResponseInner
     */
    'name': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiOrganizationsIdUsersGet200ResponseInner
     */
    'avatar': string | null;
    /**
     * arbitrary
     * @type {object}
     * @memberof ApiOrganizationsIdUsersGet200ResponseInner
     */
    'customData': object;
    /**
     * 
     * @type {{ [key: string]: ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserIdentitiesValue; }}
     * @memberof ApiOrganizationsIdUsersGet200ResponseInner
     */
    'identities': { [key: string]: ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserIdentitiesValue; };
    /**
     * 
     * @type {number}
     * @memberof ApiOrganizationsIdUsersGet200ResponseInner
     */
    'lastSignInAt': number | null;
    /**
     * 
     * @type {number}
     * @memberof ApiOrganizationsIdUsersGet200ResponseInner
     */
    'createdAt': number;
    /**
     * 
     * @type {number}
     * @memberof ApiOrganizationsIdUsersGet200ResponseInner
     */
    'updatedAt': number;
    /**
     * 
     * @type {ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfile}
     * @memberof ApiOrganizationsIdUsersGet200ResponseInner
     */
    'profile': ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfile;
    /**
     * 
     * @type {string}
     * @memberof ApiOrganizationsIdUsersGet200ResponseInner
     */
    'applicationId': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApiOrganizationsIdUsersGet200ResponseInner
     */
    'isSuspended': boolean;
    /**
     * 
     * @type {Array<ApiUsersUserIdOrganizationsGet200ResponseInnerOrganizationRolesInner>}
     * @memberof ApiOrganizationsIdUsersGet200ResponseInner
     */
    'organizationRoles': Array<ApiUsersUserIdOrganizationsGet200ResponseInnerOrganizationRolesInner>;
}
/**
 * 
 * @export
 * @interface ApiOrganizationsIdUsersPostRequest
 */
export interface ApiOrganizationsIdUsersPostRequest {
    /**
     * An array of user IDs to be added to the organization. Organization existed users assignment will be ignored.
     * @type {Array<string>}
     * @memberof ApiOrganizationsIdUsersPostRequest
     */
    'userIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ApiOrganizationsIdUsersPutRequest
 */
export interface ApiOrganizationsIdUsersPutRequest {
    /**
     * An array of user IDs to replace existing users.
     * @type {Array<string>}
     * @memberof ApiOrganizationsIdUsersPutRequest
     */
    'userIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ApiOrganizationsIdUsersRolesPostRequest
 */
export interface ApiOrganizationsIdUsersRolesPostRequest {
    /**
     * An array of user IDs to assign roles.
     * @type {Array<string>}
     * @memberof ApiOrganizationsIdUsersRolesPostRequest
     */
    'userIds': Array<string>;
    /**
     * An array of organization role IDs to assign. User existed roles assignment will be ignored.
     * @type {Array<string>}
     * @memberof ApiOrganizationsIdUsersRolesPostRequest
     */
    'organizationRoleIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ApiOrganizationsIdUsersUserIdRolesPostRequest
 */
export interface ApiOrganizationsIdUsersUserIdRolesPostRequest {
    /**
     * An array of organization role IDs to assign to the user. User existed roles assignment will be ignored.
     * @type {Array<string>}
     * @memberof ApiOrganizationsIdUsersUserIdRolesPostRequest
     */
    'organizationRoleIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ApiOrganizationsIdUsersUserIdRolesPutRequest
 */
export interface ApiOrganizationsIdUsersUserIdRolesPutRequest {
    /**
     * An array of organization role IDs to update for the user.
     * @type {Array<string>}
     * @memberof ApiOrganizationsIdUsersUserIdRolesPutRequest
     */
    'organizationRoleIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ApiOrganizationsPostRequest
 */
export interface ApiOrganizationsPostRequest {
    /**
     * The name of the organization.
     * @type {string}
     * @memberof ApiOrganizationsPostRequest
     */
    'name': string;
    /**
     * The description of the organization.
     * @type {string}
     * @memberof ApiOrganizationsPostRequest
     */
    'description'?: string | null;
    /**
     * arbitrary
     * @type {object}
     * @memberof ApiOrganizationsPostRequest
     */
    'customData'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof ApiOrganizationsPostRequest
     */
    'isMfaRequired'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiOrganizationsPostRequest
     */
    'createdAt'?: number;
}
/**
 * 
 * @export
 * @interface ApiResourcesGet200ResponseInner
 */
export interface ApiResourcesGet200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ApiResourcesGet200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiResourcesGet200ResponseInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiResourcesGet200ResponseInner
     */
    'indicator': string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiResourcesGet200ResponseInner
     */
    'isDefault': boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiResourcesGet200ResponseInner
     */
    'accessTokenTtl': number;
    /**
     * 
     * @type {Array<ApiResourcesGet200ResponseInnerScopesInner>}
     * @memberof ApiResourcesGet200ResponseInner
     */
    'scopes'?: Array<ApiResourcesGet200ResponseInnerScopesInner>;
}
/**
 * 
 * @export
 * @interface ApiResourcesGet200ResponseInnerScopesInner
 */
export interface ApiResourcesGet200ResponseInnerScopesInner {
    /**
     * 
     * @type {string}
     * @memberof ApiResourcesGet200ResponseInnerScopesInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiResourcesGet200ResponseInnerScopesInner
     */
    'resourceId': string;
    /**
     * 
     * @type {string}
     * @memberof ApiResourcesGet200ResponseInnerScopesInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiResourcesGet200ResponseInnerScopesInner
     */
    'description': string | null;
    /**
     * 
     * @type {number}
     * @memberof ApiResourcesGet200ResponseInnerScopesInner
     */
    'createdAt': number;
}
/**
 * 
 * @export
 * @interface ApiResourcesIdIsDefaultPatchRequest
 */
export interface ApiResourcesIdIsDefaultPatchRequest {
    /**
     * The updated value of the `isDefault` property.
     * @type {boolean}
     * @memberof ApiResourcesIdIsDefaultPatchRequest
     */
    'isDefault': boolean;
}
/**
 * 
 * @export
 * @interface ApiResourcesIdPatchRequest
 */
export interface ApiResourcesIdPatchRequest {
    /**
     * The updated name of the resource.
     * @type {string}
     * @memberof ApiResourcesIdPatchRequest
     */
    'name'?: string;
    /**
     * The updated access token TTL in seconds.
     * @type {number}
     * @memberof ApiResourcesIdPatchRequest
     */
    'accessTokenTtl'?: number;
}
/**
 * 
 * @export
 * @interface ApiResourcesPostRequest
 */
export interface ApiResourcesPostRequest {
    /**
     * The name of the resource.
     * @type {string}
     * @memberof ApiResourcesPostRequest
     */
    'name': string;
    /**
     * The unique resource indicator. Should be a valid URI.
     * @type {string}
     * @memberof ApiResourcesPostRequest
     */
    'indicator': string;
    /**
     * The access token TTL in seconds. It affects the `exp` claim of the access token granted for this resource.
     * @type {number}
     * @memberof ApiResourcesPostRequest
     */
    'accessTokenTtl'?: number;
}
/**
 * 
 * @export
 * @interface ApiResourcesResourceIdScopesPostRequest
 */
export interface ApiResourcesResourceIdScopesPostRequest {
    /**
     * The name of the scope. It should be unique for the resource.
     * @type {string}
     * @memberof ApiResourcesResourceIdScopesPostRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiResourcesResourceIdScopesPostRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface ApiResourcesResourceIdScopesScopeIdPatchRequest
 */
export interface ApiResourcesResourceIdScopesScopeIdPatchRequest {
    /**
     * The updated name of the scope. It should be unique for the resource.
     * @type {string}
     * @memberof ApiResourcesResourceIdScopesScopeIdPatchRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiResourcesResourceIdScopesScopeIdPatchRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface ApiRolesGet200ResponseInner
 */
export interface ApiRolesGet200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ApiRolesGet200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiRolesGet200ResponseInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiRolesGet200ResponseInner
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ApiRolesGet200ResponseInner
     */
    'type': ApiRolesGet200ResponseInnerTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ApiRolesGet200ResponseInner
     */
    'isDefault': boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiRolesGet200ResponseInner
     */
    'usersCount': number;
    /**
     * 
     * @type {Array<ApiRolesGet200ResponseInnerFeaturedUsersInner>}
     * @memberof ApiRolesGet200ResponseInner
     */
    'featuredUsers': Array<ApiRolesGet200ResponseInnerFeaturedUsersInner>;
    /**
     * 
     * @type {number}
     * @memberof ApiRolesGet200ResponseInner
     */
    'applicationsCount': number;
    /**
     * 
     * @type {Array<ApiRolesGet200ResponseInnerFeaturedApplicationsInner>}
     * @memberof ApiRolesGet200ResponseInner
     */
    'featuredApplications': Array<ApiRolesGet200ResponseInnerFeaturedApplicationsInner>;
}

export const ApiRolesGet200ResponseInnerTypeEnum = {
    User: 'User',
    MachineToMachine: 'MachineToMachine'
} as const;

export type ApiRolesGet200ResponseInnerTypeEnum = typeof ApiRolesGet200ResponseInnerTypeEnum[keyof typeof ApiRolesGet200ResponseInnerTypeEnum];

/**
 * 
 * @export
 * @interface ApiRolesGet200ResponseInnerFeaturedApplicationsInner
 */
export interface ApiRolesGet200ResponseInnerFeaturedApplicationsInner {
    /**
     * 
     * @type {string}
     * @memberof ApiRolesGet200ResponseInnerFeaturedApplicationsInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiRolesGet200ResponseInnerFeaturedApplicationsInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiRolesGet200ResponseInnerFeaturedApplicationsInner
     */
    'type': ApiRolesGet200ResponseInnerFeaturedApplicationsInnerTypeEnum;
}

export const ApiRolesGet200ResponseInnerFeaturedApplicationsInnerTypeEnum = {
    Native: 'Native',
    Spa: 'SPA',
    Traditional: 'Traditional',
    MachineToMachine: 'MachineToMachine',
    Protected: 'Protected'
} as const;

export type ApiRolesGet200ResponseInnerFeaturedApplicationsInnerTypeEnum = typeof ApiRolesGet200ResponseInnerFeaturedApplicationsInnerTypeEnum[keyof typeof ApiRolesGet200ResponseInnerFeaturedApplicationsInnerTypeEnum];

/**
 * 
 * @export
 * @interface ApiRolesGet200ResponseInnerFeaturedUsersInner
 */
export interface ApiRolesGet200ResponseInnerFeaturedUsersInner {
    /**
     * 
     * @type {string}
     * @memberof ApiRolesGet200ResponseInnerFeaturedUsersInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiRolesGet200ResponseInnerFeaturedUsersInner
     */
    'avatar': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiRolesGet200ResponseInnerFeaturedUsersInner
     */
    'name': string | null;
}
/**
 * 
 * @export
 * @interface ApiRolesIdApplicationsPostRequest
 */
export interface ApiRolesIdApplicationsPostRequest {
    /**
     * An array of application IDs to be assigned.
     * @type {Array<string>}
     * @memberof ApiRolesIdApplicationsPostRequest
     */
    'applicationIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ApiRolesIdPatchRequest
 */
export interface ApiRolesIdPatchRequest {
    /**
     * The name of the role. It should be unique within the tenant.
     * @type {string}
     * @memberof ApiRolesIdPatchRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiRolesIdPatchRequest
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiRolesIdPatchRequest
     */
    'isDefault'?: boolean;
}
/**
 * 
 * @export
 * @interface ApiRolesIdScopesGet200ResponseInner
 */
export interface ApiRolesIdScopesGet200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ApiRolesIdScopesGet200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiRolesIdScopesGet200ResponseInner
     */
    'resourceId': string;
    /**
     * 
     * @type {string}
     * @memberof ApiRolesIdScopesGet200ResponseInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiRolesIdScopesGet200ResponseInner
     */
    'description': string | null;
    /**
     * 
     * @type {number}
     * @memberof ApiRolesIdScopesGet200ResponseInner
     */
    'createdAt': number;
    /**
     * 
     * @type {ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource}
     * @memberof ApiRolesIdScopesGet200ResponseInner
     */
    'resource': ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource;
}
/**
 * 
 * @export
 * @interface ApiRolesIdScopesPostRequest
 */
export interface ApiRolesIdScopesPostRequest {
    /**
     * An array of API resource scope IDs to be linked.
     * @type {Array<string>}
     * @memberof ApiRolesIdScopesPostRequest
     */
    'scopeIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ApiRolesIdUsersPostRequest
 */
export interface ApiRolesIdUsersPostRequest {
    /**
     * An array of user IDs to be assigned.
     * @type {Array<string>}
     * @memberof ApiRolesIdUsersPostRequest
     */
    'userIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ApiRolesPostRequest
 */
export interface ApiRolesPostRequest {
    /**
     * The name of the role. It should be unique within the tenant.
     * @type {string}
     * @memberof ApiRolesPostRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiRolesPostRequest
     */
    'description': string;
    /**
     * The type of the role. It cannot be changed after creation.
     * @type {string}
     * @memberof ApiRolesPostRequest
     */
    'type'?: ApiRolesPostRequestTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ApiRolesPostRequest
     */
    'isDefault'?: boolean;
    /**
     * The initial API resource scopes assigned to the role.
     * @type {Array<string>}
     * @memberof ApiRolesPostRequest
     */
    'scopeIds'?: Array<string>;
}

export const ApiRolesPostRequestTypeEnum = {
    User: 'User',
    MachineToMachine: 'MachineToMachine'
} as const;

export type ApiRolesPostRequestTypeEnum = typeof ApiRolesPostRequestTypeEnum[keyof typeof ApiRolesPostRequestTypeEnum];

/**
 * 
 * @export
 * @interface ApiSignInExpGet200Response
 */
export interface ApiSignInExpGet200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiSignInExpGet200Response
     */
    'id': string;
    /**
     * 
     * @type {ApiSignInExpGet200ResponseColor}
     * @memberof ApiSignInExpGet200Response
     */
    'color': ApiSignInExpGet200ResponseColor;
    /**
     * 
     * @type {ApiInteractionConsentGet200ResponseApplicationBranding}
     * @memberof ApiSignInExpGet200Response
     */
    'branding': ApiInteractionConsentGet200ResponseApplicationBranding;
    /**
     * 
     * @type {ApiSignInExpGet200ResponseLanguageInfo}
     * @memberof ApiSignInExpGet200Response
     */
    'languageInfo': ApiSignInExpGet200ResponseLanguageInfo;
    /**
     * 
     * @type {string}
     * @memberof ApiSignInExpGet200Response
     */
    'termsOfUseUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiSignInExpGet200Response
     */
    'privacyPolicyUrl': string | null;
    /**
     * 
     * @type {ApiSignInExpGet200ResponseSignIn}
     * @memberof ApiSignInExpGet200Response
     */
    'signIn': ApiSignInExpGet200ResponseSignIn;
    /**
     * 
     * @type {ApiSignInExpGet200ResponseSignUp}
     * @memberof ApiSignInExpGet200Response
     */
    'signUp': ApiSignInExpGet200ResponseSignUp;
    /**
     * 
     * @type {ApiSignInExpGet200ResponseSocialSignIn}
     * @memberof ApiSignInExpGet200Response
     */
    'socialSignIn': ApiSignInExpGet200ResponseSocialSignIn;
    /**
     * Enabled social sign-in connectors, will displayed on the sign-in page.
     * @type {Array<string>}
     * @memberof ApiSignInExpGet200Response
     */
    'socialSignInConnectorTargets': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ApiSignInExpGet200Response
     */
    'signInMode': ApiSignInExpGet200ResponseSignInModeEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiSignInExpGet200Response
     */
    'customCss': string | null;
    /**
     * Custom content to display on experience flow pages. the page pathname will be the config key, the content will be the config value.
     * @type {{ [key: string]: string; }}
     * @memberof ApiSignInExpGet200Response
     */
    'customContent': { [key: string]: string; };
    /**
     * 
     * @type {ApiSignInExpGet200ResponsePasswordPolicy}
     * @memberof ApiSignInExpGet200Response
     */
    'passwordPolicy': ApiSignInExpGet200ResponsePasswordPolicy;
    /**
     * 
     * @type {ApiSignInExpGet200ResponseMfa}
     * @memberof ApiSignInExpGet200Response
     */
    'mfa': ApiSignInExpGet200ResponseMfa;
    /**
     * 
     * @type {boolean}
     * @memberof ApiSignInExpGet200Response
     */
    'singleSignOnEnabled': boolean;
}

export const ApiSignInExpGet200ResponseSignInModeEnum = {
    SignIn: 'SignIn',
    Register: 'Register',
    SignInAndRegister: 'SignInAndRegister'
} as const;

export type ApiSignInExpGet200ResponseSignInModeEnum = typeof ApiSignInExpGet200ResponseSignInModeEnum[keyof typeof ApiSignInExpGet200ResponseSignInModeEnum];

/**
 * The primary branding color for the sign-in page (both light/dark mode).
 * @export
 * @interface ApiSignInExpGet200ResponseColor
 */
export interface ApiSignInExpGet200ResponseColor {
    /**
     * 
     * @type {string}
     * @memberof ApiSignInExpGet200ResponseColor
     */
    'primaryColor': string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiSignInExpGet200ResponseColor
     */
    'isDarkModeEnabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiSignInExpGet200ResponseColor
     */
    'darkPrimaryColor': string;
}
/**
 * The language detection policy for the sign-in page.
 * @export
 * @interface ApiSignInExpGet200ResponseLanguageInfo
 */
export interface ApiSignInExpGet200ResponseLanguageInfo {
    /**
     * 
     * @type {boolean}
     * @memberof ApiSignInExpGet200ResponseLanguageInfo
     */
    'autoDetect': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiSignInExpGet200ResponseLanguageInfo
     */
    'fallbackLanguage': ApiSignInExpGet200ResponseLanguageInfoFallbackLanguageEnum;
}

export const ApiSignInExpGet200ResponseLanguageInfoFallbackLanguageEnum = {
    AfZa: 'af-ZA',
    AmEt: 'am-ET',
    ArAr: 'ar-AR',
    AsIn: 'as-IN',
    AzAz: 'az-AZ',
    BeBy: 'be-BY',
    BgBg: 'bg-BG',
    BnIn: 'bn-IN',
    BrFr: 'br-FR',
    BsBa: 'bs-BA',
    CaEs: 'ca-ES',
    CbIq: 'cb-IQ',
    CoFr: 'co-FR',
    CsCz: 'cs-CZ',
    CxPh: 'cx-PH',
    CyGb: 'cy-GB',
    DaDk: 'da-DK',
    De: 'de',
    DeDe: 'de-DE',
    ElGr: 'el-GR',
    En: 'en',
    EnGb: 'en-GB',
    EnUs: 'en-US',
    EoEo: 'eo-EO',
    Es: 'es',
    EsEs: 'es-ES',
    Es419: 'es-419',
    EtEe: 'et-EE',
    EuEs: 'eu-ES',
    FaIr: 'fa-IR',
    FfNg: 'ff-NG',
    FiFi: 'fi-FI',
    FoFo: 'fo-FO',
    Fr: 'fr',
    FrCa: 'fr-CA',
    FrFr: 'fr-FR',
    FyNl: 'fy-NL',
    GaIe: 'ga-IE',
    GlEs: 'gl-ES',
    GnPy: 'gn-PY',
    GuIn: 'gu-IN',
    HaNg: 'ha-NG',
    HeIl: 'he-IL',
    HiIn: 'hi-IN',
    HrHr: 'hr-HR',
    HtHt: 'ht-HT',
    HuHu: 'hu-HU',
    HyAm: 'hy-AM',
    IdId: 'id-ID',
    IkUs: 'ik-US',
    IsIs: 'is-IS',
    It: 'it',
    ItIt: 'it-IT',
    IuCa: 'iu-CA',
    Ja: 'ja',
    JaJp: 'ja-JP',
    JaKs: 'ja-KS',
    JvId: 'jv-ID',
    KaGe: 'ka-GE',
    KkKz: 'kk-KZ',
    KmKh: 'km-KH',
    KnIn: 'kn-IN',
    Ko: 'ko',
    KoKr: 'ko-KR',
    KuTr: 'ku-TR',
    KyKg: 'ky-KG',
    LoLa: 'lo-LA',
    LtLt: 'lt-LT',
    LvLv: 'lv-LV',
    MgMg: 'mg-MG',
    MkMk: 'mk-MK',
    MlIn: 'ml-IN',
    MnMn: 'mn-MN',
    MrIn: 'mr-IN',
    MsMy: 'ms-MY',
    MtMt: 'mt-MT',
    MyMm: 'my-MM',
    NbNo: 'nb-NO',
    NeNp: 'ne-NP',
    NlBe: 'nl-BE',
    NlNl: 'nl-NL',
    NnNo: 'nn-NO',
    OrIn: 'or-IN',
    PaIn: 'pa-IN',
    PlPl: 'pl-PL',
    PsAf: 'ps-AF',
    Pt: 'pt',
    PtBr: 'pt-BR',
    PtPt: 'pt-PT',
    RoRo: 'ro-RO',
    Ru: 'ru',
    RuRu: 'ru-RU',
    RwRw: 'rw-RW',
    ScIt: 'sc-IT',
    SiLk: 'si-LK',
    SkSk: 'sk-SK',
    SlSi: 'sl-SI',
    SnZw: 'sn-ZW',
    SqAl: 'sq-AL',
    SrRs: 'sr-RS',
    SvSe: 'sv-SE',
    SwKe: 'sw-KE',
    SySy: 'sy-SY',
    SzPl: 'sz-PL',
    TaIn: 'ta-IN',
    TeIn: 'te-IN',
    TgTj: 'tg-TJ',
    ThTh: 'th-TH',
    TlPh: 'tl-PH',
    Tr: 'tr',
    TrTr: 'tr-TR',
    TtRu: 'tt-RU',
    TzMa: 'tz-MA',
    UkUa: 'uk-UA',
    UrPk: 'ur-PK',
    UzUz: 'uz-UZ',
    ViVn: 'vi-VN',
    Zh: 'zh',
    ZhCn: 'zh-CN',
    ZhHk: 'zh-HK',
    ZhMo: 'zh-MO',
    ZhTw: 'zh-TW',
    ZzTr: 'zz-TR'
} as const;

export type ApiSignInExpGet200ResponseLanguageInfoFallbackLanguageEnum = typeof ApiSignInExpGet200ResponseLanguageInfoFallbackLanguageEnum[keyof typeof ApiSignInExpGet200ResponseLanguageInfoFallbackLanguageEnum];

/**
 * MFA settings
 * @export
 * @interface ApiSignInExpGet200ResponseMfa
 */
export interface ApiSignInExpGet200ResponseMfa {
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiSignInExpGet200ResponseMfa
     */
    'factors': Array<ApiSignInExpGet200ResponseMfaFactorsEnum>;
    /**
     * 
     * @type {string}
     * @memberof ApiSignInExpGet200ResponseMfa
     */
    'policy': ApiSignInExpGet200ResponseMfaPolicyEnum;
}

export const ApiSignInExpGet200ResponseMfaFactorsEnum = {
    Totp: 'Totp',
    WebAuthn: 'WebAuthn',
    BackupCode: 'BackupCode'
} as const;

export type ApiSignInExpGet200ResponseMfaFactorsEnum = typeof ApiSignInExpGet200ResponseMfaFactorsEnum[keyof typeof ApiSignInExpGet200ResponseMfaFactorsEnum];
export const ApiSignInExpGet200ResponseMfaPolicyEnum = {
    UserControlled: 'UserControlled',
    Mandatory: 'Mandatory'
} as const;

export type ApiSignInExpGet200ResponseMfaPolicyEnum = typeof ApiSignInExpGet200ResponseMfaPolicyEnum[keyof typeof ApiSignInExpGet200ResponseMfaPolicyEnum];

/**
 * Password policies to adjust the password strength requirements.
 * @export
 * @interface ApiSignInExpGet200ResponsePasswordPolicy
 */
export interface ApiSignInExpGet200ResponsePasswordPolicy {
    /**
     * 
     * @type {ApiSignInExpGet200ResponsePasswordPolicyLength}
     * @memberof ApiSignInExpGet200ResponsePasswordPolicy
     */
    'length'?: ApiSignInExpGet200ResponsePasswordPolicyLength;
    /**
     * 
     * @type {ApiSignInExpGet200ResponsePasswordPolicyCharacterTypes}
     * @memberof ApiSignInExpGet200ResponsePasswordPolicy
     */
    'characterTypes'?: ApiSignInExpGet200ResponsePasswordPolicyCharacterTypes;
    /**
     * 
     * @type {ApiSignInExpGet200ResponsePasswordPolicyRejects}
     * @memberof ApiSignInExpGet200ResponsePasswordPolicy
     */
    'rejects'?: ApiSignInExpGet200ResponsePasswordPolicyRejects;
}
/**
 * 
 * @export
 * @interface ApiSignInExpGet200ResponsePasswordPolicyCharacterTypes
 */
export interface ApiSignInExpGet200ResponsePasswordPolicyCharacterTypes {
    /**
     * 
     * @type {number}
     * @memberof ApiSignInExpGet200ResponsePasswordPolicyCharacterTypes
     */
    'min': number;
}
/**
 * 
 * @export
 * @interface ApiSignInExpGet200ResponsePasswordPolicyLength
 */
export interface ApiSignInExpGet200ResponsePasswordPolicyLength {
    /**
     * 
     * @type {number}
     * @memberof ApiSignInExpGet200ResponsePasswordPolicyLength
     */
    'min': number;
    /**
     * 
     * @type {number}
     * @memberof ApiSignInExpGet200ResponsePasswordPolicyLength
     */
    'max': number;
}
/**
 * 
 * @export
 * @interface ApiSignInExpGet200ResponsePasswordPolicyRejects
 */
export interface ApiSignInExpGet200ResponsePasswordPolicyRejects {
    /**
     * 
     * @type {boolean}
     * @memberof ApiSignInExpGet200ResponsePasswordPolicyRejects
     */
    'pwned': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApiSignInExpGet200ResponsePasswordPolicyRejects
     */
    'repetitionAndSequence': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApiSignInExpGet200ResponsePasswordPolicyRejects
     */
    'userInfo': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiSignInExpGet200ResponsePasswordPolicyRejects
     */
    'words': Array<string>;
}
/**
 * Sign-in method settings.
 * @export
 * @interface ApiSignInExpGet200ResponseSignIn
 */
export interface ApiSignInExpGet200ResponseSignIn {
    /**
     * 
     * @type {Array<ApiSignInExpGet200ResponseSignInMethodsInner>}
     * @memberof ApiSignInExpGet200ResponseSignIn
     */
    'methods': Array<ApiSignInExpGet200ResponseSignInMethodsInner>;
}
/**
 * 
 * @export
 * @interface ApiSignInExpGet200ResponseSignInMethodsInner
 */
export interface ApiSignInExpGet200ResponseSignInMethodsInner {
    /**
     * 
     * @type {string}
     * @memberof ApiSignInExpGet200ResponseSignInMethodsInner
     */
    'identifier': ApiSignInExpGet200ResponseSignInMethodsInnerIdentifierEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ApiSignInExpGet200ResponseSignInMethodsInner
     */
    'password': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApiSignInExpGet200ResponseSignInMethodsInner
     */
    'verificationCode': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApiSignInExpGet200ResponseSignInMethodsInner
     */
    'isPasswordPrimary': boolean;
}

export const ApiSignInExpGet200ResponseSignInMethodsInnerIdentifierEnum = {
    Username: 'username',
    Email: 'email',
    Phone: 'phone'
} as const;

export type ApiSignInExpGet200ResponseSignInMethodsInnerIdentifierEnum = typeof ApiSignInExpGet200ResponseSignInMethodsInnerIdentifierEnum[keyof typeof ApiSignInExpGet200ResponseSignInMethodsInnerIdentifierEnum];

/**
 * Sign-up method settings.
 * @export
 * @interface ApiSignInExpGet200ResponseSignUp
 */
export interface ApiSignInExpGet200ResponseSignUp {
    /**
     * Allowed identifiers when signing-up.
     * @type {Array<string>}
     * @memberof ApiSignInExpGet200ResponseSignUp
     */
    'identifiers': Array<ApiSignInExpGet200ResponseSignUpIdentifiersEnum>;
    /**
     * Whether the user is required to set a password when signing-up.
     * @type {boolean}
     * @memberof ApiSignInExpGet200ResponseSignUp
     */
    'password': boolean;
    /**
     * Whether the user is required to verify their email/phone when signing-up.
     * @type {boolean}
     * @memberof ApiSignInExpGet200ResponseSignUp
     */
    'verify': boolean;
}

export const ApiSignInExpGet200ResponseSignUpIdentifiersEnum = {
    Username: 'username',
    Email: 'email',
    Phone: 'phone'
} as const;

export type ApiSignInExpGet200ResponseSignUpIdentifiersEnum = typeof ApiSignInExpGet200ResponseSignUpIdentifiersEnum[keyof typeof ApiSignInExpGet200ResponseSignUpIdentifiersEnum];

/**
 * 
 * @export
 * @interface ApiSignInExpGet200ResponseSocialSignIn
 */
export interface ApiSignInExpGet200ResponseSocialSignIn {
    /**
     * 
     * @type {boolean}
     * @memberof ApiSignInExpGet200ResponseSocialSignIn
     */
    'automaticAccountLinking'?: boolean;
}
/**
 * 
 * @export
 * @interface ApiSignInExpPatch200Response
 */
export interface ApiSignInExpPatch200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiSignInExpPatch200Response
     */
    'id': string;
    /**
     * 
     * @type {ApiSignInExpPatch200ResponseColor}
     * @memberof ApiSignInExpPatch200Response
     */
    'color': ApiSignInExpPatch200ResponseColor;
    /**
     * 
     * @type {ApiInteractionConsentGet200ResponseApplicationBranding}
     * @memberof ApiSignInExpPatch200Response
     */
    'branding': ApiInteractionConsentGet200ResponseApplicationBranding;
    /**
     * 
     * @type {ApiSignInExpPatch200ResponseLanguageInfo}
     * @memberof ApiSignInExpPatch200Response
     */
    'languageInfo': ApiSignInExpPatch200ResponseLanguageInfo;
    /**
     * 
     * @type {string}
     * @memberof ApiSignInExpPatch200Response
     */
    'termsOfUseUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiSignInExpPatch200Response
     */
    'privacyPolicyUrl': string | null;
    /**
     * 
     * @type {ApiSignInExpPatch200ResponseSignIn}
     * @memberof ApiSignInExpPatch200Response
     */
    'signIn': ApiSignInExpPatch200ResponseSignIn;
    /**
     * 
     * @type {ApiSignInExpPatch200ResponseSignUp}
     * @memberof ApiSignInExpPatch200Response
     */
    'signUp': ApiSignInExpPatch200ResponseSignUp;
    /**
     * 
     * @type {ApiSignInExpGet200ResponseSocialSignIn}
     * @memberof ApiSignInExpPatch200Response
     */
    'socialSignIn': ApiSignInExpGet200ResponseSocialSignIn;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiSignInExpPatch200Response
     */
    'socialSignInConnectorTargets': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ApiSignInExpPatch200Response
     */
    'signInMode': ApiSignInExpPatch200ResponseSignInModeEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiSignInExpPatch200Response
     */
    'customCss': string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiSignInExpPatch200Response
     */
    'customContent': { [key: string]: string; };
    /**
     * 
     * @type {ApiSignInExpPatch200ResponsePasswordPolicy}
     * @memberof ApiSignInExpPatch200Response
     */
    'passwordPolicy': ApiSignInExpPatch200ResponsePasswordPolicy;
    /**
     * 
     * @type {ApiSignInExpPatch200ResponseMfa}
     * @memberof ApiSignInExpPatch200Response
     */
    'mfa': ApiSignInExpPatch200ResponseMfa;
    /**
     * 
     * @type {boolean}
     * @memberof ApiSignInExpPatch200Response
     */
    'singleSignOnEnabled': boolean;
}

export const ApiSignInExpPatch200ResponseSignInModeEnum = {
    SignIn: 'SignIn',
    Register: 'Register',
    SignInAndRegister: 'SignInAndRegister'
} as const;

export type ApiSignInExpPatch200ResponseSignInModeEnum = typeof ApiSignInExpPatch200ResponseSignInModeEnum[keyof typeof ApiSignInExpPatch200ResponseSignInModeEnum];

/**
 * 
 * @export
 * @interface ApiSignInExpPatch200ResponseColor
 */
export interface ApiSignInExpPatch200ResponseColor {
    /**
     * 
     * @type {string}
     * @memberof ApiSignInExpPatch200ResponseColor
     */
    'primaryColor': string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiSignInExpPatch200ResponseColor
     */
    'isDarkModeEnabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiSignInExpPatch200ResponseColor
     */
    'darkPrimaryColor': string;
}
/**
 * 
 * @export
 * @interface ApiSignInExpPatch200ResponseLanguageInfo
 */
export interface ApiSignInExpPatch200ResponseLanguageInfo {
    /**
     * 
     * @type {boolean}
     * @memberof ApiSignInExpPatch200ResponseLanguageInfo
     */
    'autoDetect': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiSignInExpPatch200ResponseLanguageInfo
     */
    'fallbackLanguage': ApiSignInExpPatch200ResponseLanguageInfoFallbackLanguageEnum;
}

export const ApiSignInExpPatch200ResponseLanguageInfoFallbackLanguageEnum = {
    AfZa: 'af-ZA',
    AmEt: 'am-ET',
    ArAr: 'ar-AR',
    AsIn: 'as-IN',
    AzAz: 'az-AZ',
    BeBy: 'be-BY',
    BgBg: 'bg-BG',
    BnIn: 'bn-IN',
    BrFr: 'br-FR',
    BsBa: 'bs-BA',
    CaEs: 'ca-ES',
    CbIq: 'cb-IQ',
    CoFr: 'co-FR',
    CsCz: 'cs-CZ',
    CxPh: 'cx-PH',
    CyGb: 'cy-GB',
    DaDk: 'da-DK',
    De: 'de',
    DeDe: 'de-DE',
    ElGr: 'el-GR',
    En: 'en',
    EnGb: 'en-GB',
    EnUs: 'en-US',
    EoEo: 'eo-EO',
    Es: 'es',
    EsEs: 'es-ES',
    Es419: 'es-419',
    EtEe: 'et-EE',
    EuEs: 'eu-ES',
    FaIr: 'fa-IR',
    FfNg: 'ff-NG',
    FiFi: 'fi-FI',
    FoFo: 'fo-FO',
    Fr: 'fr',
    FrCa: 'fr-CA',
    FrFr: 'fr-FR',
    FyNl: 'fy-NL',
    GaIe: 'ga-IE',
    GlEs: 'gl-ES',
    GnPy: 'gn-PY',
    GuIn: 'gu-IN',
    HaNg: 'ha-NG',
    HeIl: 'he-IL',
    HiIn: 'hi-IN',
    HrHr: 'hr-HR',
    HtHt: 'ht-HT',
    HuHu: 'hu-HU',
    HyAm: 'hy-AM',
    IdId: 'id-ID',
    IkUs: 'ik-US',
    IsIs: 'is-IS',
    It: 'it',
    ItIt: 'it-IT',
    IuCa: 'iu-CA',
    Ja: 'ja',
    JaJp: 'ja-JP',
    JaKs: 'ja-KS',
    JvId: 'jv-ID',
    KaGe: 'ka-GE',
    KkKz: 'kk-KZ',
    KmKh: 'km-KH',
    KnIn: 'kn-IN',
    Ko: 'ko',
    KoKr: 'ko-KR',
    KuTr: 'ku-TR',
    KyKg: 'ky-KG',
    LoLa: 'lo-LA',
    LtLt: 'lt-LT',
    LvLv: 'lv-LV',
    MgMg: 'mg-MG',
    MkMk: 'mk-MK',
    MlIn: 'ml-IN',
    MnMn: 'mn-MN',
    MrIn: 'mr-IN',
    MsMy: 'ms-MY',
    MtMt: 'mt-MT',
    MyMm: 'my-MM',
    NbNo: 'nb-NO',
    NeNp: 'ne-NP',
    NlBe: 'nl-BE',
    NlNl: 'nl-NL',
    NnNo: 'nn-NO',
    OrIn: 'or-IN',
    PaIn: 'pa-IN',
    PlPl: 'pl-PL',
    PsAf: 'ps-AF',
    Pt: 'pt',
    PtBr: 'pt-BR',
    PtPt: 'pt-PT',
    RoRo: 'ro-RO',
    Ru: 'ru',
    RuRu: 'ru-RU',
    RwRw: 'rw-RW',
    ScIt: 'sc-IT',
    SiLk: 'si-LK',
    SkSk: 'sk-SK',
    SlSi: 'sl-SI',
    SnZw: 'sn-ZW',
    SqAl: 'sq-AL',
    SrRs: 'sr-RS',
    SvSe: 'sv-SE',
    SwKe: 'sw-KE',
    SySy: 'sy-SY',
    SzPl: 'sz-PL',
    TaIn: 'ta-IN',
    TeIn: 'te-IN',
    TgTj: 'tg-TJ',
    ThTh: 'th-TH',
    TlPh: 'tl-PH',
    Tr: 'tr',
    TrTr: 'tr-TR',
    TtRu: 'tt-RU',
    TzMa: 'tz-MA',
    UkUa: 'uk-UA',
    UrPk: 'ur-PK',
    UzUz: 'uz-UZ',
    ViVn: 'vi-VN',
    Zh: 'zh',
    ZhCn: 'zh-CN',
    ZhHk: 'zh-HK',
    ZhMo: 'zh-MO',
    ZhTw: 'zh-TW',
    ZzTr: 'zz-TR'
} as const;

export type ApiSignInExpPatch200ResponseLanguageInfoFallbackLanguageEnum = typeof ApiSignInExpPatch200ResponseLanguageInfoFallbackLanguageEnum[keyof typeof ApiSignInExpPatch200ResponseLanguageInfoFallbackLanguageEnum];

/**
 * 
 * @export
 * @interface ApiSignInExpPatch200ResponseMfa
 */
export interface ApiSignInExpPatch200ResponseMfa {
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiSignInExpPatch200ResponseMfa
     */
    'factors': Array<ApiSignInExpPatch200ResponseMfaFactorsEnum>;
    /**
     * 
     * @type {string}
     * @memberof ApiSignInExpPatch200ResponseMfa
     */
    'policy': ApiSignInExpPatch200ResponseMfaPolicyEnum;
}

export const ApiSignInExpPatch200ResponseMfaFactorsEnum = {
    Totp: 'Totp',
    WebAuthn: 'WebAuthn',
    BackupCode: 'BackupCode'
} as const;

export type ApiSignInExpPatch200ResponseMfaFactorsEnum = typeof ApiSignInExpPatch200ResponseMfaFactorsEnum[keyof typeof ApiSignInExpPatch200ResponseMfaFactorsEnum];
export const ApiSignInExpPatch200ResponseMfaPolicyEnum = {
    UserControlled: 'UserControlled',
    Mandatory: 'Mandatory'
} as const;

export type ApiSignInExpPatch200ResponseMfaPolicyEnum = typeof ApiSignInExpPatch200ResponseMfaPolicyEnum[keyof typeof ApiSignInExpPatch200ResponseMfaPolicyEnum];

/**
 * 
 * @export
 * @interface ApiSignInExpPatch200ResponsePasswordPolicy
 */
export interface ApiSignInExpPatch200ResponsePasswordPolicy {
    /**
     * 
     * @type {ApiSignInExpGet200ResponsePasswordPolicyLength}
     * @memberof ApiSignInExpPatch200ResponsePasswordPolicy
     */
    'length'?: ApiSignInExpGet200ResponsePasswordPolicyLength;
    /**
     * 
     * @type {ApiSignInExpGet200ResponsePasswordPolicyCharacterTypes}
     * @memberof ApiSignInExpPatch200ResponsePasswordPolicy
     */
    'characterTypes'?: ApiSignInExpGet200ResponsePasswordPolicyCharacterTypes;
    /**
     * 
     * @type {ApiSignInExpGet200ResponsePasswordPolicyRejects}
     * @memberof ApiSignInExpPatch200ResponsePasswordPolicy
     */
    'rejects'?: ApiSignInExpGet200ResponsePasswordPolicyRejects;
}
/**
 * 
 * @export
 * @interface ApiSignInExpPatch200ResponseSignIn
 */
export interface ApiSignInExpPatch200ResponseSignIn {
    /**
     * 
     * @type {Array<ApiSignInExpGet200ResponseSignInMethodsInner>}
     * @memberof ApiSignInExpPatch200ResponseSignIn
     */
    'methods': Array<ApiSignInExpGet200ResponseSignInMethodsInner>;
}
/**
 * 
 * @export
 * @interface ApiSignInExpPatch200ResponseSignUp
 */
export interface ApiSignInExpPatch200ResponseSignUp {
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiSignInExpPatch200ResponseSignUp
     */
    'identifiers': Array<ApiSignInExpPatch200ResponseSignUpIdentifiersEnum>;
    /**
     * 
     * @type {boolean}
     * @memberof ApiSignInExpPatch200ResponseSignUp
     */
    'password': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApiSignInExpPatch200ResponseSignUp
     */
    'verify': boolean;
}

export const ApiSignInExpPatch200ResponseSignUpIdentifiersEnum = {
    Username: 'username',
    Email: 'email',
    Phone: 'phone'
} as const;

export type ApiSignInExpPatch200ResponseSignUpIdentifiersEnum = typeof ApiSignInExpPatch200ResponseSignUpIdentifiersEnum[keyof typeof ApiSignInExpPatch200ResponseSignUpIdentifiersEnum];

/**
 * 
 * @export
 * @interface ApiSignInExpPatchRequest
 */
export interface ApiSignInExpPatchRequest {
    /**
     * 
     * @type {ApiSignInExpPatchRequestColor}
     * @memberof ApiSignInExpPatchRequest
     */
    'color'?: ApiSignInExpPatchRequestColor;
    /**
     * 
     * @type {ApiInteractionConsentGet200ResponseApplicationBranding}
     * @memberof ApiSignInExpPatchRequest
     */
    'branding'?: ApiInteractionConsentGet200ResponseApplicationBranding;
    /**
     * 
     * @type {ApiSignInExpPatchRequestLanguageInfo}
     * @memberof ApiSignInExpPatchRequest
     */
    'languageInfo'?: ApiSignInExpPatchRequestLanguageInfo;
    /**
     * 
     * @type {ApiSignInExpPatchRequestSignIn}
     * @memberof ApiSignInExpPatchRequest
     */
    'signIn'?: ApiSignInExpPatchRequestSignIn;
    /**
     * 
     * @type {ApiSignInExpPatchRequestSignUp}
     * @memberof ApiSignInExpPatchRequest
     */
    'signUp'?: ApiSignInExpPatchRequestSignUp;
    /**
     * 
     * @type {ApiSignInExpGet200ResponseSocialSignIn}
     * @memberof ApiSignInExpPatchRequest
     */
    'socialSignIn'?: ApiSignInExpGet200ResponseSocialSignIn;
    /**
     * Specify the social sign-in connectors to display on the sign-in page.
     * @type {Array<string>}
     * @memberof ApiSignInExpPatchRequest
     */
    'socialSignInConnectorTargets'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ApiSignInExpPatchRequest
     */
    'signInMode'?: ApiSignInExpPatchRequestSignInModeEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiSignInExpPatchRequest
     */
    'customCss'?: string | null;
    /**
     * Custom content to display on experience flow pages. the page pathname will be the config key, the content will be the config value.
     * @type {{ [key: string]: string; }}
     * @memberof ApiSignInExpPatchRequest
     */
    'customContent'?: { [key: string]: string; };
    /**
     * 
     * @type {ApiSignInExpGet200ResponsePasswordPolicy}
     * @memberof ApiSignInExpPatchRequest
     */
    'passwordPolicy'?: ApiSignInExpGet200ResponsePasswordPolicy;
    /**
     * 
     * @type {ApiSignInExpGet200ResponseMfa}
     * @memberof ApiSignInExpPatchRequest
     */
    'mfa'?: ApiSignInExpGet200ResponseMfa;
    /**
     * 
     * @type {boolean}
     * @memberof ApiSignInExpPatchRequest
     */
    'singleSignOnEnabled'?: boolean;
    /**
     * 
     * @type {ApiSignInExpPatchRequestTermsOfUseUrl}
     * @memberof ApiSignInExpPatchRequest
     */
    'termsOfUseUrl'?: ApiSignInExpPatchRequestTermsOfUseUrl;
    /**
     * 
     * @type {ApiSignInExpPatchRequestTermsOfUseUrl}
     * @memberof ApiSignInExpPatchRequest
     */
    'privacyPolicyUrl'?: ApiSignInExpPatchRequestTermsOfUseUrl;
}

export const ApiSignInExpPatchRequestSignInModeEnum = {
    SignIn: 'SignIn',
    Register: 'Register',
    SignInAndRegister: 'SignInAndRegister'
} as const;

export type ApiSignInExpPatchRequestSignInModeEnum = typeof ApiSignInExpPatchRequestSignInModeEnum[keyof typeof ApiSignInExpPatchRequestSignInModeEnum];

/**
 * Specify the primary branding color for the sign-in page (both light/dark mode).
 * @export
 * @interface ApiSignInExpPatchRequestColor
 */
export interface ApiSignInExpPatchRequestColor {
    /**
     * 
     * @type {string}
     * @memberof ApiSignInExpPatchRequestColor
     */
    'primaryColor': string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiSignInExpPatchRequestColor
     */
    'isDarkModeEnabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiSignInExpPatchRequestColor
     */
    'darkPrimaryColor': string;
}
/**
 * Control the language detection policy for the sign-in page.
 * @export
 * @interface ApiSignInExpPatchRequestLanguageInfo
 */
export interface ApiSignInExpPatchRequestLanguageInfo {
    /**
     * 
     * @type {boolean}
     * @memberof ApiSignInExpPatchRequestLanguageInfo
     */
    'autoDetect': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiSignInExpPatchRequestLanguageInfo
     */
    'fallbackLanguage': ApiSignInExpPatchRequestLanguageInfoFallbackLanguageEnum;
}

export const ApiSignInExpPatchRequestLanguageInfoFallbackLanguageEnum = {
    AfZa: 'af-ZA',
    AmEt: 'am-ET',
    ArAr: 'ar-AR',
    AsIn: 'as-IN',
    AzAz: 'az-AZ',
    BeBy: 'be-BY',
    BgBg: 'bg-BG',
    BnIn: 'bn-IN',
    BrFr: 'br-FR',
    BsBa: 'bs-BA',
    CaEs: 'ca-ES',
    CbIq: 'cb-IQ',
    CoFr: 'co-FR',
    CsCz: 'cs-CZ',
    CxPh: 'cx-PH',
    CyGb: 'cy-GB',
    DaDk: 'da-DK',
    De: 'de',
    DeDe: 'de-DE',
    ElGr: 'el-GR',
    En: 'en',
    EnGb: 'en-GB',
    EnUs: 'en-US',
    EoEo: 'eo-EO',
    Es: 'es',
    EsEs: 'es-ES',
    Es419: 'es-419',
    EtEe: 'et-EE',
    EuEs: 'eu-ES',
    FaIr: 'fa-IR',
    FfNg: 'ff-NG',
    FiFi: 'fi-FI',
    FoFo: 'fo-FO',
    Fr: 'fr',
    FrCa: 'fr-CA',
    FrFr: 'fr-FR',
    FyNl: 'fy-NL',
    GaIe: 'ga-IE',
    GlEs: 'gl-ES',
    GnPy: 'gn-PY',
    GuIn: 'gu-IN',
    HaNg: 'ha-NG',
    HeIl: 'he-IL',
    HiIn: 'hi-IN',
    HrHr: 'hr-HR',
    HtHt: 'ht-HT',
    HuHu: 'hu-HU',
    HyAm: 'hy-AM',
    IdId: 'id-ID',
    IkUs: 'ik-US',
    IsIs: 'is-IS',
    It: 'it',
    ItIt: 'it-IT',
    IuCa: 'iu-CA',
    Ja: 'ja',
    JaJp: 'ja-JP',
    JaKs: 'ja-KS',
    JvId: 'jv-ID',
    KaGe: 'ka-GE',
    KkKz: 'kk-KZ',
    KmKh: 'km-KH',
    KnIn: 'kn-IN',
    Ko: 'ko',
    KoKr: 'ko-KR',
    KuTr: 'ku-TR',
    KyKg: 'ky-KG',
    LoLa: 'lo-LA',
    LtLt: 'lt-LT',
    LvLv: 'lv-LV',
    MgMg: 'mg-MG',
    MkMk: 'mk-MK',
    MlIn: 'ml-IN',
    MnMn: 'mn-MN',
    MrIn: 'mr-IN',
    MsMy: 'ms-MY',
    MtMt: 'mt-MT',
    MyMm: 'my-MM',
    NbNo: 'nb-NO',
    NeNp: 'ne-NP',
    NlBe: 'nl-BE',
    NlNl: 'nl-NL',
    NnNo: 'nn-NO',
    OrIn: 'or-IN',
    PaIn: 'pa-IN',
    PlPl: 'pl-PL',
    PsAf: 'ps-AF',
    Pt: 'pt',
    PtBr: 'pt-BR',
    PtPt: 'pt-PT',
    RoRo: 'ro-RO',
    Ru: 'ru',
    RuRu: 'ru-RU',
    RwRw: 'rw-RW',
    ScIt: 'sc-IT',
    SiLk: 'si-LK',
    SkSk: 'sk-SK',
    SlSi: 'sl-SI',
    SnZw: 'sn-ZW',
    SqAl: 'sq-AL',
    SrRs: 'sr-RS',
    SvSe: 'sv-SE',
    SwKe: 'sw-KE',
    SySy: 'sy-SY',
    SzPl: 'sz-PL',
    TaIn: 'ta-IN',
    TeIn: 'te-IN',
    TgTj: 'tg-TJ',
    ThTh: 'th-TH',
    TlPh: 'tl-PH',
    Tr: 'tr',
    TrTr: 'tr-TR',
    TtRu: 'tt-RU',
    TzMa: 'tz-MA',
    UkUa: 'uk-UA',
    UrPk: 'ur-PK',
    UzUz: 'uz-UZ',
    ViVn: 'vi-VN',
    Zh: 'zh',
    ZhCn: 'zh-CN',
    ZhHk: 'zh-HK',
    ZhMo: 'zh-MO',
    ZhTw: 'zh-TW',
    ZzTr: 'zz-TR'
} as const;

export type ApiSignInExpPatchRequestLanguageInfoFallbackLanguageEnum = typeof ApiSignInExpPatchRequestLanguageInfoFallbackLanguageEnum[keyof typeof ApiSignInExpPatchRequestLanguageInfoFallbackLanguageEnum];

/**
 * Sign-in method settings
 * @export
 * @interface ApiSignInExpPatchRequestSignIn
 */
export interface ApiSignInExpPatchRequestSignIn {
    /**
     * 
     * @type {Array<ApiSignInExpGet200ResponseSignInMethodsInner>}
     * @memberof ApiSignInExpPatchRequestSignIn
     */
    'methods': Array<ApiSignInExpGet200ResponseSignInMethodsInner>;
}
/**
 * Sign-up method settings
 * @export
 * @interface ApiSignInExpPatchRequestSignUp
 */
export interface ApiSignInExpPatchRequestSignUp {
    /**
     * Specify allowed identifiers when signing-up.
     * @type {Array<string>}
     * @memberof ApiSignInExpPatchRequestSignUp
     */
    'identifiers': Array<ApiSignInExpPatchRequestSignUpIdentifiersEnum>;
    /**
     * Whether the user is required to set a password when signing-up.
     * @type {boolean}
     * @memberof ApiSignInExpPatchRequestSignUp
     */
    'password': boolean;
    /**
     * Whether the user is required to verify their email/phone when signing-up.
     * @type {boolean}
     * @memberof ApiSignInExpPatchRequestSignUp
     */
    'verify': boolean;
}

export const ApiSignInExpPatchRequestSignUpIdentifiersEnum = {
    Username: 'username',
    Email: 'email',
    Phone: 'phone'
} as const;

export type ApiSignInExpPatchRequestSignUpIdentifiersEnum = typeof ApiSignInExpPatchRequestSignUpIdentifiersEnum[keyof typeof ApiSignInExpPatchRequestSignUpIdentifiersEnum];

/**
 * @type ApiSignInExpPatchRequestTermsOfUseUrl
 * @export
 */
export type ApiSignInExpPatchRequestTermsOfUseUrl = string;

/**
 * 
 * @export
 * @interface ApiSsoConnectorProvidersGet200ResponseInner
 */
export interface ApiSsoConnectorProvidersGet200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ApiSsoConnectorProvidersGet200ResponseInner
     */
    'providerName': ApiSsoConnectorProvidersGet200ResponseInnerProviderNameEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiSsoConnectorProvidersGet200ResponseInner
     */
    'providerType': ApiSsoConnectorProvidersGet200ResponseInnerProviderTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiSsoConnectorProvidersGet200ResponseInner
     */
    'logo': string;
    /**
     * 
     * @type {string}
     * @memberof ApiSsoConnectorProvidersGet200ResponseInner
     */
    'logoDark': string;
    /**
     * 
     * @type {string}
     * @memberof ApiSsoConnectorProvidersGet200ResponseInner
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ApiSsoConnectorProvidersGet200ResponseInner
     */
    'name': string;
}

export const ApiSsoConnectorProvidersGet200ResponseInnerProviderNameEnum = {
    Oidc: 'OIDC',
    Saml: 'SAML',
    AzureAd: 'AzureAD',
    GoogleWorkspace: 'GoogleWorkspace',
    Okta: 'Okta',
    AzureAdOidc: 'AzureAdOidc'
} as const;

export type ApiSsoConnectorProvidersGet200ResponseInnerProviderNameEnum = typeof ApiSsoConnectorProvidersGet200ResponseInnerProviderNameEnum[keyof typeof ApiSsoConnectorProvidersGet200ResponseInnerProviderNameEnum];
export const ApiSsoConnectorProvidersGet200ResponseInnerProviderTypeEnum = {
    Oidc: 'oidc',
    Saml: 'saml'
} as const;

export type ApiSsoConnectorProvidersGet200ResponseInnerProviderTypeEnum = typeof ApiSsoConnectorProvidersGet200ResponseInnerProviderTypeEnum[keyof typeof ApiSsoConnectorProvidersGet200ResponseInnerProviderTypeEnum];

/**
 * 
 * @export
 * @interface ApiSsoConnectorsGet200ResponseInner
 */
export interface ApiSsoConnectorsGet200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ApiSsoConnectorsGet200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiSsoConnectorsGet200ResponseInner
     */
    'providerName': ApiSsoConnectorsGet200ResponseInnerProviderNameEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiSsoConnectorsGet200ResponseInner
     */
    'connectorName': string;
    /**
     * arbitrary
     * @type {object}
     * @memberof ApiSsoConnectorsGet200ResponseInner
     */
    'config': object;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiSsoConnectorsGet200ResponseInner
     */
    'domains': Array<string>;
    /**
     * 
     * @type {ApiSsoConnectorsGet200ResponseInnerBranding}
     * @memberof ApiSsoConnectorsGet200ResponseInner
     */
    'branding': ApiSsoConnectorsGet200ResponseInnerBranding;
    /**
     * 
     * @type {boolean}
     * @memberof ApiSsoConnectorsGet200ResponseInner
     */
    'syncProfile': boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiSsoConnectorsGet200ResponseInner
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof ApiSsoConnectorsGet200ResponseInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiSsoConnectorsGet200ResponseInner
     */
    'providerType': ApiSsoConnectorsGet200ResponseInnerProviderTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiSsoConnectorsGet200ResponseInner
     */
    'providerLogo': string;
    /**
     * 
     * @type {string}
     * @memberof ApiSsoConnectorsGet200ResponseInner
     */
    'providerLogoDark': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ApiSsoConnectorsGet200ResponseInner
     */
    'providerConfig'?: { [key: string]: any; };
}

export const ApiSsoConnectorsGet200ResponseInnerProviderNameEnum = {
    Oidc: 'OIDC',
    Saml: 'SAML',
    AzureAd: 'AzureAD',
    GoogleWorkspace: 'GoogleWorkspace',
    Okta: 'Okta',
    AzureAdOidc: 'AzureAdOidc'
} as const;

export type ApiSsoConnectorsGet200ResponseInnerProviderNameEnum = typeof ApiSsoConnectorsGet200ResponseInnerProviderNameEnum[keyof typeof ApiSsoConnectorsGet200ResponseInnerProviderNameEnum];
export const ApiSsoConnectorsGet200ResponseInnerProviderTypeEnum = {
    Oidc: 'oidc',
    Saml: 'saml'
} as const;

export type ApiSsoConnectorsGet200ResponseInnerProviderTypeEnum = typeof ApiSsoConnectorsGet200ResponseInnerProviderTypeEnum[keyof typeof ApiSsoConnectorsGet200ResponseInnerProviderTypeEnum];

/**
 * 
 * @export
 * @interface ApiSsoConnectorsGet200ResponseInnerBranding
 */
export interface ApiSsoConnectorsGet200ResponseInnerBranding {
    /**
     * 
     * @type {string}
     * @memberof ApiSsoConnectorsGet200ResponseInnerBranding
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiSsoConnectorsGet200ResponseInnerBranding
     */
    'logo'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiSsoConnectorsGet200ResponseInnerBranding
     */
    'darkLogo'?: string;
}
/**
 * 
 * @export
 * @interface ApiSsoConnectorsIdPatchRequest
 */
export interface ApiSsoConnectorsIdPatchRequest {
    /**
     * arbitrary
     * @type {object}
     * @memberof ApiSsoConnectorsIdPatchRequest
     */
    'config'?: object;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiSsoConnectorsIdPatchRequest
     */
    'domains'?: Array<string>;
    /**
     * 
     * @type {ApiSsoConnectorsGet200ResponseInnerBranding}
     * @memberof ApiSsoConnectorsIdPatchRequest
     */
    'branding'?: ApiSsoConnectorsGet200ResponseInnerBranding;
    /**
     * 
     * @type {boolean}
     * @memberof ApiSsoConnectorsIdPatchRequest
     */
    'syncProfile'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiSsoConnectorsIdPatchRequest
     */
    'connectorName'?: string;
}
/**
 * 
 * @export
 * @interface ApiSsoConnectorsPost200Response
 */
export interface ApiSsoConnectorsPost200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiSsoConnectorsPost200Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiSsoConnectorsPost200Response
     */
    'providerName': string;
    /**
     * 
     * @type {string}
     * @memberof ApiSsoConnectorsPost200Response
     */
    'connectorName': string;
    /**
     * arbitrary
     * @type {object}
     * @memberof ApiSsoConnectorsPost200Response
     */
    'config': object;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiSsoConnectorsPost200Response
     */
    'domains': Array<string>;
    /**
     * 
     * @type {ApiSsoConnectorsGet200ResponseInnerBranding}
     * @memberof ApiSsoConnectorsPost200Response
     */
    'branding': ApiSsoConnectorsGet200ResponseInnerBranding;
    /**
     * 
     * @type {boolean}
     * @memberof ApiSsoConnectorsPost200Response
     */
    'syncProfile': boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiSsoConnectorsPost200Response
     */
    'createdAt': number;
}
/**
 * 
 * @export
 * @interface ApiSsoConnectorsPostRequest
 */
export interface ApiSsoConnectorsPostRequest {
    /**
     * arbitrary
     * @type {object}
     * @memberof ApiSsoConnectorsPostRequest
     */
    'config'?: object;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiSsoConnectorsPostRequest
     */
    'domains'?: Array<string>;
    /**
     * 
     * @type {ApiSsoConnectorsGet200ResponseInnerBranding}
     * @memberof ApiSsoConnectorsPostRequest
     */
    'branding'?: ApiSsoConnectorsGet200ResponseInnerBranding;
    /**
     * 
     * @type {boolean}
     * @memberof ApiSsoConnectorsPostRequest
     */
    'syncProfile'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiSsoConnectorsPostRequest
     */
    'providerName': string;
    /**
     * 
     * @type {string}
     * @memberof ApiSsoConnectorsPostRequest
     */
    'connectorName': string;
}
/**
 * 
 * @export
 * @interface ApiSystemsApplicationGet200Response
 */
export interface ApiSystemsApplicationGet200Response {
    /**
     * 
     * @type {ApiSystemsApplicationGet200ResponseProtectedApps}
     * @memberof ApiSystemsApplicationGet200Response
     */
    'protectedApps': ApiSystemsApplicationGet200ResponseProtectedApps;
}
/**
 * 
 * @export
 * @interface ApiSystemsApplicationGet200ResponseProtectedApps
 */
export interface ApiSystemsApplicationGet200ResponseProtectedApps {
    /**
     * 
     * @type {string}
     * @memberof ApiSystemsApplicationGet200ResponseProtectedApps
     */
    'defaultDomain': string;
}
/**
 * 
 * @export
 * @interface ApiUserAssetsPost200Response
 */
export interface ApiUserAssetsPost200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiUserAssetsPost200Response
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface ApiUserAssetsServiceStatusGet200Response
 */
export interface ApiUserAssetsServiceStatusGet200Response {
    /**
     * 
     * @type {ApiUserAssetsServiceStatusGet200ResponseStatus}
     * @memberof ApiUserAssetsServiceStatusGet200Response
     */
    'status': ApiUserAssetsServiceStatusGet200ResponseStatus;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiUserAssetsServiceStatusGet200Response
     */
    'allowUploadMimeTypes'?: Array<ApiUserAssetsServiceStatusGet200ResponseAllowUploadMimeTypesEnum>;
    /**
     * 
     * @type {number}
     * @memberof ApiUserAssetsServiceStatusGet200Response
     */
    'maxUploadFileSize'?: number;
}

export const ApiUserAssetsServiceStatusGet200ResponseAllowUploadMimeTypesEnum = {
    Jpeg: 'image/jpeg',
    Png: 'image/png',
    Gif: 'image/gif',
    VndMicrosoftIcon: 'image/vnd.microsoft.icon',
    XIcon: 'image/x-icon',
    Svgxml: 'image/svg+xml',
    Tiff: 'image/tiff',
    Webp: 'image/webp',
    Bmp: 'image/bmp'
} as const;

export type ApiUserAssetsServiceStatusGet200ResponseAllowUploadMimeTypesEnum = typeof ApiUserAssetsServiceStatusGet200ResponseAllowUploadMimeTypesEnum[keyof typeof ApiUserAssetsServiceStatusGet200ResponseAllowUploadMimeTypesEnum];

/**
 * @type ApiUserAssetsServiceStatusGet200ResponseStatus
 * @export
 */
export type ApiUserAssetsServiceStatusGet200ResponseStatus = string;

/**
 * User data to create a new user. All properties are optional.
 * @export
 * @interface ApiUsersPostRequest
 */
export interface ApiUsersPostRequest {
    /**
     * Primary phone number for the user. It should be unique across all users.
     * @type {string}
     * @memberof ApiUsersPostRequest
     */
    'primaryPhone'?: string;
    /**
     * Primary email address for the user. It should be unique across all users.
     * @type {string}
     * @memberof ApiUsersPostRequest
     */
    'primaryEmail'?: string;
    /**
     * Username for the user. It should be unique across all users.
     * @type {string}
     * @memberof ApiUsersPostRequest
     */
    'username'?: string;
    /**
     * Plain text password for the user.
     * @type {string}
     * @memberof ApiUsersPostRequest
     */
    'password'?: string;
    /**
     * In case you already have the password digests and not the passwords, you can use them for the newly created user via this property. The value should be generated with one of the supported algorithms. The algorithm can be specified using the `passwordAlgorithm` property.
     * @type {string}
     * @memberof ApiUsersPostRequest
     */
    'passwordDigest'?: string;
    /**
     * The hash algorithm used for the password. It should be one of the supported algorithms: argon2, md5, sha1, sha256. Should the encryption algorithm differ from argon2, it will automatically be upgraded to argon2 upon the user\'s next sign-in.
     * @type {string}
     * @memberof ApiUsersPostRequest
     */
    'passwordAlgorithm'?: ApiUsersPostRequestPasswordAlgorithmEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersPostRequest
     */
    'name'?: string;
    /**
     * 
     * @type {ApiUsersUserIdPatchRequestAvatar}
     * @memberof ApiUsersPostRequest
     */
    'avatar'?: ApiUsersUserIdPatchRequestAvatar | null;
    /**
     * arbitrary
     * @type {object}
     * @memberof ApiUsersPostRequest
     */
    'customData'?: object;
    /**
     * 
     * @type {ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfile}
     * @memberof ApiUsersPostRequest
     */
    'profile'?: ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfile;
}

export const ApiUsersPostRequestPasswordAlgorithmEnum = {
    Argon2i: 'Argon2i',
    Sha1: 'SHA1',
    Sha256: 'SHA256',
    Md5: 'MD5',
    Bcrypt: 'Bcrypt'
} as const;

export type ApiUsersPostRequestPasswordAlgorithmEnum = typeof ApiUsersPostRequestPasswordAlgorithmEnum[keyof typeof ApiUsersPostRequestPasswordAlgorithmEnum];

/**
 * 
 * @export
 * @interface ApiUsersUserIdCustomDataPatchRequest
 */
export interface ApiUsersUserIdCustomDataPatchRequest {
    /**
     * Partial custom data object to update for the given user ID.
     * @type {object}
     * @memberof ApiUsersUserIdCustomDataPatchRequest
     */
    'customData': object;
}
/**
 * 
 * @export
 * @interface ApiUsersUserIdGet200Response
 */
export interface ApiUsersUserIdGet200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdGet200Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdGet200Response
     */
    'username': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdGet200Response
     */
    'primaryEmail': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdGet200Response
     */
    'primaryPhone': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdGet200Response
     */
    'name': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdGet200Response
     */
    'avatar': string | null;
    /**
     * arbitrary
     * @type {object}
     * @memberof ApiUsersUserIdGet200Response
     */
    'customData': object;
    /**
     * 
     * @type {{ [key: string]: ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserIdentitiesValue; }}
     * @memberof ApiUsersUserIdGet200Response
     */
    'identities': { [key: string]: ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserIdentitiesValue; };
    /**
     * 
     * @type {number}
     * @memberof ApiUsersUserIdGet200Response
     */
    'lastSignInAt': number | null;
    /**
     * 
     * @type {number}
     * @memberof ApiUsersUserIdGet200Response
     */
    'createdAt': number;
    /**
     * 
     * @type {number}
     * @memberof ApiUsersUserIdGet200Response
     */
    'updatedAt': number;
    /**
     * 
     * @type {ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfile}
     * @memberof ApiUsersUserIdGet200Response
     */
    'profile': ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfile;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdGet200Response
     */
    'applicationId': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApiUsersUserIdGet200Response
     */
    'isSuspended': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApiUsersUserIdGet200Response
     */
    'hasPassword'?: boolean;
    /**
     * List of SSO identities associated with the user. Only available when the `includeSsoIdentities` query parameter is provided with a truthy value.
     * @type {Array<ApiUsersUserIdGet200ResponseSsoIdentitiesInner>}
     * @memberof ApiUsersUserIdGet200Response
     */
    'ssoIdentities'?: Array<ApiUsersUserIdGet200ResponseSsoIdentitiesInner>;
}
/**
 * 
 * @export
 * @interface ApiUsersUserIdGet200ResponseSsoIdentitiesInner
 */
export interface ApiUsersUserIdGet200ResponseSsoIdentitiesInner {
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdGet200ResponseSsoIdentitiesInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdGet200ResponseSsoIdentitiesInner
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdGet200ResponseSsoIdentitiesInner
     */
    'issuer': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdGet200ResponseSsoIdentitiesInner
     */
    'identityId': string;
    /**
     * arbitrary
     * @type {object}
     * @memberof ApiUsersUserIdGet200ResponseSsoIdentitiesInner
     */
    'detail': object;
    /**
     * 
     * @type {number}
     * @memberof ApiUsersUserIdGet200ResponseSsoIdentitiesInner
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdGet200ResponseSsoIdentitiesInner
     */
    'ssoConnectorId': string;
}
/**
 * 
 * @export
 * @interface ApiUsersUserIdHasPasswordGet200Response
 */
export interface ApiUsersUserIdHasPasswordGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ApiUsersUserIdHasPasswordGet200Response
     */
    'hasPassword': boolean;
}
/**
 * 
 * @export
 * @interface ApiUsersUserIdIdentitiesPostRequest
 */
export interface ApiUsersUserIdIdentitiesPostRequest {
    /**
     * The Logto connector ID.
     * @type {string}
     * @memberof ApiUsersUserIdIdentitiesPostRequest
     */
    'connectorId': string;
    /**
     * A json object constructed from the url query params returned by the social platform. Typically it contains `code`, `state` and `redirectUri` fields.
     * @type {{ [key: string]: any; }}
     * @memberof ApiUsersUserIdIdentitiesPostRequest
     */
    'connectorData': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ApiUsersUserIdIdentitiesTargetPutRequest
 */
export interface ApiUsersUserIdIdentitiesTargetPutRequest {
    /**
     * The user\'s social identity ID.
     * @type {string}
     * @memberof ApiUsersUserIdIdentitiesTargetPutRequest
     */
    'userId': string;
    /**
     * The user\'s social identity details.
     * @type {object}
     * @memberof ApiUsersUserIdIdentitiesTargetPutRequest
     */
    'details'?: object;
}
/**
 * 
 * @export
 * @interface ApiUsersUserIdIsSuspendedPatchRequest
 */
export interface ApiUsersUserIdIsSuspendedPatchRequest {
    /**
     * New suspension status for the user.
     * @type {boolean}
     * @memberof ApiUsersUserIdIsSuspendedPatchRequest
     */
    'isSuspended': boolean;
}
/**
 * 
 * @export
 * @interface ApiUsersUserIdMfaVerificationsGet200ResponseInner
 */
export interface ApiUsersUserIdMfaVerificationsGet200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdMfaVerificationsGet200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdMfaVerificationsGet200ResponseInner
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdMfaVerificationsGet200ResponseInner
     */
    'type': ApiUsersUserIdMfaVerificationsGet200ResponseInnerTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdMfaVerificationsGet200ResponseInner
     */
    'agent'?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiUsersUserIdMfaVerificationsGet200ResponseInner
     */
    'remainCodes'?: number;
}

export const ApiUsersUserIdMfaVerificationsGet200ResponseInnerTypeEnum = {
    Totp: 'Totp',
    WebAuthn: 'WebAuthn',
    BackupCode: 'BackupCode'
} as const;

export type ApiUsersUserIdMfaVerificationsGet200ResponseInnerTypeEnum = typeof ApiUsersUserIdMfaVerificationsGet200ResponseInnerTypeEnum[keyof typeof ApiUsersUserIdMfaVerificationsGet200ResponseInnerTypeEnum];

/**
 * @type ApiUsersUserIdMfaVerificationsPost200Response
 * @export
 */
export type ApiUsersUserIdMfaVerificationsPost200Response = ApiUsersUserIdMfaVerificationsPost200ResponseOneOf | ApiUsersUserIdMfaVerificationsPost200ResponseOneOf1;

/**
 * 
 * @export
 * @interface ApiUsersUserIdMfaVerificationsPost200ResponseOneOf
 */
export interface ApiUsersUserIdMfaVerificationsPost200ResponseOneOf {
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdMfaVerificationsPost200ResponseOneOf
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdMfaVerificationsPost200ResponseOneOf
     */
    'secret': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdMfaVerificationsPost200ResponseOneOf
     */
    'secretQrCode': string;
}
/**
 * 
 * @export
 * @interface ApiUsersUserIdMfaVerificationsPost200ResponseOneOf1
 */
export interface ApiUsersUserIdMfaVerificationsPost200ResponseOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdMfaVerificationsPost200ResponseOneOf1
     */
    'type': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiUsersUserIdMfaVerificationsPost200ResponseOneOf1
     */
    'codes': Array<string>;
}
/**
 * 
 * @export
 * @interface ApiUsersUserIdMfaVerificationsPostRequest
 */
export interface ApiUsersUserIdMfaVerificationsPostRequest {
    /**
     * 
     * @type {ApiUsersUserIdMfaVerificationsPostRequestType}
     * @memberof ApiUsersUserIdMfaVerificationsPostRequest
     */
    'type': ApiUsersUserIdMfaVerificationsPostRequestType;
}
/**
 * @type ApiUsersUserIdMfaVerificationsPostRequestType
 * The type of MFA verification to create.
 * @export
 */
export type ApiUsersUserIdMfaVerificationsPostRequestType = string;

/**
 * 
 * @export
 * @interface ApiUsersUserIdOrganizationsGet200ResponseInner
 */
export interface ApiUsersUserIdOrganizationsGet200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdOrganizationsGet200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdOrganizationsGet200ResponseInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdOrganizationsGet200ResponseInner
     */
    'description': string | null;
    /**
     * arbitrary
     * @type {object}
     * @memberof ApiUsersUserIdOrganizationsGet200ResponseInner
     */
    'customData': object;
    /**
     * 
     * @type {boolean}
     * @memberof ApiUsersUserIdOrganizationsGet200ResponseInner
     */
    'isMfaRequired': boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiUsersUserIdOrganizationsGet200ResponseInner
     */
    'createdAt': number;
    /**
     * 
     * @type {Array<ApiUsersUserIdOrganizationsGet200ResponseInnerOrganizationRolesInner>}
     * @memberof ApiUsersUserIdOrganizationsGet200ResponseInner
     */
    'organizationRoles': Array<ApiUsersUserIdOrganizationsGet200ResponseInnerOrganizationRolesInner>;
}
/**
 * 
 * @export
 * @interface ApiUsersUserIdOrganizationsGet200ResponseInnerOrganizationRolesInner
 */
export interface ApiUsersUserIdOrganizationsGet200ResponseInnerOrganizationRolesInner {
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdOrganizationsGet200ResponseInnerOrganizationRolesInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdOrganizationsGet200ResponseInnerOrganizationRolesInner
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ApiUsersUserIdPasswordPatchRequest
 */
export interface ApiUsersUserIdPasswordPatchRequest {
    /**
     * New password for the user.
     * @type {string}
     * @memberof ApiUsersUserIdPasswordPatchRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface ApiUsersUserIdPasswordVerifyPostRequest
 */
export interface ApiUsersUserIdPasswordVerifyPostRequest {
    /**
     * Password to verify.
     * @type {string}
     * @memberof ApiUsersUserIdPasswordVerifyPostRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface ApiUsersUserIdPatch200Response
 */
export interface ApiUsersUserIdPatch200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdPatch200Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdPatch200Response
     */
    'username': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdPatch200Response
     */
    'primaryEmail': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdPatch200Response
     */
    'primaryPhone': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdPatch200Response
     */
    'name': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdPatch200Response
     */
    'avatar': string | null;
    /**
     * arbitrary
     * @type {object}
     * @memberof ApiUsersUserIdPatch200Response
     */
    'customData': object;
    /**
     * 
     * @type {{ [key: string]: ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserIdentitiesValue; }}
     * @memberof ApiUsersUserIdPatch200Response
     */
    'identities': { [key: string]: ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserIdentitiesValue; };
    /**
     * 
     * @type {number}
     * @memberof ApiUsersUserIdPatch200Response
     */
    'lastSignInAt': number | null;
    /**
     * 
     * @type {number}
     * @memberof ApiUsersUserIdPatch200Response
     */
    'createdAt': number;
    /**
     * 
     * @type {number}
     * @memberof ApiUsersUserIdPatch200Response
     */
    'updatedAt': number;
    /**
     * 
     * @type {ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfile}
     * @memberof ApiUsersUserIdPatch200Response
     */
    'profile': ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfile;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdPatch200Response
     */
    'applicationId': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApiUsersUserIdPatch200Response
     */
    'isSuspended': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApiUsersUserIdPatch200Response
     */
    'hasPassword'?: boolean;
    /**
     * 
     * @type {Array<ApiUsersUserIdGet200ResponseSsoIdentitiesInner>}
     * @memberof ApiUsersUserIdPatch200Response
     */
    'ssoIdentities'?: Array<ApiUsersUserIdGet200ResponseSsoIdentitiesInner>;
}
/**
 * 
 * @export
 * @interface ApiUsersUserIdPatchRequest
 */
export interface ApiUsersUserIdPatchRequest {
    /**
     * 
     * @type {ApiUsersUserIdPatchRequestUsername}
     * @memberof ApiUsersUserIdPatchRequest
     */
    'username'?: ApiUsersUserIdPatchRequestUsername | null;
    /**
     * 
     * @type {ApiUsersUserIdPatchRequestPrimaryEmail}
     * @memberof ApiUsersUserIdPatchRequest
     */
    'primaryEmail'?: ApiUsersUserIdPatchRequestPrimaryEmail | null;
    /**
     * 
     * @type {ApiUsersUserIdPatchRequestPrimaryPhone}
     * @memberof ApiUsersUserIdPatchRequest
     */
    'primaryPhone'?: ApiUsersUserIdPatchRequestPrimaryPhone | null;
    /**
     * 
     * @type {ApiUsersUserIdPatchRequestName}
     * @memberof ApiUsersUserIdPatchRequest
     */
    'name'?: ApiUsersUserIdPatchRequestName | null;
    /**
     * 
     * @type {ApiUsersUserIdPatchRequestAvatar}
     * @memberof ApiUsersUserIdPatchRequest
     */
    'avatar'?: ApiUsersUserIdPatchRequestAvatar | null;
    /**
     * Custom data object to update for the given user ID. Note this will replace the entire custom data object.  If you want to perform a partial update, use the `PATCH /api/users/{userId}/custom-data` endpoint instead.
     * @type {object}
     * @memberof ApiUsersUserIdPatchRequest
     */
    'customData'?: object;
    /**
     * 
     * @type {ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfile}
     * @memberof ApiUsersUserIdPatchRequest
     */
    'profile'?: ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfile;
}
/**
 * @type ApiUsersUserIdPatchRequestAvatar
 * @export
 */
export type ApiUsersUserIdPatchRequestAvatar = string;

/**
 * @type ApiUsersUserIdPatchRequestName
 * @export
 */
export type ApiUsersUserIdPatchRequestName = string;

/**
 * @type ApiUsersUserIdPatchRequestPrimaryEmail
 * Updated primary email address for the user. It should be unique across all users.
 * @export
 */
export type ApiUsersUserIdPatchRequestPrimaryEmail = string;

/**
 * @type ApiUsersUserIdPatchRequestPrimaryPhone
 * Updated primary phone number for the user. It should be unique across all users.
 * @export
 */
export type ApiUsersUserIdPatchRequestPrimaryPhone = string;

/**
 * @type ApiUsersUserIdPatchRequestUsername
 * Updated username for the user. It should be unique across all users.
 * @export
 */
export type ApiUsersUserIdPatchRequestUsername = string;

/**
 * 
 * @export
 * @interface ApiUsersUserIdProfilePatchRequest
 */
export interface ApiUsersUserIdProfilePatchRequest {
    /**
     * 
     * @type {ApiUsersUserIdProfilePatchRequestProfile}
     * @memberof ApiUsersUserIdProfilePatchRequest
     */
    'profile': ApiUsersUserIdProfilePatchRequestProfile;
}
/**
 * Partial profile object to update for the given user ID.
 * @export
 * @interface ApiUsersUserIdProfilePatchRequestProfile
 */
export interface ApiUsersUserIdProfilePatchRequestProfile {
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdProfilePatchRequestProfile
     */
    'familyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdProfilePatchRequestProfile
     */
    'givenName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdProfilePatchRequestProfile
     */
    'middleName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdProfilePatchRequestProfile
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdProfilePatchRequestProfile
     */
    'preferredUsername'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdProfilePatchRequestProfile
     */
    'profile'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdProfilePatchRequestProfile
     */
    'website'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdProfilePatchRequestProfile
     */
    'gender'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdProfilePatchRequestProfile
     */
    'birthdate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdProfilePatchRequestProfile
     */
    'zoneinfo'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiUsersUserIdProfilePatchRequestProfile
     */
    'locale'?: string;
    /**
     * 
     * @type {ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfileAddress}
     * @memberof ApiUsersUserIdProfilePatchRequestProfile
     */
    'address'?: ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfileAddress;
}
/**
 * @type ApiVerificationCodesVerifyPostRequest
 * @export
 */
export type ApiVerificationCodesVerifyPostRequest = ApiInteractionPutRequestIdentifierOneOf3 | ApiInteractionPutRequestIdentifierOneOf4;

/**
 * @type ApiWellKnownPhrasesGet200ResponseValue
 * @export
 */
export type ApiWellKnownPhrasesGet200ResponseValue = string | { [key: string]: any; };

/**
 * 
 * @export
 * @interface ApiWellKnownSignInExpGet200Response
 */
export interface ApiWellKnownSignInExpGet200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiWellKnownSignInExpGet200Response
     */
    'id': string;
    /**
     * 
     * @type {ApiSignInExpPatch200ResponseColor}
     * @memberof ApiWellKnownSignInExpGet200Response
     */
    'color': ApiSignInExpPatch200ResponseColor;
    /**
     * 
     * @type {ApiInteractionConsentGet200ResponseApplicationBranding}
     * @memberof ApiWellKnownSignInExpGet200Response
     */
    'branding': ApiInteractionConsentGet200ResponseApplicationBranding;
    /**
     * 
     * @type {ApiSignInExpPatch200ResponseLanguageInfo}
     * @memberof ApiWellKnownSignInExpGet200Response
     */
    'languageInfo': ApiSignInExpPatch200ResponseLanguageInfo;
    /**
     * 
     * @type {string}
     * @memberof ApiWellKnownSignInExpGet200Response
     */
    'termsOfUseUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiWellKnownSignInExpGet200Response
     */
    'privacyPolicyUrl': string | null;
    /**
     * 
     * @type {ApiSignInExpPatch200ResponseSignIn}
     * @memberof ApiWellKnownSignInExpGet200Response
     */
    'signIn': ApiSignInExpPatch200ResponseSignIn;
    /**
     * 
     * @type {ApiSignInExpPatch200ResponseSignUp}
     * @memberof ApiWellKnownSignInExpGet200Response
     */
    'signUp': ApiSignInExpPatch200ResponseSignUp;
    /**
     * 
     * @type {ApiSignInExpGet200ResponseSocialSignIn}
     * @memberof ApiWellKnownSignInExpGet200Response
     */
    'socialSignIn': ApiSignInExpGet200ResponseSocialSignIn;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiWellKnownSignInExpGet200Response
     */
    'socialSignInConnectorTargets': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ApiWellKnownSignInExpGet200Response
     */
    'signInMode': ApiWellKnownSignInExpGet200ResponseSignInModeEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiWellKnownSignInExpGet200Response
     */
    'customCss': string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiWellKnownSignInExpGet200Response
     */
    'customContent': { [key: string]: string; };
    /**
     * 
     * @type {ApiSignInExpPatch200ResponsePasswordPolicy}
     * @memberof ApiWellKnownSignInExpGet200Response
     */
    'passwordPolicy': ApiSignInExpPatch200ResponsePasswordPolicy;
    /**
     * 
     * @type {ApiSignInExpPatch200ResponseMfa}
     * @memberof ApiWellKnownSignInExpGet200Response
     */
    'mfa': ApiSignInExpPatch200ResponseMfa;
    /**
     * 
     * @type {boolean}
     * @memberof ApiWellKnownSignInExpGet200Response
     */
    'singleSignOnEnabled': boolean;
    /**
     * 
     * @type {Array<ApiWellKnownSignInExpGet200ResponseSocialConnectorsInner>}
     * @memberof ApiWellKnownSignInExpGet200Response
     */
    'socialConnectors': Array<ApiWellKnownSignInExpGet200ResponseSocialConnectorsInner>;
    /**
     * 
     * @type {Array<ApiWellKnownSignInExpGet200ResponseSsoConnectorsInner>}
     * @memberof ApiWellKnownSignInExpGet200Response
     */
    'ssoConnectors': Array<ApiWellKnownSignInExpGet200ResponseSsoConnectorsInner>;
    /**
     * 
     * @type {ApiWellKnownSignInExpGet200ResponseForgotPassword}
     * @memberof ApiWellKnownSignInExpGet200Response
     */
    'forgotPassword': ApiWellKnownSignInExpGet200ResponseForgotPassword;
    /**
     * 
     * @type {boolean}
     * @memberof ApiWellKnownSignInExpGet200Response
     */
    'isDevelopmentTenant': boolean;
}

export const ApiWellKnownSignInExpGet200ResponseSignInModeEnum = {
    SignIn: 'SignIn',
    Register: 'Register',
    SignInAndRegister: 'SignInAndRegister'
} as const;

export type ApiWellKnownSignInExpGet200ResponseSignInModeEnum = typeof ApiWellKnownSignInExpGet200ResponseSignInModeEnum[keyof typeof ApiWellKnownSignInExpGet200ResponseSignInModeEnum];

/**
 * 
 * @export
 * @interface ApiWellKnownSignInExpGet200ResponseForgotPassword
 */
export interface ApiWellKnownSignInExpGet200ResponseForgotPassword {
    /**
     * 
     * @type {boolean}
     * @memberof ApiWellKnownSignInExpGet200ResponseForgotPassword
     */
    'phone': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApiWellKnownSignInExpGet200ResponseForgotPassword
     */
    'email': boolean;
}
/**
 * 
 * @export
 * @interface ApiWellKnownSignInExpGet200ResponseSocialConnectorsInner
 */
export interface ApiWellKnownSignInExpGet200ResponseSocialConnectorsInner {
    /**
     * 
     * @type {string}
     * @memberof ApiWellKnownSignInExpGet200ResponseSocialConnectorsInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiWellKnownSignInExpGet200ResponseSocialConnectorsInner
     */
    'target': string;
    /**
     * Validator function
     * @type {object}
     * @memberof ApiWellKnownSignInExpGet200ResponseSocialConnectorsInner
     */
    'name': object;
    /**
     * Validator function
     * @type {object}
     * @memberof ApiWellKnownSignInExpGet200ResponseSocialConnectorsInner
     */
    'description': object;
    /**
     * 
     * @type {string}
     * @memberof ApiWellKnownSignInExpGet200ResponseSocialConnectorsInner
     */
    'logo': string;
    /**
     * 
     * @type {string}
     * @memberof ApiWellKnownSignInExpGet200ResponseSocialConnectorsInner
     */
    'logoDark': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiWellKnownSignInExpGet200ResponseSocialConnectorsInner
     */
    'readme': string;
    /**
     * 
     * @type {string}
     * @memberof ApiWellKnownSignInExpGet200ResponseSocialConnectorsInner
     */
    'configTemplate'?: string;
    /**
     * 
     * @type {Array<ApiConnectorsGet200ResponseInnerFormItemsInner>}
     * @memberof ApiWellKnownSignInExpGet200ResponseSocialConnectorsInner
     */
    'formItems'?: Array<ApiConnectorsGet200ResponseInnerFormItemsInner>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ApiWellKnownSignInExpGet200ResponseSocialConnectorsInner
     */
    'customData'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ApiWellKnownSignInExpGet200ResponseSocialConnectorsInner
     */
    'fromEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiWellKnownSignInExpGet200ResponseSocialConnectorsInner
     */
    'platform': ApiWellKnownSignInExpGet200ResponseSocialConnectorsInnerPlatformEnum | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApiWellKnownSignInExpGet200ResponseSocialConnectorsInner
     */
    'isStandard'?: boolean;
}

export const ApiWellKnownSignInExpGet200ResponseSocialConnectorsInnerPlatformEnum = {
    Native: 'Native',
    Universal: 'Universal',
    Web: 'Web'
} as const;

export type ApiWellKnownSignInExpGet200ResponseSocialConnectorsInnerPlatformEnum = typeof ApiWellKnownSignInExpGet200ResponseSocialConnectorsInnerPlatformEnum[keyof typeof ApiWellKnownSignInExpGet200ResponseSocialConnectorsInnerPlatformEnum];

/**
 * 
 * @export
 * @interface ApiWellKnownSignInExpGet200ResponseSsoConnectorsInner
 */
export interface ApiWellKnownSignInExpGet200ResponseSsoConnectorsInner {
    /**
     * 
     * @type {string}
     * @memberof ApiWellKnownSignInExpGet200ResponseSsoConnectorsInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiWellKnownSignInExpGet200ResponseSsoConnectorsInner
     */
    'connectorName': string;
    /**
     * 
     * @type {string}
     * @memberof ApiWellKnownSignInExpGet200ResponseSsoConnectorsInner
     */
    'logo': string;
    /**
     * 
     * @type {string}
     * @memberof ApiWellKnownSignInExpGet200ResponseSsoConnectorsInner
     */
    'darkLogo'?: string;
}
/**
 * @type Translation
 * @export
 */
export type Translation = string;

/**
 * 
 * @export
 * @interface TranslationObject
 */
export interface TranslationObject {
    /**
     * 
     * @type {Translation}
     * @memberof TranslationObject
     */
    '[translationKey]'?: Translation;
}

/**
 * ApplicationsApi - axios parameter creator
 * @export
 */
export const ApplicationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get API resource roles assigned to the specified application with pagination.
         * @summary Get application API resource roles
         * @param {string} applicationId The unique identifier of the application.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsApplicationIdRolesGet: async (applicationId: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('apiApplicationsApplicationIdRolesGet', 'applicationId', applicationId)
            const localVarPath = `/api/applications/{applicationId}/roles`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign API resource roles to the specified application. The API resource roles will be added to the existing API resource roles.
         * @summary Assign API resource roles to application
         * @param {string} applicationId The unique identifier of the application.
         * @param {ApiApplicationsApplicationIdRolesPostRequest} apiApplicationsApplicationIdRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsApplicationIdRolesPost: async (applicationId: string, apiApplicationsApplicationIdRolesPostRequest: ApiApplicationsApplicationIdRolesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('apiApplicationsApplicationIdRolesPost', 'applicationId', applicationId)
            // verify required parameter 'apiApplicationsApplicationIdRolesPostRequest' is not null or undefined
            assertParamExists('apiApplicationsApplicationIdRolesPost', 'apiApplicationsApplicationIdRolesPostRequest', apiApplicationsApplicationIdRolesPostRequest)
            const localVarPath = `/api/applications/{applicationId}/roles`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiApplicationsApplicationIdRolesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update API resource roles assigned to the specified application. This will replace the existing API resource roles.
         * @summary Update API resource roles for application
         * @param {string} applicationId The unique identifier of the application.
         * @param {ApiApplicationsApplicationIdRolesPutRequest} apiApplicationsApplicationIdRolesPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsApplicationIdRolesPut: async (applicationId: string, apiApplicationsApplicationIdRolesPutRequest: ApiApplicationsApplicationIdRolesPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('apiApplicationsApplicationIdRolesPut', 'applicationId', applicationId)
            // verify required parameter 'apiApplicationsApplicationIdRolesPutRequest' is not null or undefined
            assertParamExists('apiApplicationsApplicationIdRolesPut', 'apiApplicationsApplicationIdRolesPutRequest', apiApplicationsApplicationIdRolesPutRequest)
            const localVarPath = `/api/applications/{applicationId}/roles`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiApplicationsApplicationIdRolesPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a API resource role from the specified application.
         * @summary Remove a API resource role from application
         * @param {string} applicationId The unique identifier of the application.
         * @param {string} roleId The unique identifier of the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsApplicationIdRolesRoleIdDelete: async (applicationId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('apiApplicationsApplicationIdRolesRoleIdDelete', 'applicationId', applicationId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('apiApplicationsApplicationIdRolesRoleIdDelete', 'roleId', roleId)
            const localVarPath = `/api/applications/{applicationId}/roles/{roleId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get application level sign-in experience for a given application.   - Only branding properties and terms links customization is supported for now.    - Only third-party applications can have the sign-in experience customization for now.
         * @summary Get the application level sign-in experience
         * @param {string} applicationId The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsApplicationIdSignInExperienceGet: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('apiApplicationsApplicationIdSignInExperienceGet', 'applicationId', applicationId)
            const localVarPath = `/api/applications/{applicationId}/sign-in-experience`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update application level sign-in experience for the specified application. Create a new sign-in experience if it does not exist.   - Only branding properties and terms links customization is supported for now.    - Only third-party applications can be customized for now.    - Application level sign-in experience customization is optional, if provided, it will override the default branding and terms links.
         * @summary Update application level sign-in experience
         * @param {string} applicationId The unique identifier of the application.
         * @param {ApiApplicationsApplicationIdSignInExperiencePutRequest} apiApplicationsApplicationIdSignInExperiencePutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsApplicationIdSignInExperiencePut: async (applicationId: string, apiApplicationsApplicationIdSignInExperiencePutRequest: ApiApplicationsApplicationIdSignInExperiencePutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('apiApplicationsApplicationIdSignInExperiencePut', 'applicationId', applicationId)
            // verify required parameter 'apiApplicationsApplicationIdSignInExperiencePutRequest' is not null or undefined
            assertParamExists('apiApplicationsApplicationIdSignInExperiencePut', 'apiApplicationsApplicationIdSignInExperiencePutRequest', apiApplicationsApplicationIdSignInExperiencePutRequest)
            const localVarPath = `/api/applications/{applicationId}/sign-in-experience`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiApplicationsApplicationIdSignInExperiencePutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all the user consent scopes of an application by application id
         * @summary List all the user consent scopes of an application.
         * @param {string} applicationId The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsApplicationIdUserConsentScopesGet: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('apiApplicationsApplicationIdUserConsentScopesGet', 'applicationId', applicationId)
            const localVarPath = `/api/applications/{applicationId}/user-consent-scopes`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign the user consent scopes to an application by application id
         * @summary Assign user consent scopes to application.
         * @param {string} applicationId The unique identifier of the application.
         * @param {ApiApplicationsApplicationIdUserConsentScopesPostRequest} apiApplicationsApplicationIdUserConsentScopesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsApplicationIdUserConsentScopesPost: async (applicationId: string, apiApplicationsApplicationIdUserConsentScopesPostRequest: ApiApplicationsApplicationIdUserConsentScopesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('apiApplicationsApplicationIdUserConsentScopesPost', 'applicationId', applicationId)
            // verify required parameter 'apiApplicationsApplicationIdUserConsentScopesPostRequest' is not null or undefined
            assertParamExists('apiApplicationsApplicationIdUserConsentScopesPost', 'apiApplicationsApplicationIdUserConsentScopesPostRequest', apiApplicationsApplicationIdUserConsentScopesPostRequest)
            const localVarPath = `/api/applications/{applicationId}/user-consent-scopes`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiApplicationsApplicationIdUserConsentScopesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove the user consent scope from an application by application id, scope type and scope id
         * @summary Remove user consent scope from application.
         * @param {string} applicationId The unique identifier of the application.
         * @param {ApiApplicationsApplicationIdUserConsentScopesScopeTypeScopeIdDeleteScopeTypeEnum} scopeType 
         * @param {string} scopeId The unique identifier of the scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsApplicationIdUserConsentScopesScopeTypeScopeIdDelete: async (applicationId: string, scopeType: ApiApplicationsApplicationIdUserConsentScopesScopeTypeScopeIdDeleteScopeTypeEnum, scopeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('apiApplicationsApplicationIdUserConsentScopesScopeTypeScopeIdDelete', 'applicationId', applicationId)
            // verify required parameter 'scopeType' is not null or undefined
            assertParamExists('apiApplicationsApplicationIdUserConsentScopesScopeTypeScopeIdDelete', 'scopeType', scopeType)
            // verify required parameter 'scopeId' is not null or undefined
            assertParamExists('apiApplicationsApplicationIdUserConsentScopesScopeTypeScopeIdDelete', 'scopeId', scopeId)
            const localVarPath = `/api/applications/{applicationId}/user-consent-scopes/{scopeType}/{scopeId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"scopeType"}}`, encodeURIComponent(String(scopeType)))
                .replace(`{${"scopeId"}}`, encodeURIComponent(String(scopeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get applications that match the given query with pagination.
         * @summary Get applications
         * @param {ApiApplicationsGetTypesParameter} [types] An array of application types to filter applications.
         * @param {string} [excludeRoleId] 
         * @param {ApiApplicationsGetIsThirdPartyParameter} [isThirdParty] 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsGet: async (types?: ApiApplicationsGetTypesParameter, excludeRoleId?: string, isThirdParty?: ApiApplicationsGetIsThirdPartyParameter, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (types !== undefined) {
                for (const [key, value] of Object.entries(types)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (excludeRoleId !== undefined) {
                localVarQueryParameter['excludeRoleId'] = excludeRoleId;
            }

            if (isThirdParty !== undefined) {
                for (const [key, value] of Object.entries(isThirdParty)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete application by ID.
         * @summary Delete application
         * @param {string} id The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiApplicationsIdDelete', 'id', id)
            const localVarPath = `/api/applications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get application details by ID.
         * @summary Get application
         * @param {string} id The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiApplicationsIdGet', 'id', id)
            const localVarPath = `/api/applications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update application details by ID with the given data.
         * @summary Update application
         * @param {string} id The unique identifier of the application.
         * @param {ApiApplicationsIdPatchRequest} apiApplicationsIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsIdPatch: async (id: string, apiApplicationsIdPatchRequest: ApiApplicationsIdPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiApplicationsIdPatch', 'id', id)
            // verify required parameter 'apiApplicationsIdPatchRequest' is not null or undefined
            assertParamExists('apiApplicationsIdPatch', 'apiApplicationsIdPatchRequest', apiApplicationsIdPatchRequest)
            const localVarPath = `/api/applications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiApplicationsIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a custom domain. This feature is not available for open source version.
         * @summary Delete a custom domain.
         * @param {string} id The unique identifier of the application.
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsIdProtectedAppMetadataCustomDomainsDomainDelete: async (id: string, domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiApplicationsIdProtectedAppMetadataCustomDomainsDomainDelete', 'id', id)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('apiApplicationsIdProtectedAppMetadataCustomDomainsDomainDelete', 'domain', domain)
            const localVarPath = `/api/applications/{id}/protected-app-metadata/custom-domains/{domain}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the list of custom domains of the protected application. This feature is not available for open source version.
         * @summary Get the list of custom domains of the protected application.
         * @param {string} id The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsIdProtectedAppMetadataCustomDomainsGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiApplicationsIdProtectedAppMetadataCustomDomainsGet', 'id', id)
            const localVarPath = `/api/applications/{id}/protected-app-metadata/custom-domains`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a custom domain to the protected application. You\'ll need to setup DNS record later. This feature is not available for open source version.
         * @summary Add a custom domain to the protected application.
         * @param {string} id The unique identifier of the application.
         * @param {ApiApplicationsIdProtectedAppMetadataCustomDomainsPostRequest} apiApplicationsIdProtectedAppMetadataCustomDomainsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsIdProtectedAppMetadataCustomDomainsPost: async (id: string, apiApplicationsIdProtectedAppMetadataCustomDomainsPostRequest: ApiApplicationsIdProtectedAppMetadataCustomDomainsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiApplicationsIdProtectedAppMetadataCustomDomainsPost', 'id', id)
            // verify required parameter 'apiApplicationsIdProtectedAppMetadataCustomDomainsPostRequest' is not null or undefined
            assertParamExists('apiApplicationsIdProtectedAppMetadataCustomDomainsPost', 'apiApplicationsIdProtectedAppMetadataCustomDomainsPostRequest', apiApplicationsIdProtectedAppMetadataCustomDomainsPostRequest)
            const localVarPath = `/api/applications/{id}/protected-app-metadata/custom-domains`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiApplicationsIdProtectedAppMetadataCustomDomainsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all the user consented organizations for a application by application id and user id.
         * @summary List all the user consented organizations of a application.
         * @param {string} id The unique identifier of the application.
         * @param {string} userId The unique identifier of the user.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsIdUsersUserIdConsentOrganizationsGet: async (id: string, userId: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiApplicationsIdUsersUserIdConsentOrganizationsGet', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiApplicationsIdUsersUserIdConsentOrganizationsGet', 'userId', userId)
            const localVarPath = `/api/applications/{id}/users/{userId}/consent-organizations`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke a user\'s access to an organization for a application by application id, user id and organization id.
         * @summary Revoke a user\'s access to an organization for a application.
         * @param {string} id The unique identifier of the application.
         * @param {string} userId The unique identifier of the user.
         * @param {string} organizationId The unique identifier of the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsIdUsersUserIdConsentOrganizationsOrganizationIdDelete: async (id: string, userId: string, organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiApplicationsIdUsersUserIdConsentOrganizationsOrganizationIdDelete', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiApplicationsIdUsersUserIdConsentOrganizationsOrganizationIdDelete', 'userId', userId)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('apiApplicationsIdUsersUserIdConsentOrganizationsOrganizationIdDelete', 'organizationId', organizationId)
            const localVarPath = `/api/applications/{id}/users/{userId}/consent-organizations/{organizationId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Grant a list of organization access of a user for a application by application id and user id. <br/> The user must be a member of all the organizations. <br/> Only third-party application needs to be granted access to organizations, all the other applications can request for all the organizations\' access by default.
         * @summary Grant a list of organization access of a user for a application.
         * @param {string} id The unique identifier of the application.
         * @param {string} userId The unique identifier of the user.
         * @param {ApiApplicationsIdUsersUserIdConsentOrganizationsPostRequest} apiApplicationsIdUsersUserIdConsentOrganizationsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsIdUsersUserIdConsentOrganizationsPost: async (id: string, userId: string, apiApplicationsIdUsersUserIdConsentOrganizationsPostRequest: ApiApplicationsIdUsersUserIdConsentOrganizationsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiApplicationsIdUsersUserIdConsentOrganizationsPost', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiApplicationsIdUsersUserIdConsentOrganizationsPost', 'userId', userId)
            // verify required parameter 'apiApplicationsIdUsersUserIdConsentOrganizationsPostRequest' is not null or undefined
            assertParamExists('apiApplicationsIdUsersUserIdConsentOrganizationsPost', 'apiApplicationsIdUsersUserIdConsentOrganizationsPostRequest', apiApplicationsIdUsersUserIdConsentOrganizationsPostRequest)
            const localVarPath = `/api/applications/{id}/users/{userId}/consent-organizations`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiApplicationsIdUsersUserIdConsentOrganizationsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Grant a list of organization access of a user for a application by application id and user id. <br/> The user must be a member of all the organizations. <br/> Only third-party application needs to be granted access to organizations, all the other applications can request for all the organizations\' access by default.
         * @summary Grant a list of organization access of a user for a application.
         * @param {string} id The unique identifier of the application.
         * @param {string} userId The unique identifier of the user.
         * @param {ApiApplicationsIdUsersUserIdConsentOrganizationsPutRequest} apiApplicationsIdUsersUserIdConsentOrganizationsPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsIdUsersUserIdConsentOrganizationsPut: async (id: string, userId: string, apiApplicationsIdUsersUserIdConsentOrganizationsPutRequest: ApiApplicationsIdUsersUserIdConsentOrganizationsPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiApplicationsIdUsersUserIdConsentOrganizationsPut', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiApplicationsIdUsersUserIdConsentOrganizationsPut', 'userId', userId)
            // verify required parameter 'apiApplicationsIdUsersUserIdConsentOrganizationsPutRequest' is not null or undefined
            assertParamExists('apiApplicationsIdUsersUserIdConsentOrganizationsPut', 'apiApplicationsIdUsersUserIdConsentOrganizationsPutRequest', apiApplicationsIdUsersUserIdConsentOrganizationsPutRequest)
            const localVarPath = `/api/applications/{id}/users/{userId}/consent-organizations`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiApplicationsIdUsersUserIdConsentOrganizationsPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new application with the given data.
         * @summary Create an application
         * @param {ApiApplicationsPostRequest} apiApplicationsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsPost: async (apiApplicationsPostRequest: ApiApplicationsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiApplicationsPostRequest' is not null or undefined
            assertParamExists('apiApplicationsPost', 'apiApplicationsPostRequest', apiApplicationsPostRequest)
            const localVarPath = `/api/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiApplicationsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationsApi - functional programming interface
 * @export
 */
export const ApplicationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get API resource roles assigned to the specified application with pagination.
         * @summary Get application API resource roles
         * @param {string} applicationId The unique identifier of the application.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationsApplicationIdRolesGet(applicationId: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiApplicationsApplicationIdRolesGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApplicationsApplicationIdRolesGet(applicationId, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.apiApplicationsApplicationIdRolesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Assign API resource roles to the specified application. The API resource roles will be added to the existing API resource roles.
         * @summary Assign API resource roles to application
         * @param {string} applicationId The unique identifier of the application.
         * @param {ApiApplicationsApplicationIdRolesPostRequest} apiApplicationsApplicationIdRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationsApplicationIdRolesPost(applicationId: string, apiApplicationsApplicationIdRolesPostRequest: ApiApplicationsApplicationIdRolesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApplicationsApplicationIdRolesPost(applicationId, apiApplicationsApplicationIdRolesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.apiApplicationsApplicationIdRolesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update API resource roles assigned to the specified application. This will replace the existing API resource roles.
         * @summary Update API resource roles for application
         * @param {string} applicationId The unique identifier of the application.
         * @param {ApiApplicationsApplicationIdRolesPutRequest} apiApplicationsApplicationIdRolesPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationsApplicationIdRolesPut(applicationId: string, apiApplicationsApplicationIdRolesPutRequest: ApiApplicationsApplicationIdRolesPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApplicationsApplicationIdRolesPut(applicationId, apiApplicationsApplicationIdRolesPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.apiApplicationsApplicationIdRolesPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a API resource role from the specified application.
         * @summary Remove a API resource role from application
         * @param {string} applicationId The unique identifier of the application.
         * @param {string} roleId The unique identifier of the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationsApplicationIdRolesRoleIdDelete(applicationId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApplicationsApplicationIdRolesRoleIdDelete(applicationId, roleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.apiApplicationsApplicationIdRolesRoleIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get application level sign-in experience for a given application.   - Only branding properties and terms links customization is supported for now.    - Only third-party applications can have the sign-in experience customization for now.
         * @summary Get the application level sign-in experience
         * @param {string} applicationId The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationsApplicationIdSignInExperienceGet(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiApplicationsApplicationIdSignInExperienceGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApplicationsApplicationIdSignInExperienceGet(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.apiApplicationsApplicationIdSignInExperienceGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update application level sign-in experience for the specified application. Create a new sign-in experience if it does not exist.   - Only branding properties and terms links customization is supported for now.    - Only third-party applications can be customized for now.    - Application level sign-in experience customization is optional, if provided, it will override the default branding and terms links.
         * @summary Update application level sign-in experience
         * @param {string} applicationId The unique identifier of the application.
         * @param {ApiApplicationsApplicationIdSignInExperiencePutRequest} apiApplicationsApplicationIdSignInExperiencePutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationsApplicationIdSignInExperiencePut(applicationId: string, apiApplicationsApplicationIdSignInExperiencePutRequest: ApiApplicationsApplicationIdSignInExperiencePutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiApplicationsApplicationIdSignInExperienceGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApplicationsApplicationIdSignInExperiencePut(applicationId, apiApplicationsApplicationIdSignInExperiencePutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.apiApplicationsApplicationIdSignInExperiencePut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all the user consent scopes of an application by application id
         * @summary List all the user consent scopes of an application.
         * @param {string} applicationId The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationsApplicationIdUserConsentScopesGet(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiApplicationsApplicationIdUserConsentScopesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApplicationsApplicationIdUserConsentScopesGet(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.apiApplicationsApplicationIdUserConsentScopesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Assign the user consent scopes to an application by application id
         * @summary Assign user consent scopes to application.
         * @param {string} applicationId The unique identifier of the application.
         * @param {ApiApplicationsApplicationIdUserConsentScopesPostRequest} apiApplicationsApplicationIdUserConsentScopesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationsApplicationIdUserConsentScopesPost(applicationId: string, apiApplicationsApplicationIdUserConsentScopesPostRequest: ApiApplicationsApplicationIdUserConsentScopesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApplicationsApplicationIdUserConsentScopesPost(applicationId, apiApplicationsApplicationIdUserConsentScopesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.apiApplicationsApplicationIdUserConsentScopesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove the user consent scope from an application by application id, scope type and scope id
         * @summary Remove user consent scope from application.
         * @param {string} applicationId The unique identifier of the application.
         * @param {ApiApplicationsApplicationIdUserConsentScopesScopeTypeScopeIdDeleteScopeTypeEnum} scopeType 
         * @param {string} scopeId The unique identifier of the scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationsApplicationIdUserConsentScopesScopeTypeScopeIdDelete(applicationId: string, scopeType: ApiApplicationsApplicationIdUserConsentScopesScopeTypeScopeIdDeleteScopeTypeEnum, scopeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApplicationsApplicationIdUserConsentScopesScopeTypeScopeIdDelete(applicationId, scopeType, scopeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.apiApplicationsApplicationIdUserConsentScopesScopeTypeScopeIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get applications that match the given query with pagination.
         * @summary Get applications
         * @param {ApiApplicationsGetTypesParameter} [types] An array of application types to filter applications.
         * @param {string} [excludeRoleId] 
         * @param {ApiApplicationsGetIsThirdPartyParameter} [isThirdParty] 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationsGet(types?: ApiApplicationsGetTypesParameter, excludeRoleId?: string, isThirdParty?: ApiApplicationsGetIsThirdPartyParameter, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiApplicationsGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApplicationsGet(types, excludeRoleId, isThirdParty, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.apiApplicationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete application by ID.
         * @summary Delete application
         * @param {string} id The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApplicationsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.apiApplicationsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get application details by ID.
         * @summary Get application
         * @param {string} id The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiApplicationsIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApplicationsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.apiApplicationsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update application details by ID with the given data.
         * @summary Update application
         * @param {string} id The unique identifier of the application.
         * @param {ApiApplicationsIdPatchRequest} apiApplicationsIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationsIdPatch(id: string, apiApplicationsIdPatchRequest: ApiApplicationsIdPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiApplicationsGet200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApplicationsIdPatch(id, apiApplicationsIdPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.apiApplicationsIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a custom domain. This feature is not available for open source version.
         * @summary Delete a custom domain.
         * @param {string} id The unique identifier of the application.
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationsIdProtectedAppMetadataCustomDomainsDomainDelete(id: string, domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApplicationsIdProtectedAppMetadataCustomDomainsDomainDelete(id, domain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.apiApplicationsIdProtectedAppMetadataCustomDomainsDomainDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the list of custom domains of the protected application. This feature is not available for open source version.
         * @summary Get the list of custom domains of the protected application.
         * @param {string} id The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationsIdProtectedAppMetadataCustomDomainsGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApplicationsIdProtectedAppMetadataCustomDomainsGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.apiApplicationsIdProtectedAppMetadataCustomDomainsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a custom domain to the protected application. You\'ll need to setup DNS record later. This feature is not available for open source version.
         * @summary Add a custom domain to the protected application.
         * @param {string} id The unique identifier of the application.
         * @param {ApiApplicationsIdProtectedAppMetadataCustomDomainsPostRequest} apiApplicationsIdProtectedAppMetadataCustomDomainsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationsIdProtectedAppMetadataCustomDomainsPost(id: string, apiApplicationsIdProtectedAppMetadataCustomDomainsPostRequest: ApiApplicationsIdProtectedAppMetadataCustomDomainsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApplicationsIdProtectedAppMetadataCustomDomainsPost(id, apiApplicationsIdProtectedAppMetadataCustomDomainsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.apiApplicationsIdProtectedAppMetadataCustomDomainsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all the user consented organizations for a application by application id and user id.
         * @summary List all the user consented organizations of a application.
         * @param {string} id The unique identifier of the application.
         * @param {string} userId The unique identifier of the user.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationsIdUsersUserIdConsentOrganizationsGet(id: string, userId: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiApplicationsIdUsersUserIdConsentOrganizationsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApplicationsIdUsersUserIdConsentOrganizationsGet(id, userId, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.apiApplicationsIdUsersUserIdConsentOrganizationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revoke a user\'s access to an organization for a application by application id, user id and organization id.
         * @summary Revoke a user\'s access to an organization for a application.
         * @param {string} id The unique identifier of the application.
         * @param {string} userId The unique identifier of the user.
         * @param {string} organizationId The unique identifier of the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationsIdUsersUserIdConsentOrganizationsOrganizationIdDelete(id: string, userId: string, organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApplicationsIdUsersUserIdConsentOrganizationsOrganizationIdDelete(id, userId, organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.apiApplicationsIdUsersUserIdConsentOrganizationsOrganizationIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Grant a list of organization access of a user for a application by application id and user id. <br/> The user must be a member of all the organizations. <br/> Only third-party application needs to be granted access to organizations, all the other applications can request for all the organizations\' access by default.
         * @summary Grant a list of organization access of a user for a application.
         * @param {string} id The unique identifier of the application.
         * @param {string} userId The unique identifier of the user.
         * @param {ApiApplicationsIdUsersUserIdConsentOrganizationsPostRequest} apiApplicationsIdUsersUserIdConsentOrganizationsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationsIdUsersUserIdConsentOrganizationsPost(id: string, userId: string, apiApplicationsIdUsersUserIdConsentOrganizationsPostRequest: ApiApplicationsIdUsersUserIdConsentOrganizationsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApplicationsIdUsersUserIdConsentOrganizationsPost(id, userId, apiApplicationsIdUsersUserIdConsentOrganizationsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.apiApplicationsIdUsersUserIdConsentOrganizationsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Grant a list of organization access of a user for a application by application id and user id. <br/> The user must be a member of all the organizations. <br/> Only third-party application needs to be granted access to organizations, all the other applications can request for all the organizations\' access by default.
         * @summary Grant a list of organization access of a user for a application.
         * @param {string} id The unique identifier of the application.
         * @param {string} userId The unique identifier of the user.
         * @param {ApiApplicationsIdUsersUserIdConsentOrganizationsPutRequest} apiApplicationsIdUsersUserIdConsentOrganizationsPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationsIdUsersUserIdConsentOrganizationsPut(id: string, userId: string, apiApplicationsIdUsersUserIdConsentOrganizationsPutRequest: ApiApplicationsIdUsersUserIdConsentOrganizationsPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApplicationsIdUsersUserIdConsentOrganizationsPut(id, userId, apiApplicationsIdUsersUserIdConsentOrganizationsPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.apiApplicationsIdUsersUserIdConsentOrganizationsPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new application with the given data.
         * @summary Create an application
         * @param {ApiApplicationsPostRequest} apiApplicationsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationsPost(apiApplicationsPostRequest: ApiApplicationsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiApplicationsGet200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApplicationsPost(apiApplicationsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.apiApplicationsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApplicationsApi - factory interface
 * @export
 */
export const ApplicationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationsApiFp(configuration)
    return {
        /**
         * Get API resource roles assigned to the specified application with pagination.
         * @summary Get application API resource roles
         * @param {string} applicationId The unique identifier of the application.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsApplicationIdRolesGet(applicationId: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ApiApplicationsApplicationIdRolesGet200ResponseInner>> {
            return localVarFp.apiApplicationsApplicationIdRolesGet(applicationId, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign API resource roles to the specified application. The API resource roles will be added to the existing API resource roles.
         * @summary Assign API resource roles to application
         * @param {string} applicationId The unique identifier of the application.
         * @param {ApiApplicationsApplicationIdRolesPostRequest} apiApplicationsApplicationIdRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsApplicationIdRolesPost(applicationId: string, apiApplicationsApplicationIdRolesPostRequest: ApiApplicationsApplicationIdRolesPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiApplicationsApplicationIdRolesPost(applicationId, apiApplicationsApplicationIdRolesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update API resource roles assigned to the specified application. This will replace the existing API resource roles.
         * @summary Update API resource roles for application
         * @param {string} applicationId The unique identifier of the application.
         * @param {ApiApplicationsApplicationIdRolesPutRequest} apiApplicationsApplicationIdRolesPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsApplicationIdRolesPut(applicationId: string, apiApplicationsApplicationIdRolesPutRequest: ApiApplicationsApplicationIdRolesPutRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiApplicationsApplicationIdRolesPut(applicationId, apiApplicationsApplicationIdRolesPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a API resource role from the specified application.
         * @summary Remove a API resource role from application
         * @param {string} applicationId The unique identifier of the application.
         * @param {string} roleId The unique identifier of the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsApplicationIdRolesRoleIdDelete(applicationId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiApplicationsApplicationIdRolesRoleIdDelete(applicationId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get application level sign-in experience for a given application.   - Only branding properties and terms links customization is supported for now.    - Only third-party applications can have the sign-in experience customization for now.
         * @summary Get the application level sign-in experience
         * @param {string} applicationId The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsApplicationIdSignInExperienceGet(applicationId: string, options?: any): AxiosPromise<ApiApplicationsApplicationIdSignInExperienceGet200Response> {
            return localVarFp.apiApplicationsApplicationIdSignInExperienceGet(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update application level sign-in experience for the specified application. Create a new sign-in experience if it does not exist.   - Only branding properties and terms links customization is supported for now.    - Only third-party applications can be customized for now.    - Application level sign-in experience customization is optional, if provided, it will override the default branding and terms links.
         * @summary Update application level sign-in experience
         * @param {string} applicationId The unique identifier of the application.
         * @param {ApiApplicationsApplicationIdSignInExperiencePutRequest} apiApplicationsApplicationIdSignInExperiencePutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsApplicationIdSignInExperiencePut(applicationId: string, apiApplicationsApplicationIdSignInExperiencePutRequest: ApiApplicationsApplicationIdSignInExperiencePutRequest, options?: any): AxiosPromise<ApiApplicationsApplicationIdSignInExperienceGet200Response> {
            return localVarFp.apiApplicationsApplicationIdSignInExperiencePut(applicationId, apiApplicationsApplicationIdSignInExperiencePutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the user consent scopes of an application by application id
         * @summary List all the user consent scopes of an application.
         * @param {string} applicationId The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsApplicationIdUserConsentScopesGet(applicationId: string, options?: any): AxiosPromise<ApiApplicationsApplicationIdUserConsentScopesGet200Response> {
            return localVarFp.apiApplicationsApplicationIdUserConsentScopesGet(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign the user consent scopes to an application by application id
         * @summary Assign user consent scopes to application.
         * @param {string} applicationId The unique identifier of the application.
         * @param {ApiApplicationsApplicationIdUserConsentScopesPostRequest} apiApplicationsApplicationIdUserConsentScopesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsApplicationIdUserConsentScopesPost(applicationId: string, apiApplicationsApplicationIdUserConsentScopesPostRequest: ApiApplicationsApplicationIdUserConsentScopesPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiApplicationsApplicationIdUserConsentScopesPost(applicationId, apiApplicationsApplicationIdUserConsentScopesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove the user consent scope from an application by application id, scope type and scope id
         * @summary Remove user consent scope from application.
         * @param {string} applicationId The unique identifier of the application.
         * @param {ApiApplicationsApplicationIdUserConsentScopesScopeTypeScopeIdDeleteScopeTypeEnum} scopeType 
         * @param {string} scopeId The unique identifier of the scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsApplicationIdUserConsentScopesScopeTypeScopeIdDelete(applicationId: string, scopeType: ApiApplicationsApplicationIdUserConsentScopesScopeTypeScopeIdDeleteScopeTypeEnum, scopeId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiApplicationsApplicationIdUserConsentScopesScopeTypeScopeIdDelete(applicationId, scopeType, scopeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get applications that match the given query with pagination.
         * @summary Get applications
         * @param {ApiApplicationsGetTypesParameter} [types] An array of application types to filter applications.
         * @param {string} [excludeRoleId] 
         * @param {ApiApplicationsGetIsThirdPartyParameter} [isThirdParty] 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsGet(types?: ApiApplicationsGetTypesParameter, excludeRoleId?: string, isThirdParty?: ApiApplicationsGetIsThirdPartyParameter, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ApiApplicationsGet200ResponseInner>> {
            return localVarFp.apiApplicationsGet(types, excludeRoleId, isThirdParty, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete application by ID.
         * @summary Delete application
         * @param {string} id The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiApplicationsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get application details by ID.
         * @summary Get application
         * @param {string} id The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsIdGet(id: string, options?: any): AxiosPromise<ApiApplicationsIdGet200Response> {
            return localVarFp.apiApplicationsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update application details by ID with the given data.
         * @summary Update application
         * @param {string} id The unique identifier of the application.
         * @param {ApiApplicationsIdPatchRequest} apiApplicationsIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsIdPatch(id: string, apiApplicationsIdPatchRequest: ApiApplicationsIdPatchRequest, options?: any): AxiosPromise<ApiApplicationsGet200ResponseInner> {
            return localVarFp.apiApplicationsIdPatch(id, apiApplicationsIdPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a custom domain. This feature is not available for open source version.
         * @summary Delete a custom domain.
         * @param {string} id The unique identifier of the application.
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsIdProtectedAppMetadataCustomDomainsDomainDelete(id: string, domain: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiApplicationsIdProtectedAppMetadataCustomDomainsDomainDelete(id, domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the list of custom domains of the protected application. This feature is not available for open source version.
         * @summary Get the list of custom domains of the protected application.
         * @param {string} id The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsIdProtectedAppMetadataCustomDomainsGet(id: string, options?: any): AxiosPromise<Array<ApiApplicationsGet200ResponseInnerProtectedAppMetadataCustomDomainsInner>> {
            return localVarFp.apiApplicationsIdProtectedAppMetadataCustomDomainsGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a custom domain to the protected application. You\'ll need to setup DNS record later. This feature is not available for open source version.
         * @summary Add a custom domain to the protected application.
         * @param {string} id The unique identifier of the application.
         * @param {ApiApplicationsIdProtectedAppMetadataCustomDomainsPostRequest} apiApplicationsIdProtectedAppMetadataCustomDomainsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsIdProtectedAppMetadataCustomDomainsPost(id: string, apiApplicationsIdProtectedAppMetadataCustomDomainsPostRequest: ApiApplicationsIdProtectedAppMetadataCustomDomainsPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiApplicationsIdProtectedAppMetadataCustomDomainsPost(id, apiApplicationsIdProtectedAppMetadataCustomDomainsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the user consented organizations for a application by application id and user id.
         * @summary List all the user consented organizations of a application.
         * @param {string} id The unique identifier of the application.
         * @param {string} userId The unique identifier of the user.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsIdUsersUserIdConsentOrganizationsGet(id: string, userId: string, page?: number, pageSize?: number, options?: any): AxiosPromise<ApiApplicationsIdUsersUserIdConsentOrganizationsGet200Response> {
            return localVarFp.apiApplicationsIdUsersUserIdConsentOrganizationsGet(id, userId, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke a user\'s access to an organization for a application by application id, user id and organization id.
         * @summary Revoke a user\'s access to an organization for a application.
         * @param {string} id The unique identifier of the application.
         * @param {string} userId The unique identifier of the user.
         * @param {string} organizationId The unique identifier of the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsIdUsersUserIdConsentOrganizationsOrganizationIdDelete(id: string, userId: string, organizationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiApplicationsIdUsersUserIdConsentOrganizationsOrganizationIdDelete(id, userId, organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Grant a list of organization access of a user for a application by application id and user id. <br/> The user must be a member of all the organizations. <br/> Only third-party application needs to be granted access to organizations, all the other applications can request for all the organizations\' access by default.
         * @summary Grant a list of organization access of a user for a application.
         * @param {string} id The unique identifier of the application.
         * @param {string} userId The unique identifier of the user.
         * @param {ApiApplicationsIdUsersUserIdConsentOrganizationsPostRequest} apiApplicationsIdUsersUserIdConsentOrganizationsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsIdUsersUserIdConsentOrganizationsPost(id: string, userId: string, apiApplicationsIdUsersUserIdConsentOrganizationsPostRequest: ApiApplicationsIdUsersUserIdConsentOrganizationsPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiApplicationsIdUsersUserIdConsentOrganizationsPost(id, userId, apiApplicationsIdUsersUserIdConsentOrganizationsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Grant a list of organization access of a user for a application by application id and user id. <br/> The user must be a member of all the organizations. <br/> Only third-party application needs to be granted access to organizations, all the other applications can request for all the organizations\' access by default.
         * @summary Grant a list of organization access of a user for a application.
         * @param {string} id The unique identifier of the application.
         * @param {string} userId The unique identifier of the user.
         * @param {ApiApplicationsIdUsersUserIdConsentOrganizationsPutRequest} apiApplicationsIdUsersUserIdConsentOrganizationsPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsIdUsersUserIdConsentOrganizationsPut(id: string, userId: string, apiApplicationsIdUsersUserIdConsentOrganizationsPutRequest: ApiApplicationsIdUsersUserIdConsentOrganizationsPutRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiApplicationsIdUsersUserIdConsentOrganizationsPut(id, userId, apiApplicationsIdUsersUserIdConsentOrganizationsPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new application with the given data.
         * @summary Create an application
         * @param {ApiApplicationsPostRequest} apiApplicationsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationsPost(apiApplicationsPostRequest: ApiApplicationsPostRequest, options?: any): AxiosPromise<ApiApplicationsGet200ResponseInner> {
            return localVarFp.apiApplicationsPost(apiApplicationsPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationsApi - object-oriented interface
 * @export
 * @class ApplicationsApi
 * @extends {BaseAPI}
 */
export class ApplicationsApi extends BaseAPI {
    /**
     * Get API resource roles assigned to the specified application with pagination.
     * @summary Get application API resource roles
     * @param {string} applicationId The unique identifier of the application.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public apiApplicationsApplicationIdRolesGet(applicationId: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).apiApplicationsApplicationIdRolesGet(applicationId, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assign API resource roles to the specified application. The API resource roles will be added to the existing API resource roles.
     * @summary Assign API resource roles to application
     * @param {string} applicationId The unique identifier of the application.
     * @param {ApiApplicationsApplicationIdRolesPostRequest} apiApplicationsApplicationIdRolesPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public apiApplicationsApplicationIdRolesPost(applicationId: string, apiApplicationsApplicationIdRolesPostRequest: ApiApplicationsApplicationIdRolesPostRequest, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).apiApplicationsApplicationIdRolesPost(applicationId, apiApplicationsApplicationIdRolesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update API resource roles assigned to the specified application. This will replace the existing API resource roles.
     * @summary Update API resource roles for application
     * @param {string} applicationId The unique identifier of the application.
     * @param {ApiApplicationsApplicationIdRolesPutRequest} apiApplicationsApplicationIdRolesPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public apiApplicationsApplicationIdRolesPut(applicationId: string, apiApplicationsApplicationIdRolesPutRequest: ApiApplicationsApplicationIdRolesPutRequest, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).apiApplicationsApplicationIdRolesPut(applicationId, apiApplicationsApplicationIdRolesPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a API resource role from the specified application.
     * @summary Remove a API resource role from application
     * @param {string} applicationId The unique identifier of the application.
     * @param {string} roleId The unique identifier of the role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public apiApplicationsApplicationIdRolesRoleIdDelete(applicationId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).apiApplicationsApplicationIdRolesRoleIdDelete(applicationId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get application level sign-in experience for a given application.   - Only branding properties and terms links customization is supported for now.    - Only third-party applications can have the sign-in experience customization for now.
     * @summary Get the application level sign-in experience
     * @param {string} applicationId The unique identifier of the application.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public apiApplicationsApplicationIdSignInExperienceGet(applicationId: string, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).apiApplicationsApplicationIdSignInExperienceGet(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update application level sign-in experience for the specified application. Create a new sign-in experience if it does not exist.   - Only branding properties and terms links customization is supported for now.    - Only third-party applications can be customized for now.    - Application level sign-in experience customization is optional, if provided, it will override the default branding and terms links.
     * @summary Update application level sign-in experience
     * @param {string} applicationId The unique identifier of the application.
     * @param {ApiApplicationsApplicationIdSignInExperiencePutRequest} apiApplicationsApplicationIdSignInExperiencePutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public apiApplicationsApplicationIdSignInExperiencePut(applicationId: string, apiApplicationsApplicationIdSignInExperiencePutRequest: ApiApplicationsApplicationIdSignInExperiencePutRequest, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).apiApplicationsApplicationIdSignInExperiencePut(applicationId, apiApplicationsApplicationIdSignInExperiencePutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all the user consent scopes of an application by application id
     * @summary List all the user consent scopes of an application.
     * @param {string} applicationId The unique identifier of the application.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public apiApplicationsApplicationIdUserConsentScopesGet(applicationId: string, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).apiApplicationsApplicationIdUserConsentScopesGet(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assign the user consent scopes to an application by application id
     * @summary Assign user consent scopes to application.
     * @param {string} applicationId The unique identifier of the application.
     * @param {ApiApplicationsApplicationIdUserConsentScopesPostRequest} apiApplicationsApplicationIdUserConsentScopesPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public apiApplicationsApplicationIdUserConsentScopesPost(applicationId: string, apiApplicationsApplicationIdUserConsentScopesPostRequest: ApiApplicationsApplicationIdUserConsentScopesPostRequest, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).apiApplicationsApplicationIdUserConsentScopesPost(applicationId, apiApplicationsApplicationIdUserConsentScopesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove the user consent scope from an application by application id, scope type and scope id
     * @summary Remove user consent scope from application.
     * @param {string} applicationId The unique identifier of the application.
     * @param {ApiApplicationsApplicationIdUserConsentScopesScopeTypeScopeIdDeleteScopeTypeEnum} scopeType 
     * @param {string} scopeId The unique identifier of the scope.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public apiApplicationsApplicationIdUserConsentScopesScopeTypeScopeIdDelete(applicationId: string, scopeType: ApiApplicationsApplicationIdUserConsentScopesScopeTypeScopeIdDeleteScopeTypeEnum, scopeId: string, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).apiApplicationsApplicationIdUserConsentScopesScopeTypeScopeIdDelete(applicationId, scopeType, scopeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get applications that match the given query with pagination.
     * @summary Get applications
     * @param {ApiApplicationsGetTypesParameter} [types] An array of application types to filter applications.
     * @param {string} [excludeRoleId] 
     * @param {ApiApplicationsGetIsThirdPartyParameter} [isThirdParty] 
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public apiApplicationsGet(types?: ApiApplicationsGetTypesParameter, excludeRoleId?: string, isThirdParty?: ApiApplicationsGetIsThirdPartyParameter, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).apiApplicationsGet(types, excludeRoleId, isThirdParty, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete application by ID.
     * @summary Delete application
     * @param {string} id The unique identifier of the application.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public apiApplicationsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).apiApplicationsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get application details by ID.
     * @summary Get application
     * @param {string} id The unique identifier of the application.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public apiApplicationsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).apiApplicationsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update application details by ID with the given data.
     * @summary Update application
     * @param {string} id The unique identifier of the application.
     * @param {ApiApplicationsIdPatchRequest} apiApplicationsIdPatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public apiApplicationsIdPatch(id: string, apiApplicationsIdPatchRequest: ApiApplicationsIdPatchRequest, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).apiApplicationsIdPatch(id, apiApplicationsIdPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a custom domain. This feature is not available for open source version.
     * @summary Delete a custom domain.
     * @param {string} id The unique identifier of the application.
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public apiApplicationsIdProtectedAppMetadataCustomDomainsDomainDelete(id: string, domain: string, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).apiApplicationsIdProtectedAppMetadataCustomDomainsDomainDelete(id, domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the list of custom domains of the protected application. This feature is not available for open source version.
     * @summary Get the list of custom domains of the protected application.
     * @param {string} id The unique identifier of the application.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public apiApplicationsIdProtectedAppMetadataCustomDomainsGet(id: string, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).apiApplicationsIdProtectedAppMetadataCustomDomainsGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a custom domain to the protected application. You\'ll need to setup DNS record later. This feature is not available for open source version.
     * @summary Add a custom domain to the protected application.
     * @param {string} id The unique identifier of the application.
     * @param {ApiApplicationsIdProtectedAppMetadataCustomDomainsPostRequest} apiApplicationsIdProtectedAppMetadataCustomDomainsPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public apiApplicationsIdProtectedAppMetadataCustomDomainsPost(id: string, apiApplicationsIdProtectedAppMetadataCustomDomainsPostRequest: ApiApplicationsIdProtectedAppMetadataCustomDomainsPostRequest, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).apiApplicationsIdProtectedAppMetadataCustomDomainsPost(id, apiApplicationsIdProtectedAppMetadataCustomDomainsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all the user consented organizations for a application by application id and user id.
     * @summary List all the user consented organizations of a application.
     * @param {string} id The unique identifier of the application.
     * @param {string} userId The unique identifier of the user.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public apiApplicationsIdUsersUserIdConsentOrganizationsGet(id: string, userId: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).apiApplicationsIdUsersUserIdConsentOrganizationsGet(id, userId, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke a user\'s access to an organization for a application by application id, user id and organization id.
     * @summary Revoke a user\'s access to an organization for a application.
     * @param {string} id The unique identifier of the application.
     * @param {string} userId The unique identifier of the user.
     * @param {string} organizationId The unique identifier of the organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public apiApplicationsIdUsersUserIdConsentOrganizationsOrganizationIdDelete(id: string, userId: string, organizationId: string, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).apiApplicationsIdUsersUserIdConsentOrganizationsOrganizationIdDelete(id, userId, organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Grant a list of organization access of a user for a application by application id and user id. <br/> The user must be a member of all the organizations. <br/> Only third-party application needs to be granted access to organizations, all the other applications can request for all the organizations\' access by default.
     * @summary Grant a list of organization access of a user for a application.
     * @param {string} id The unique identifier of the application.
     * @param {string} userId The unique identifier of the user.
     * @param {ApiApplicationsIdUsersUserIdConsentOrganizationsPostRequest} apiApplicationsIdUsersUserIdConsentOrganizationsPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public apiApplicationsIdUsersUserIdConsentOrganizationsPost(id: string, userId: string, apiApplicationsIdUsersUserIdConsentOrganizationsPostRequest: ApiApplicationsIdUsersUserIdConsentOrganizationsPostRequest, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).apiApplicationsIdUsersUserIdConsentOrganizationsPost(id, userId, apiApplicationsIdUsersUserIdConsentOrganizationsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Grant a list of organization access of a user for a application by application id and user id. <br/> The user must be a member of all the organizations. <br/> Only third-party application needs to be granted access to organizations, all the other applications can request for all the organizations\' access by default.
     * @summary Grant a list of organization access of a user for a application.
     * @param {string} id The unique identifier of the application.
     * @param {string} userId The unique identifier of the user.
     * @param {ApiApplicationsIdUsersUserIdConsentOrganizationsPutRequest} apiApplicationsIdUsersUserIdConsentOrganizationsPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public apiApplicationsIdUsersUserIdConsentOrganizationsPut(id: string, userId: string, apiApplicationsIdUsersUserIdConsentOrganizationsPutRequest: ApiApplicationsIdUsersUserIdConsentOrganizationsPutRequest, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).apiApplicationsIdUsersUserIdConsentOrganizationsPut(id, userId, apiApplicationsIdUsersUserIdConsentOrganizationsPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new application with the given data.
     * @summary Create an application
     * @param {ApiApplicationsPostRequest} apiApplicationsPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public apiApplicationsPost(apiApplicationsPostRequest: ApiApplicationsPostRequest, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).apiApplicationsPost(apiApplicationsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ApiApplicationsApplicationIdUserConsentScopesScopeTypeScopeIdDeleteScopeTypeEnum = {
    OrganizationScopes: 'organization-scopes',
    ResourceScopes: 'resource-scopes',
    OrganizationResourceScopes: 'organization-resource-scopes',
    UserScopes: 'user-scopes'
} as const;
export type ApiApplicationsApplicationIdUserConsentScopesScopeTypeScopeIdDeleteScopeTypeEnum = typeof ApiApplicationsApplicationIdUserConsentScopesScopeTypeScopeIdDeleteScopeTypeEnum[keyof typeof ApiApplicationsApplicationIdUserConsentScopesScopeTypeScopeIdDeleteScopeTypeEnum];


/**
 * AuditLogsApi - axios parameter creator
 * @export
 */
export const AuditLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get logs that match the given query with pagination.
         * @summary Get logs
         * @param {string} [userId] Filter logs by user ID.
         * @param {string} [applicationId] Filter logs by application ID.
         * @param {string} [logKey] Filter logs by log key.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLogsGet: async (userId?: string, applicationId?: string, logKey?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (logKey !== undefined) {
                localVarQueryParameter['logKey'] = logKey;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get log details by ID.
         * @summary Get log
         * @param {string} id The unique identifier of the log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLogsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiLogsIdGet', 'id', id)
            const localVarPath = `/api/logs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuditLogsApi - functional programming interface
 * @export
 */
export const AuditLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuditLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get logs that match the given query with pagination.
         * @summary Get logs
         * @param {string} [userId] Filter logs by user ID.
         * @param {string} [applicationId] Filter logs by application ID.
         * @param {string} [logKey] Filter logs by log key.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiLogsGet(userId?: string, applicationId?: string, logKey?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiLogsGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiLogsGet(userId, applicationId, logKey, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuditLogsApi.apiLogsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get log details by ID.
         * @summary Get log
         * @param {string} id The unique identifier of the log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiLogsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiLogsGet200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiLogsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuditLogsApi.apiLogsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuditLogsApi - factory interface
 * @export
 */
export const AuditLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuditLogsApiFp(configuration)
    return {
        /**
         * Get logs that match the given query with pagination.
         * @summary Get logs
         * @param {string} [userId] Filter logs by user ID.
         * @param {string} [applicationId] Filter logs by application ID.
         * @param {string} [logKey] Filter logs by log key.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLogsGet(userId?: string, applicationId?: string, logKey?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ApiLogsGet200ResponseInner>> {
            return localVarFp.apiLogsGet(userId, applicationId, logKey, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get log details by ID.
         * @summary Get log
         * @param {string} id The unique identifier of the log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiLogsIdGet(id: string, options?: any): AxiosPromise<ApiLogsGet200ResponseInner> {
            return localVarFp.apiLogsIdGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuditLogsApi - object-oriented interface
 * @export
 * @class AuditLogsApi
 * @extends {BaseAPI}
 */
export class AuditLogsApi extends BaseAPI {
    /**
     * Get logs that match the given query with pagination.
     * @summary Get logs
     * @param {string} [userId] Filter logs by user ID.
     * @param {string} [applicationId] Filter logs by application ID.
     * @param {string} [logKey] Filter logs by log key.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogsApi
     */
    public apiLogsGet(userId?: string, applicationId?: string, logKey?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return AuditLogsApiFp(this.configuration).apiLogsGet(userId, applicationId, logKey, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get log details by ID.
     * @summary Get log
     * @param {string} id The unique identifier of the log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogsApi
     */
    public apiLogsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return AuditLogsApiFp(this.configuration).apiLogsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthnApi - axios parameter creator
 * @export
 */
export const AuthnApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The `HASURA_GRAPHQL_AUTH_HOOK` endpoint for Hasura auth. Use this endpoint to integrate Hasura\'s [webhook authentication flow](https://hasura.io/docs/latest/auth/authentication/webhook/).
         * @summary Hasura auth hook endpoint
         * @param {string} resource 
         * @param {string} [unauthorizedRole] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthnHasuraGet: async (resource: string, unauthorizedRole?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resource' is not null or undefined
            assertParamExists('apiAuthnHasuraGet', 'resource', resource)
            const localVarPath = `/api/authn/hasura`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (resource !== undefined) {
                localVarQueryParameter['resource'] = resource;
            }

            if (unauthorizedRole !== undefined) {
                localVarQueryParameter['unauthorizedRole'] = unauthorizedRole;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Assertion Consumer Service (ACS) endpoint for Simple Assertion Markup Language (SAML) social connectors.  SAML social connectors are deprecated. Use the SSO SAML connector instead.
         * @summary SAML ACS endpoint (social)
         * @param {string} connectorId The unique identifier of the connector.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        apiAuthnSamlConnectorIdPost: async (connectorId: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('apiAuthnSamlConnectorIdPost', 'connectorId', connectorId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('apiAuthnSamlConnectorIdPost', 'body', body)
            const localVarPath = `/api/authn/saml/{connectorId}`
                .replace(`{${"connectorId"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Assertion Consumer Service (ACS) endpoint for Simple Assertion Markup Language (SAML) single sign-on (SSO) connectors.  This endpoint is used to complete the SAML SSO authentication flow. It receives the SAML assertion response from the identity provider (IdP) and redirects the user to complete the authentication flow.
         * @summary SAML ACS endpoint (SSO)
         * @param {string} connectorId The unique identifier of the connector.
         * @param {ApiAuthnSingleSignOnSamlConnectorIdPostRequest} apiAuthnSingleSignOnSamlConnectorIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthnSingleSignOnSamlConnectorIdPost: async (connectorId: string, apiAuthnSingleSignOnSamlConnectorIdPostRequest: ApiAuthnSingleSignOnSamlConnectorIdPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('apiAuthnSingleSignOnSamlConnectorIdPost', 'connectorId', connectorId)
            // verify required parameter 'apiAuthnSingleSignOnSamlConnectorIdPostRequest' is not null or undefined
            assertParamExists('apiAuthnSingleSignOnSamlConnectorIdPost', 'apiAuthnSingleSignOnSamlConnectorIdPostRequest', apiAuthnSingleSignOnSamlConnectorIdPostRequest)
            const localVarPath = `/api/authn/single-sign-on/saml/{connectorId}`
                .replace(`{${"connectorId"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiAuthnSingleSignOnSamlConnectorIdPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthnApi - functional programming interface
 * @export
 */
export const AuthnApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthnApiAxiosParamCreator(configuration)
    return {
        /**
         * The `HASURA_GRAPHQL_AUTH_HOOK` endpoint for Hasura auth. Use this endpoint to integrate Hasura\'s [webhook authentication flow](https://hasura.io/docs/latest/auth/authentication/webhook/).
         * @summary Hasura auth hook endpoint
         * @param {string} resource 
         * @param {string} [unauthorizedRole] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthnHasuraGet(resource: string, unauthorizedRole?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiAuthnHasuraGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthnHasuraGet(resource, unauthorizedRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthnApi.apiAuthnHasuraGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The Assertion Consumer Service (ACS) endpoint for Simple Assertion Markup Language (SAML) social connectors.  SAML social connectors are deprecated. Use the SSO SAML connector instead.
         * @summary SAML ACS endpoint (social)
         * @param {string} connectorId The unique identifier of the connector.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async apiAuthnSamlConnectorIdPost(connectorId: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthnSamlConnectorIdPost(connectorId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthnApi.apiAuthnSamlConnectorIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The Assertion Consumer Service (ACS) endpoint for Simple Assertion Markup Language (SAML) single sign-on (SSO) connectors.  This endpoint is used to complete the SAML SSO authentication flow. It receives the SAML assertion response from the identity provider (IdP) and redirects the user to complete the authentication flow.
         * @summary SAML ACS endpoint (SSO)
         * @param {string} connectorId The unique identifier of the connector.
         * @param {ApiAuthnSingleSignOnSamlConnectorIdPostRequest} apiAuthnSingleSignOnSamlConnectorIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthnSingleSignOnSamlConnectorIdPost(connectorId: string, apiAuthnSingleSignOnSamlConnectorIdPostRequest: ApiAuthnSingleSignOnSamlConnectorIdPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthnSingleSignOnSamlConnectorIdPost(connectorId, apiAuthnSingleSignOnSamlConnectorIdPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthnApi.apiAuthnSingleSignOnSamlConnectorIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthnApi - factory interface
 * @export
 */
export const AuthnApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthnApiFp(configuration)
    return {
        /**
         * The `HASURA_GRAPHQL_AUTH_HOOK` endpoint for Hasura auth. Use this endpoint to integrate Hasura\'s [webhook authentication flow](https://hasura.io/docs/latest/auth/authentication/webhook/).
         * @summary Hasura auth hook endpoint
         * @param {string} resource 
         * @param {string} [unauthorizedRole] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthnHasuraGet(resource: string, unauthorizedRole?: string, options?: any): AxiosPromise<ApiAuthnHasuraGet200Response> {
            return localVarFp.apiAuthnHasuraGet(resource, unauthorizedRole, options).then((request) => request(axios, basePath));
        },
        /**
         * The Assertion Consumer Service (ACS) endpoint for Simple Assertion Markup Language (SAML) social connectors.  SAML social connectors are deprecated. Use the SSO SAML connector instead.
         * @summary SAML ACS endpoint (social)
         * @param {string} connectorId The unique identifier of the connector.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        apiAuthnSamlConnectorIdPost(connectorId: string, body: object, options?: any): AxiosPromise<void> {
            return localVarFp.apiAuthnSamlConnectorIdPost(connectorId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * The Assertion Consumer Service (ACS) endpoint for Simple Assertion Markup Language (SAML) single sign-on (SSO) connectors.  This endpoint is used to complete the SAML SSO authentication flow. It receives the SAML assertion response from the identity provider (IdP) and redirects the user to complete the authentication flow.
         * @summary SAML ACS endpoint (SSO)
         * @param {string} connectorId The unique identifier of the connector.
         * @param {ApiAuthnSingleSignOnSamlConnectorIdPostRequest} apiAuthnSingleSignOnSamlConnectorIdPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthnSingleSignOnSamlConnectorIdPost(connectorId: string, apiAuthnSingleSignOnSamlConnectorIdPostRequest: ApiAuthnSingleSignOnSamlConnectorIdPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiAuthnSingleSignOnSamlConnectorIdPost(connectorId, apiAuthnSingleSignOnSamlConnectorIdPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthnApi - object-oriented interface
 * @export
 * @class AuthnApi
 * @extends {BaseAPI}
 */
export class AuthnApi extends BaseAPI {
    /**
     * The `HASURA_GRAPHQL_AUTH_HOOK` endpoint for Hasura auth. Use this endpoint to integrate Hasura\'s [webhook authentication flow](https://hasura.io/docs/latest/auth/authentication/webhook/).
     * @summary Hasura auth hook endpoint
     * @param {string} resource 
     * @param {string} [unauthorizedRole] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthnApi
     */
    public apiAuthnHasuraGet(resource: string, unauthorizedRole?: string, options?: RawAxiosRequestConfig) {
        return AuthnApiFp(this.configuration).apiAuthnHasuraGet(resource, unauthorizedRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The Assertion Consumer Service (ACS) endpoint for Simple Assertion Markup Language (SAML) social connectors.  SAML social connectors are deprecated. Use the SSO SAML connector instead.
     * @summary SAML ACS endpoint (social)
     * @param {string} connectorId The unique identifier of the connector.
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AuthnApi
     */
    public apiAuthnSamlConnectorIdPost(connectorId: string, body: object, options?: RawAxiosRequestConfig) {
        return AuthnApiFp(this.configuration).apiAuthnSamlConnectorIdPost(connectorId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The Assertion Consumer Service (ACS) endpoint for Simple Assertion Markup Language (SAML) single sign-on (SSO) connectors.  This endpoint is used to complete the SAML SSO authentication flow. It receives the SAML assertion response from the identity provider (IdP) and redirects the user to complete the authentication flow.
     * @summary SAML ACS endpoint (SSO)
     * @param {string} connectorId The unique identifier of the connector.
     * @param {ApiAuthnSingleSignOnSamlConnectorIdPostRequest} apiAuthnSingleSignOnSamlConnectorIdPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthnApi
     */
    public apiAuthnSingleSignOnSamlConnectorIdPost(connectorId: string, apiAuthnSingleSignOnSamlConnectorIdPostRequest: ApiAuthnSingleSignOnSamlConnectorIdPostRequest, options?: RawAxiosRequestConfig) {
        return AuthnApiFp(this.configuration).apiAuthnSingleSignOnSamlConnectorIdPost(connectorId, apiAuthnSingleSignOnSamlConnectorIdPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConfigsApi - axios parameter creator
 * @export
 */
export const ConfigsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the global configuration object for Logto Console.
         * @summary Get admin console config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConfigsAdminConsoleGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/configs/admin-console`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the global configuration object for Logto Console. This method performs a partial update.
         * @summary Update admin console config
         * @param {ApiConfigsAdminConsolePatchRequest} apiConfigsAdminConsolePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConfigsAdminConsolePatch: async (apiConfigsAdminConsolePatchRequest: ApiConfigsAdminConsolePatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiConfigsAdminConsolePatchRequest' is not null or undefined
            assertParamExists('apiConfigsAdminConsolePatch', 'apiConfigsAdminConsolePatchRequest', apiConfigsAdminConsolePatchRequest)
            const localVarPath = `/api/configs/admin-console`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiConfigsAdminConsolePatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all JWT customizers for the tenant.
         * @summary Get all JWT customizers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConfigsJwtCustomizerGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/configs/jwt-customizer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test the JWT customizer script with the given sample context and sample token payload.
         * @summary Test JWT customizer
         * @param {ApiConfigsJwtCustomizerTestPostRequest} apiConfigsJwtCustomizerTestPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConfigsJwtCustomizerTestPost: async (apiConfigsJwtCustomizerTestPostRequest: ApiConfigsJwtCustomizerTestPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiConfigsJwtCustomizerTestPostRequest' is not null or undefined
            assertParamExists('apiConfigsJwtCustomizerTestPost', 'apiConfigsJwtCustomizerTestPostRequest', apiConfigsJwtCustomizerTestPostRequest)
            const localVarPath = `/api/configs/jwt-customizer/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiConfigsJwtCustomizerTestPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the JWT customizer for the given token type.
         * @summary Delete JWT customizer
         * @param {ApiConfigsJwtCustomizerTokenTypePathDeleteTokenTypePathEnum} tokenTypePath The token type path to delete the JWT customizer for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConfigsJwtCustomizerTokenTypePathDelete: async (tokenTypePath: ApiConfigsJwtCustomizerTokenTypePathDeleteTokenTypePathEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenTypePath' is not null or undefined
            assertParamExists('apiConfigsJwtCustomizerTokenTypePathDelete', 'tokenTypePath', tokenTypePath)
            const localVarPath = `/api/configs/jwt-customizer/{tokenTypePath}`
                .replace(`{${"tokenTypePath"}}`, encodeURIComponent(String(tokenTypePath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the JWT customizer for the given token type.
         * @summary Get JWT customizer
         * @param {ApiConfigsJwtCustomizerTokenTypePathGetTokenTypePathEnum} tokenTypePath The token type to get the JWT customizer for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConfigsJwtCustomizerTokenTypePathGet: async (tokenTypePath: ApiConfigsJwtCustomizerTokenTypePathGetTokenTypePathEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenTypePath' is not null or undefined
            assertParamExists('apiConfigsJwtCustomizerTokenTypePathGet', 'tokenTypePath', tokenTypePath)
            const localVarPath = `/api/configs/jwt-customizer/{tokenTypePath}`
                .replace(`{${"tokenTypePath"}}`, encodeURIComponent(String(tokenTypePath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the JWT customizer for the given token type.
         * @summary Update JWT customizer
         * @param {ApiConfigsJwtCustomizerTokenTypePathPatchTokenTypePathEnum} tokenTypePath The token type to update a JWT customizer for.
         * @param {ApiConfigsJwtCustomizerTokenTypePathPutRequest} apiConfigsJwtCustomizerTokenTypePathPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConfigsJwtCustomizerTokenTypePathPatch: async (tokenTypePath: ApiConfigsJwtCustomizerTokenTypePathPatchTokenTypePathEnum, apiConfigsJwtCustomizerTokenTypePathPutRequest: ApiConfigsJwtCustomizerTokenTypePathPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenTypePath' is not null or undefined
            assertParamExists('apiConfigsJwtCustomizerTokenTypePathPatch', 'tokenTypePath', tokenTypePath)
            // verify required parameter 'apiConfigsJwtCustomizerTokenTypePathPutRequest' is not null or undefined
            assertParamExists('apiConfigsJwtCustomizerTokenTypePathPatch', 'apiConfigsJwtCustomizerTokenTypePathPutRequest', apiConfigsJwtCustomizerTokenTypePathPutRequest)
            const localVarPath = `/api/configs/jwt-customizer/{tokenTypePath}`
                .replace(`{${"tokenTypePath"}}`, encodeURIComponent(String(tokenTypePath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiConfigsJwtCustomizerTokenTypePathPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update a JWT customizer for the given token type.
         * @summary Create or update JWT customizer
         * @param {ApiConfigsJwtCustomizerTokenTypePathPutTokenTypePathEnum} tokenTypePath The token type to create a JWT customizer for.
         * @param {ApiConfigsJwtCustomizerTokenTypePathPutRequest} apiConfigsJwtCustomizerTokenTypePathPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConfigsJwtCustomizerTokenTypePathPut: async (tokenTypePath: ApiConfigsJwtCustomizerTokenTypePathPutTokenTypePathEnum, apiConfigsJwtCustomizerTokenTypePathPutRequest: ApiConfigsJwtCustomizerTokenTypePathPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenTypePath' is not null or undefined
            assertParamExists('apiConfigsJwtCustomizerTokenTypePathPut', 'tokenTypePath', tokenTypePath)
            // verify required parameter 'apiConfigsJwtCustomizerTokenTypePathPutRequest' is not null or undefined
            assertParamExists('apiConfigsJwtCustomizerTokenTypePathPut', 'apiConfigsJwtCustomizerTokenTypePathPutRequest', apiConfigsJwtCustomizerTokenTypePathPutRequest)
            const localVarPath = `/api/configs/jwt-customizer/{tokenTypePath}`
                .replace(`{${"tokenTypePath"}}`, encodeURIComponent(String(tokenTypePath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiConfigsJwtCustomizerTokenTypePathPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get OIDC signing keys by key type. The actual key will be redacted from the result.
         * @summary Get OIDC keys
         * @param {ApiConfigsOidcKeyTypeGetKeyTypeEnum} keyType Private keys are used to sign OIDC JWTs. Cookie keys are used to sign OIDC cookies. For clients, they do not need to know private keys to verify OIDC JWTs; they can use public keys from the JWKS endpoint instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConfigsOidcKeyTypeGet: async (keyType: ApiConfigsOidcKeyTypeGetKeyTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyType' is not null or undefined
            assertParamExists('apiConfigsOidcKeyTypeGet', 'keyType', keyType)
            const localVarPath = `/api/configs/oidc/{keyType}`
                .replace(`{${"keyType"}}`, encodeURIComponent(String(keyType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an OIDC signing key by key type and key ID.
         * @summary Delete OIDC key
         * @param {ApiConfigsOidcKeyTypeKeyIdDeleteKeyTypeEnum} keyType Private keys are used to sign OIDC JWTs. Cookie keys are used to sign OIDC cookies. For clients, they do not need to know private keys to verify OIDC JWTs; they can use public keys from the JWKS endpoint instead.
         * @param {string} keyId The unique identifier of the key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConfigsOidcKeyTypeKeyIdDelete: async (keyType: ApiConfigsOidcKeyTypeKeyIdDeleteKeyTypeEnum, keyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyType' is not null or undefined
            assertParamExists('apiConfigsOidcKeyTypeKeyIdDelete', 'keyType', keyType)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('apiConfigsOidcKeyTypeKeyIdDelete', 'keyId', keyId)
            const localVarPath = `/api/configs/oidc/{keyType}/{keyId}`
                .replace(`{${"keyType"}}`, encodeURIComponent(String(keyType)))
                .replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A new key will be generated and prepend to the list of keys.  Only two recent keys will be kept. The oldest key will be automatically removed if there are more than two keys.
         * @summary Rotate OIDC keys
         * @param {ApiConfigsOidcKeyTypeRotatePostKeyTypeEnum} keyType Private keys are used to sign OIDC JWTs. Cookie keys are used to sign OIDC cookies. For clients, they do not need to know private keys to verify OIDC JWTs; they can use public keys from the JWKS endpoint instead.
         * @param {ApiConfigsOidcKeyTypeRotatePostRequest} apiConfigsOidcKeyTypeRotatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConfigsOidcKeyTypeRotatePost: async (keyType: ApiConfigsOidcKeyTypeRotatePostKeyTypeEnum, apiConfigsOidcKeyTypeRotatePostRequest: ApiConfigsOidcKeyTypeRotatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyType' is not null or undefined
            assertParamExists('apiConfigsOidcKeyTypeRotatePost', 'keyType', keyType)
            // verify required parameter 'apiConfigsOidcKeyTypeRotatePostRequest' is not null or undefined
            assertParamExists('apiConfigsOidcKeyTypeRotatePost', 'apiConfigsOidcKeyTypeRotatePostRequest', apiConfigsOidcKeyTypeRotatePostRequest)
            const localVarPath = `/api/configs/oidc/{keyType}/rotate`
                .replace(`{${"keyType"}}`, encodeURIComponent(String(keyType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiConfigsOidcKeyTypeRotatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigsApi - functional programming interface
 * @export
 */
export const ConfigsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConfigsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the global configuration object for Logto Console.
         * @summary Get admin console config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConfigsAdminConsoleGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiConfigsAdminConsoleGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConfigsAdminConsoleGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigsApi.apiConfigsAdminConsoleGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the global configuration object for Logto Console. This method performs a partial update.
         * @summary Update admin console config
         * @param {ApiConfigsAdminConsolePatchRequest} apiConfigsAdminConsolePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConfigsAdminConsolePatch(apiConfigsAdminConsolePatchRequest: ApiConfigsAdminConsolePatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiConfigsAdminConsoleGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConfigsAdminConsolePatch(apiConfigsAdminConsolePatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigsApi.apiConfigsAdminConsolePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all JWT customizers for the tenant.
         * @summary Get all JWT customizers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConfigsJwtCustomizerGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiConfigsJwtCustomizerGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConfigsJwtCustomizerGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigsApi.apiConfigsJwtCustomizerGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test the JWT customizer script with the given sample context and sample token payload.
         * @summary Test JWT customizer
         * @param {ApiConfigsJwtCustomizerTestPostRequest} apiConfigsJwtCustomizerTestPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConfigsJwtCustomizerTestPost(apiConfigsJwtCustomizerTestPostRequest: ApiConfigsJwtCustomizerTestPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConfigsJwtCustomizerTestPost(apiConfigsJwtCustomizerTestPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigsApi.apiConfigsJwtCustomizerTestPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the JWT customizer for the given token type.
         * @summary Delete JWT customizer
         * @param {ApiConfigsJwtCustomizerTokenTypePathDeleteTokenTypePathEnum} tokenTypePath The token type path to delete the JWT customizer for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConfigsJwtCustomizerTokenTypePathDelete(tokenTypePath: ApiConfigsJwtCustomizerTokenTypePathDeleteTokenTypePathEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConfigsJwtCustomizerTokenTypePathDelete(tokenTypePath, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigsApi.apiConfigsJwtCustomizerTokenTypePathDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the JWT customizer for the given token type.
         * @summary Get JWT customizer
         * @param {ApiConfigsJwtCustomizerTokenTypePathGetTokenTypePathEnum} tokenTypePath The token type to get the JWT customizer for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConfigsJwtCustomizerTokenTypePathGet(tokenTypePath: ApiConfigsJwtCustomizerTokenTypePathGetTokenTypePathEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiConfigsJwtCustomizerTokenTypePathGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConfigsJwtCustomizerTokenTypePathGet(tokenTypePath, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigsApi.apiConfigsJwtCustomizerTokenTypePathGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the JWT customizer for the given token type.
         * @summary Update JWT customizer
         * @param {ApiConfigsJwtCustomizerTokenTypePathPatchTokenTypePathEnum} tokenTypePath The token type to update a JWT customizer for.
         * @param {ApiConfigsJwtCustomizerTokenTypePathPutRequest} apiConfigsJwtCustomizerTokenTypePathPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConfigsJwtCustomizerTokenTypePathPatch(tokenTypePath: ApiConfigsJwtCustomizerTokenTypePathPatchTokenTypePathEnum, apiConfigsJwtCustomizerTokenTypePathPutRequest: ApiConfigsJwtCustomizerTokenTypePathPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiConfigsJwtCustomizerTokenTypePathGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConfigsJwtCustomizerTokenTypePathPatch(tokenTypePath, apiConfigsJwtCustomizerTokenTypePathPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigsApi.apiConfigsJwtCustomizerTokenTypePathPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or update a JWT customizer for the given token type.
         * @summary Create or update JWT customizer
         * @param {ApiConfigsJwtCustomizerTokenTypePathPutTokenTypePathEnum} tokenTypePath The token type to create a JWT customizer for.
         * @param {ApiConfigsJwtCustomizerTokenTypePathPutRequest} apiConfigsJwtCustomizerTokenTypePathPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConfigsJwtCustomizerTokenTypePathPut(tokenTypePath: ApiConfigsJwtCustomizerTokenTypePathPutTokenTypePathEnum, apiConfigsJwtCustomizerTokenTypePathPutRequest: ApiConfigsJwtCustomizerTokenTypePathPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiConfigsJwtCustomizerTokenTypePathGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConfigsJwtCustomizerTokenTypePathPut(tokenTypePath, apiConfigsJwtCustomizerTokenTypePathPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigsApi.apiConfigsJwtCustomizerTokenTypePathPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get OIDC signing keys by key type. The actual key will be redacted from the result.
         * @summary Get OIDC keys
         * @param {ApiConfigsOidcKeyTypeGetKeyTypeEnum} keyType Private keys are used to sign OIDC JWTs. Cookie keys are used to sign OIDC cookies. For clients, they do not need to know private keys to verify OIDC JWTs; they can use public keys from the JWKS endpoint instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConfigsOidcKeyTypeGet(keyType: ApiConfigsOidcKeyTypeGetKeyTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiConfigsOidcKeyTypeGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConfigsOidcKeyTypeGet(keyType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigsApi.apiConfigsOidcKeyTypeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an OIDC signing key by key type and key ID.
         * @summary Delete OIDC key
         * @param {ApiConfigsOidcKeyTypeKeyIdDeleteKeyTypeEnum} keyType Private keys are used to sign OIDC JWTs. Cookie keys are used to sign OIDC cookies. For clients, they do not need to know private keys to verify OIDC JWTs; they can use public keys from the JWKS endpoint instead.
         * @param {string} keyId The unique identifier of the key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConfigsOidcKeyTypeKeyIdDelete(keyType: ApiConfigsOidcKeyTypeKeyIdDeleteKeyTypeEnum, keyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConfigsOidcKeyTypeKeyIdDelete(keyType, keyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigsApi.apiConfigsOidcKeyTypeKeyIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A new key will be generated and prepend to the list of keys.  Only two recent keys will be kept. The oldest key will be automatically removed if there are more than two keys.
         * @summary Rotate OIDC keys
         * @param {ApiConfigsOidcKeyTypeRotatePostKeyTypeEnum} keyType Private keys are used to sign OIDC JWTs. Cookie keys are used to sign OIDC cookies. For clients, they do not need to know private keys to verify OIDC JWTs; they can use public keys from the JWKS endpoint instead.
         * @param {ApiConfigsOidcKeyTypeRotatePostRequest} apiConfigsOidcKeyTypeRotatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConfigsOidcKeyTypeRotatePost(keyType: ApiConfigsOidcKeyTypeRotatePostKeyTypeEnum, apiConfigsOidcKeyTypeRotatePostRequest: ApiConfigsOidcKeyTypeRotatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiConfigsOidcKeyTypeGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConfigsOidcKeyTypeRotatePost(keyType, apiConfigsOidcKeyTypeRotatePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigsApi.apiConfigsOidcKeyTypeRotatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConfigsApi - factory interface
 * @export
 */
export const ConfigsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConfigsApiFp(configuration)
    return {
        /**
         * Get the global configuration object for Logto Console.
         * @summary Get admin console config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConfigsAdminConsoleGet(options?: any): AxiosPromise<ApiConfigsAdminConsoleGet200Response> {
            return localVarFp.apiConfigsAdminConsoleGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Update the global configuration object for Logto Console. This method performs a partial update.
         * @summary Update admin console config
         * @param {ApiConfigsAdminConsolePatchRequest} apiConfigsAdminConsolePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConfigsAdminConsolePatch(apiConfigsAdminConsolePatchRequest: ApiConfigsAdminConsolePatchRequest, options?: any): AxiosPromise<ApiConfigsAdminConsoleGet200Response> {
            return localVarFp.apiConfigsAdminConsolePatch(apiConfigsAdminConsolePatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all JWT customizers for the tenant.
         * @summary Get all JWT customizers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConfigsJwtCustomizerGet(options?: any): AxiosPromise<Array<ApiConfigsJwtCustomizerGet200ResponseInner>> {
            return localVarFp.apiConfigsJwtCustomizerGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Test the JWT customizer script with the given sample context and sample token payload.
         * @summary Test JWT customizer
         * @param {ApiConfigsJwtCustomizerTestPostRequest} apiConfigsJwtCustomizerTestPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConfigsJwtCustomizerTestPost(apiConfigsJwtCustomizerTestPostRequest: ApiConfigsJwtCustomizerTestPostRequest, options?: any): AxiosPromise<object> {
            return localVarFp.apiConfigsJwtCustomizerTestPost(apiConfigsJwtCustomizerTestPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the JWT customizer for the given token type.
         * @summary Delete JWT customizer
         * @param {ApiConfigsJwtCustomizerTokenTypePathDeleteTokenTypePathEnum} tokenTypePath The token type path to delete the JWT customizer for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConfigsJwtCustomizerTokenTypePathDelete(tokenTypePath: ApiConfigsJwtCustomizerTokenTypePathDeleteTokenTypePathEnum, options?: any): AxiosPromise<void> {
            return localVarFp.apiConfigsJwtCustomizerTokenTypePathDelete(tokenTypePath, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the JWT customizer for the given token type.
         * @summary Get JWT customizer
         * @param {ApiConfigsJwtCustomizerTokenTypePathGetTokenTypePathEnum} tokenTypePath The token type to get the JWT customizer for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConfigsJwtCustomizerTokenTypePathGet(tokenTypePath: ApiConfigsJwtCustomizerTokenTypePathGetTokenTypePathEnum, options?: any): AxiosPromise<ApiConfigsJwtCustomizerTokenTypePathGet200Response> {
            return localVarFp.apiConfigsJwtCustomizerTokenTypePathGet(tokenTypePath, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the JWT customizer for the given token type.
         * @summary Update JWT customizer
         * @param {ApiConfigsJwtCustomizerTokenTypePathPatchTokenTypePathEnum} tokenTypePath The token type to update a JWT customizer for.
         * @param {ApiConfigsJwtCustomizerTokenTypePathPutRequest} apiConfigsJwtCustomizerTokenTypePathPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConfigsJwtCustomizerTokenTypePathPatch(tokenTypePath: ApiConfigsJwtCustomizerTokenTypePathPatchTokenTypePathEnum, apiConfigsJwtCustomizerTokenTypePathPutRequest: ApiConfigsJwtCustomizerTokenTypePathPutRequest, options?: any): AxiosPromise<ApiConfigsJwtCustomizerTokenTypePathGet200Response> {
            return localVarFp.apiConfigsJwtCustomizerTokenTypePathPatch(tokenTypePath, apiConfigsJwtCustomizerTokenTypePathPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update a JWT customizer for the given token type.
         * @summary Create or update JWT customizer
         * @param {ApiConfigsJwtCustomizerTokenTypePathPutTokenTypePathEnum} tokenTypePath The token type to create a JWT customizer for.
         * @param {ApiConfigsJwtCustomizerTokenTypePathPutRequest} apiConfigsJwtCustomizerTokenTypePathPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConfigsJwtCustomizerTokenTypePathPut(tokenTypePath: ApiConfigsJwtCustomizerTokenTypePathPutTokenTypePathEnum, apiConfigsJwtCustomizerTokenTypePathPutRequest: ApiConfigsJwtCustomizerTokenTypePathPutRequest, options?: any): AxiosPromise<ApiConfigsJwtCustomizerTokenTypePathGet200Response> {
            return localVarFp.apiConfigsJwtCustomizerTokenTypePathPut(tokenTypePath, apiConfigsJwtCustomizerTokenTypePathPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get OIDC signing keys by key type. The actual key will be redacted from the result.
         * @summary Get OIDC keys
         * @param {ApiConfigsOidcKeyTypeGetKeyTypeEnum} keyType Private keys are used to sign OIDC JWTs. Cookie keys are used to sign OIDC cookies. For clients, they do not need to know private keys to verify OIDC JWTs; they can use public keys from the JWKS endpoint instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConfigsOidcKeyTypeGet(keyType: ApiConfigsOidcKeyTypeGetKeyTypeEnum, options?: any): AxiosPromise<Array<ApiConfigsOidcKeyTypeGet200ResponseInner>> {
            return localVarFp.apiConfigsOidcKeyTypeGet(keyType, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an OIDC signing key by key type and key ID.
         * @summary Delete OIDC key
         * @param {ApiConfigsOidcKeyTypeKeyIdDeleteKeyTypeEnum} keyType Private keys are used to sign OIDC JWTs. Cookie keys are used to sign OIDC cookies. For clients, they do not need to know private keys to verify OIDC JWTs; they can use public keys from the JWKS endpoint instead.
         * @param {string} keyId The unique identifier of the key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConfigsOidcKeyTypeKeyIdDelete(keyType: ApiConfigsOidcKeyTypeKeyIdDeleteKeyTypeEnum, keyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiConfigsOidcKeyTypeKeyIdDelete(keyType, keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * A new key will be generated and prepend to the list of keys.  Only two recent keys will be kept. The oldest key will be automatically removed if there are more than two keys.
         * @summary Rotate OIDC keys
         * @param {ApiConfigsOidcKeyTypeRotatePostKeyTypeEnum} keyType Private keys are used to sign OIDC JWTs. Cookie keys are used to sign OIDC cookies. For clients, they do not need to know private keys to verify OIDC JWTs; they can use public keys from the JWKS endpoint instead.
         * @param {ApiConfigsOidcKeyTypeRotatePostRequest} apiConfigsOidcKeyTypeRotatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConfigsOidcKeyTypeRotatePost(keyType: ApiConfigsOidcKeyTypeRotatePostKeyTypeEnum, apiConfigsOidcKeyTypeRotatePostRequest: ApiConfigsOidcKeyTypeRotatePostRequest, options?: any): AxiosPromise<Array<ApiConfigsOidcKeyTypeGet200ResponseInner>> {
            return localVarFp.apiConfigsOidcKeyTypeRotatePost(keyType, apiConfigsOidcKeyTypeRotatePostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConfigsApi - object-oriented interface
 * @export
 * @class ConfigsApi
 * @extends {BaseAPI}
 */
export class ConfigsApi extends BaseAPI {
    /**
     * Get the global configuration object for Logto Console.
     * @summary Get admin console config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public apiConfigsAdminConsoleGet(options?: RawAxiosRequestConfig) {
        return ConfigsApiFp(this.configuration).apiConfigsAdminConsoleGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the global configuration object for Logto Console. This method performs a partial update.
     * @summary Update admin console config
     * @param {ApiConfigsAdminConsolePatchRequest} apiConfigsAdminConsolePatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public apiConfigsAdminConsolePatch(apiConfigsAdminConsolePatchRequest: ApiConfigsAdminConsolePatchRequest, options?: RawAxiosRequestConfig) {
        return ConfigsApiFp(this.configuration).apiConfigsAdminConsolePatch(apiConfigsAdminConsolePatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all JWT customizers for the tenant.
     * @summary Get all JWT customizers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public apiConfigsJwtCustomizerGet(options?: RawAxiosRequestConfig) {
        return ConfigsApiFp(this.configuration).apiConfigsJwtCustomizerGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test the JWT customizer script with the given sample context and sample token payload.
     * @summary Test JWT customizer
     * @param {ApiConfigsJwtCustomizerTestPostRequest} apiConfigsJwtCustomizerTestPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public apiConfigsJwtCustomizerTestPost(apiConfigsJwtCustomizerTestPostRequest: ApiConfigsJwtCustomizerTestPostRequest, options?: RawAxiosRequestConfig) {
        return ConfigsApiFp(this.configuration).apiConfigsJwtCustomizerTestPost(apiConfigsJwtCustomizerTestPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the JWT customizer for the given token type.
     * @summary Delete JWT customizer
     * @param {ApiConfigsJwtCustomizerTokenTypePathDeleteTokenTypePathEnum} tokenTypePath The token type path to delete the JWT customizer for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public apiConfigsJwtCustomizerTokenTypePathDelete(tokenTypePath: ApiConfigsJwtCustomizerTokenTypePathDeleteTokenTypePathEnum, options?: RawAxiosRequestConfig) {
        return ConfigsApiFp(this.configuration).apiConfigsJwtCustomizerTokenTypePathDelete(tokenTypePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the JWT customizer for the given token type.
     * @summary Get JWT customizer
     * @param {ApiConfigsJwtCustomizerTokenTypePathGetTokenTypePathEnum} tokenTypePath The token type to get the JWT customizer for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public apiConfigsJwtCustomizerTokenTypePathGet(tokenTypePath: ApiConfigsJwtCustomizerTokenTypePathGetTokenTypePathEnum, options?: RawAxiosRequestConfig) {
        return ConfigsApiFp(this.configuration).apiConfigsJwtCustomizerTokenTypePathGet(tokenTypePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the JWT customizer for the given token type.
     * @summary Update JWT customizer
     * @param {ApiConfigsJwtCustomizerTokenTypePathPatchTokenTypePathEnum} tokenTypePath The token type to update a JWT customizer for.
     * @param {ApiConfigsJwtCustomizerTokenTypePathPutRequest} apiConfigsJwtCustomizerTokenTypePathPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public apiConfigsJwtCustomizerTokenTypePathPatch(tokenTypePath: ApiConfigsJwtCustomizerTokenTypePathPatchTokenTypePathEnum, apiConfigsJwtCustomizerTokenTypePathPutRequest: ApiConfigsJwtCustomizerTokenTypePathPutRequest, options?: RawAxiosRequestConfig) {
        return ConfigsApiFp(this.configuration).apiConfigsJwtCustomizerTokenTypePathPatch(tokenTypePath, apiConfigsJwtCustomizerTokenTypePathPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update a JWT customizer for the given token type.
     * @summary Create or update JWT customizer
     * @param {ApiConfigsJwtCustomizerTokenTypePathPutTokenTypePathEnum} tokenTypePath The token type to create a JWT customizer for.
     * @param {ApiConfigsJwtCustomizerTokenTypePathPutRequest} apiConfigsJwtCustomizerTokenTypePathPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public apiConfigsJwtCustomizerTokenTypePathPut(tokenTypePath: ApiConfigsJwtCustomizerTokenTypePathPutTokenTypePathEnum, apiConfigsJwtCustomizerTokenTypePathPutRequest: ApiConfigsJwtCustomizerTokenTypePathPutRequest, options?: RawAxiosRequestConfig) {
        return ConfigsApiFp(this.configuration).apiConfigsJwtCustomizerTokenTypePathPut(tokenTypePath, apiConfigsJwtCustomizerTokenTypePathPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get OIDC signing keys by key type. The actual key will be redacted from the result.
     * @summary Get OIDC keys
     * @param {ApiConfigsOidcKeyTypeGetKeyTypeEnum} keyType Private keys are used to sign OIDC JWTs. Cookie keys are used to sign OIDC cookies. For clients, they do not need to know private keys to verify OIDC JWTs; they can use public keys from the JWKS endpoint instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public apiConfigsOidcKeyTypeGet(keyType: ApiConfigsOidcKeyTypeGetKeyTypeEnum, options?: RawAxiosRequestConfig) {
        return ConfigsApiFp(this.configuration).apiConfigsOidcKeyTypeGet(keyType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an OIDC signing key by key type and key ID.
     * @summary Delete OIDC key
     * @param {ApiConfigsOidcKeyTypeKeyIdDeleteKeyTypeEnum} keyType Private keys are used to sign OIDC JWTs. Cookie keys are used to sign OIDC cookies. For clients, they do not need to know private keys to verify OIDC JWTs; they can use public keys from the JWKS endpoint instead.
     * @param {string} keyId The unique identifier of the key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public apiConfigsOidcKeyTypeKeyIdDelete(keyType: ApiConfigsOidcKeyTypeKeyIdDeleteKeyTypeEnum, keyId: string, options?: RawAxiosRequestConfig) {
        return ConfigsApiFp(this.configuration).apiConfigsOidcKeyTypeKeyIdDelete(keyType, keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A new key will be generated and prepend to the list of keys.  Only two recent keys will be kept. The oldest key will be automatically removed if there are more than two keys.
     * @summary Rotate OIDC keys
     * @param {ApiConfigsOidcKeyTypeRotatePostKeyTypeEnum} keyType Private keys are used to sign OIDC JWTs. Cookie keys are used to sign OIDC cookies. For clients, they do not need to know private keys to verify OIDC JWTs; they can use public keys from the JWKS endpoint instead.
     * @param {ApiConfigsOidcKeyTypeRotatePostRequest} apiConfigsOidcKeyTypeRotatePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public apiConfigsOidcKeyTypeRotatePost(keyType: ApiConfigsOidcKeyTypeRotatePostKeyTypeEnum, apiConfigsOidcKeyTypeRotatePostRequest: ApiConfigsOidcKeyTypeRotatePostRequest, options?: RawAxiosRequestConfig) {
        return ConfigsApiFp(this.configuration).apiConfigsOidcKeyTypeRotatePost(keyType, apiConfigsOidcKeyTypeRotatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ApiConfigsJwtCustomizerTokenTypePathDeleteTokenTypePathEnum = {
    AccessToken: 'access-token',
    ClientCredentials: 'client-credentials'
} as const;
export type ApiConfigsJwtCustomizerTokenTypePathDeleteTokenTypePathEnum = typeof ApiConfigsJwtCustomizerTokenTypePathDeleteTokenTypePathEnum[keyof typeof ApiConfigsJwtCustomizerTokenTypePathDeleteTokenTypePathEnum];
/**
 * @export
 */
export const ApiConfigsJwtCustomizerTokenTypePathGetTokenTypePathEnum = {
    AccessToken: 'access-token',
    ClientCredentials: 'client-credentials'
} as const;
export type ApiConfigsJwtCustomizerTokenTypePathGetTokenTypePathEnum = typeof ApiConfigsJwtCustomizerTokenTypePathGetTokenTypePathEnum[keyof typeof ApiConfigsJwtCustomizerTokenTypePathGetTokenTypePathEnum];
/**
 * @export
 */
export const ApiConfigsJwtCustomizerTokenTypePathPatchTokenTypePathEnum = {
    AccessToken: 'access-token',
    ClientCredentials: 'client-credentials'
} as const;
export type ApiConfigsJwtCustomizerTokenTypePathPatchTokenTypePathEnum = typeof ApiConfigsJwtCustomizerTokenTypePathPatchTokenTypePathEnum[keyof typeof ApiConfigsJwtCustomizerTokenTypePathPatchTokenTypePathEnum];
/**
 * @export
 */
export const ApiConfigsJwtCustomizerTokenTypePathPutTokenTypePathEnum = {
    AccessToken: 'access-token',
    ClientCredentials: 'client-credentials'
} as const;
export type ApiConfigsJwtCustomizerTokenTypePathPutTokenTypePathEnum = typeof ApiConfigsJwtCustomizerTokenTypePathPutTokenTypePathEnum[keyof typeof ApiConfigsJwtCustomizerTokenTypePathPutTokenTypePathEnum];
/**
 * @export
 */
export const ApiConfigsOidcKeyTypeGetKeyTypeEnum = {
    PrivateKeys: 'private-keys',
    CookieKeys: 'cookie-keys'
} as const;
export type ApiConfigsOidcKeyTypeGetKeyTypeEnum = typeof ApiConfigsOidcKeyTypeGetKeyTypeEnum[keyof typeof ApiConfigsOidcKeyTypeGetKeyTypeEnum];
/**
 * @export
 */
export const ApiConfigsOidcKeyTypeKeyIdDeleteKeyTypeEnum = {
    PrivateKeys: 'private-keys',
    CookieKeys: 'cookie-keys'
} as const;
export type ApiConfigsOidcKeyTypeKeyIdDeleteKeyTypeEnum = typeof ApiConfigsOidcKeyTypeKeyIdDeleteKeyTypeEnum[keyof typeof ApiConfigsOidcKeyTypeKeyIdDeleteKeyTypeEnum];
/**
 * @export
 */
export const ApiConfigsOidcKeyTypeRotatePostKeyTypeEnum = {
    PrivateKeys: 'private-keys',
    CookieKeys: 'cookie-keys'
} as const;
export type ApiConfigsOidcKeyTypeRotatePostKeyTypeEnum = typeof ApiConfigsOidcKeyTypeRotatePostKeyTypeEnum[keyof typeof ApiConfigsOidcKeyTypeRotatePostKeyTypeEnum];


/**
 * ConnectorFactoriesApi - axios parameter creator
 * @export
 */
export const ConnectorFactoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all connector factories data available in Logto.
         * @summary Get connector factories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorFactoriesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/connector-factories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get connector factory by the given ID.
         * @summary Get connector factory
         * @param {string} id The unique identifier of the connector factory.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorFactoriesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiConnectorFactoriesIdGet', 'id', id)
            const localVarPath = `/api/connector-factories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectorFactoriesApi - functional programming interface
 * @export
 */
export const ConnectorFactoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectorFactoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all connector factories data available in Logto.
         * @summary Get connector factories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConnectorFactoriesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiConnectorFactoriesGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConnectorFactoriesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorFactoriesApi.apiConnectorFactoriesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get connector factory by the given ID.
         * @summary Get connector factory
         * @param {string} id The unique identifier of the connector factory.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConnectorFactoriesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiConnectorFactoriesGet200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConnectorFactoriesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorFactoriesApi.apiConnectorFactoriesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConnectorFactoriesApi - factory interface
 * @export
 */
export const ConnectorFactoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectorFactoriesApiFp(configuration)
    return {
        /**
         * Get all connector factories data available in Logto.
         * @summary Get connector factories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorFactoriesGet(options?: any): AxiosPromise<Array<ApiConnectorFactoriesGet200ResponseInner>> {
            return localVarFp.apiConnectorFactoriesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get connector factory by the given ID.
         * @summary Get connector factory
         * @param {string} id The unique identifier of the connector factory.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorFactoriesIdGet(id: string, options?: any): AxiosPromise<ApiConnectorFactoriesGet200ResponseInner> {
            return localVarFp.apiConnectorFactoriesIdGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConnectorFactoriesApi - object-oriented interface
 * @export
 * @class ConnectorFactoriesApi
 * @extends {BaseAPI}
 */
export class ConnectorFactoriesApi extends BaseAPI {
    /**
     * Get all connector factories data available in Logto.
     * @summary Get connector factories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorFactoriesApi
     */
    public apiConnectorFactoriesGet(options?: RawAxiosRequestConfig) {
        return ConnectorFactoriesApiFp(this.configuration).apiConnectorFactoriesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get connector factory by the given ID.
     * @summary Get connector factory
     * @param {string} id The unique identifier of the connector factory.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorFactoriesApi
     */
    public apiConnectorFactoriesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return ConnectorFactoriesApiFp(this.configuration).apiConnectorFactoriesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConnectorsApi - axios parameter creator
 * @export
 */
export const ConnectorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get authorization URI for specified connector by providing redirect URI and randomly generated state.
         * @summary Get connector\'s authorization URI
         * @param {string} connectorId The unique identifier of the connector.
         * @param {ApiConnectorsConnectorIdAuthorizationUriPostRequest} apiConnectorsConnectorIdAuthorizationUriPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorsConnectorIdAuthorizationUriPost: async (connectorId: string, apiConnectorsConnectorIdAuthorizationUriPostRequest: ApiConnectorsConnectorIdAuthorizationUriPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('apiConnectorsConnectorIdAuthorizationUriPost', 'connectorId', connectorId)
            // verify required parameter 'apiConnectorsConnectorIdAuthorizationUriPostRequest' is not null or undefined
            assertParamExists('apiConnectorsConnectorIdAuthorizationUriPost', 'apiConnectorsConnectorIdAuthorizationUriPostRequest', apiConnectorsConnectorIdAuthorizationUriPostRequest)
            const localVarPath = `/api/connectors/{connectorId}/authorization-uri`
                .replace(`{${"connectorId"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiConnectorsConnectorIdAuthorizationUriPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test a passwordless (email or SMS) connector by sending a test message to the given phone number or email address.
         * @summary Test passwordless connector
         * @param {string} factoryId The unique identifier of the factory.
         * @param {ApiConnectorsFactoryIdTestPostRequest} apiConnectorsFactoryIdTestPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorsFactoryIdTestPost: async (factoryId: string, apiConnectorsFactoryIdTestPostRequest: ApiConnectorsFactoryIdTestPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'factoryId' is not null or undefined
            assertParamExists('apiConnectorsFactoryIdTestPost', 'factoryId', factoryId)
            // verify required parameter 'apiConnectorsFactoryIdTestPostRequest' is not null or undefined
            assertParamExists('apiConnectorsFactoryIdTestPost', 'apiConnectorsFactoryIdTestPostRequest', apiConnectorsFactoryIdTestPostRequest)
            const localVarPath = `/api/connectors/{factoryId}/test`
                .replace(`{${"factoryId"}}`, encodeURIComponent(String(factoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiConnectorsFactoryIdTestPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all connectors in the current tenant.
         * @summary Get connectors
         * @param {string} [target] Filter connectors by target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorsGet: async (target?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (target !== undefined) {
                localVarQueryParameter['target'] = target;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete connector by ID.
         * @summary Delete connector
         * @param {string} id The unique identifier of the connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiConnectorsIdDelete', 'id', id)
            const localVarPath = `/api/connectors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get connector data by ID
         * @summary Get connector
         * @param {string} id The unique identifier of the connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiConnectorsIdGet', 'id', id)
            const localVarPath = `/api/connectors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update connector by ID with the given data. This methods performs a partial update.
         * @summary Update connector
         * @param {string} id The unique identifier of the connector.
         * @param {ApiConnectorsIdPatchRequest} apiConnectorsIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorsIdPatch: async (id: string, apiConnectorsIdPatchRequest: ApiConnectorsIdPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiConnectorsIdPatch', 'id', id)
            // verify required parameter 'apiConnectorsIdPatchRequest' is not null or undefined
            assertParamExists('apiConnectorsIdPatch', 'apiConnectorsIdPatchRequest', apiConnectorsIdPatchRequest)
            const localVarPath = `/api/connectors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiConnectorsIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a connector with the given data.
         * @summary Create connector
         * @param {ApiConnectorsPostRequest} apiConnectorsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorsPost: async (apiConnectorsPostRequest: ApiConnectorsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiConnectorsPostRequest' is not null or undefined
            assertParamExists('apiConnectorsPost', 'apiConnectorsPostRequest', apiConnectorsPostRequest)
            const localVarPath = `/api/connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiConnectorsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectorsApi - functional programming interface
 * @export
 */
export const ConnectorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectorsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get authorization URI for specified connector by providing redirect URI and randomly generated state.
         * @summary Get connector\'s authorization URI
         * @param {string} connectorId The unique identifier of the connector.
         * @param {ApiConnectorsConnectorIdAuthorizationUriPostRequest} apiConnectorsConnectorIdAuthorizationUriPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConnectorsConnectorIdAuthorizationUriPost(connectorId: string, apiConnectorsConnectorIdAuthorizationUriPostRequest: ApiConnectorsConnectorIdAuthorizationUriPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiConnectorsConnectorIdAuthorizationUriPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConnectorsConnectorIdAuthorizationUriPost(connectorId, apiConnectorsConnectorIdAuthorizationUriPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.apiConnectorsConnectorIdAuthorizationUriPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test a passwordless (email or SMS) connector by sending a test message to the given phone number or email address.
         * @summary Test passwordless connector
         * @param {string} factoryId The unique identifier of the factory.
         * @param {ApiConnectorsFactoryIdTestPostRequest} apiConnectorsFactoryIdTestPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConnectorsFactoryIdTestPost(factoryId: string, apiConnectorsFactoryIdTestPostRequest: ApiConnectorsFactoryIdTestPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConnectorsFactoryIdTestPost(factoryId, apiConnectorsFactoryIdTestPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.apiConnectorsFactoryIdTestPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all connectors in the current tenant.
         * @summary Get connectors
         * @param {string} [target] Filter connectors by target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConnectorsGet(target?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiConnectorsGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConnectorsGet(target, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.apiConnectorsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete connector by ID.
         * @summary Delete connector
         * @param {string} id The unique identifier of the connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConnectorsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConnectorsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.apiConnectorsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get connector data by ID
         * @summary Get connector
         * @param {string} id The unique identifier of the connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConnectorsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiConnectorsGet200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConnectorsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.apiConnectorsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update connector by ID with the given data. This methods performs a partial update.
         * @summary Update connector
         * @param {string} id The unique identifier of the connector.
         * @param {ApiConnectorsIdPatchRequest} apiConnectorsIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConnectorsIdPatch(id: string, apiConnectorsIdPatchRequest: ApiConnectorsIdPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiConnectorsGet200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConnectorsIdPatch(id, apiConnectorsIdPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.apiConnectorsIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a connector with the given data.
         * @summary Create connector
         * @param {ApiConnectorsPostRequest} apiConnectorsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConnectorsPost(apiConnectorsPostRequest: ApiConnectorsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiConnectorsGet200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConnectorsPost(apiConnectorsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.apiConnectorsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConnectorsApi - factory interface
 * @export
 */
export const ConnectorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectorsApiFp(configuration)
    return {
        /**
         * Get authorization URI for specified connector by providing redirect URI and randomly generated state.
         * @summary Get connector\'s authorization URI
         * @param {string} connectorId The unique identifier of the connector.
         * @param {ApiConnectorsConnectorIdAuthorizationUriPostRequest} apiConnectorsConnectorIdAuthorizationUriPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorsConnectorIdAuthorizationUriPost(connectorId: string, apiConnectorsConnectorIdAuthorizationUriPostRequest: ApiConnectorsConnectorIdAuthorizationUriPostRequest, options?: any): AxiosPromise<ApiConnectorsConnectorIdAuthorizationUriPost200Response> {
            return localVarFp.apiConnectorsConnectorIdAuthorizationUriPost(connectorId, apiConnectorsConnectorIdAuthorizationUriPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Test a passwordless (email or SMS) connector by sending a test message to the given phone number or email address.
         * @summary Test passwordless connector
         * @param {string} factoryId The unique identifier of the factory.
         * @param {ApiConnectorsFactoryIdTestPostRequest} apiConnectorsFactoryIdTestPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorsFactoryIdTestPost(factoryId: string, apiConnectorsFactoryIdTestPostRequest: ApiConnectorsFactoryIdTestPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiConnectorsFactoryIdTestPost(factoryId, apiConnectorsFactoryIdTestPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all connectors in the current tenant.
         * @summary Get connectors
         * @param {string} [target] Filter connectors by target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorsGet(target?: string, options?: any): AxiosPromise<Array<ApiConnectorsGet200ResponseInner>> {
            return localVarFp.apiConnectorsGet(target, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete connector by ID.
         * @summary Delete connector
         * @param {string} id The unique identifier of the connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiConnectorsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get connector data by ID
         * @summary Get connector
         * @param {string} id The unique identifier of the connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorsIdGet(id: string, options?: any): AxiosPromise<ApiConnectorsGet200ResponseInner> {
            return localVarFp.apiConnectorsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update connector by ID with the given data. This methods performs a partial update.
         * @summary Update connector
         * @param {string} id The unique identifier of the connector.
         * @param {ApiConnectorsIdPatchRequest} apiConnectorsIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorsIdPatch(id: string, apiConnectorsIdPatchRequest: ApiConnectorsIdPatchRequest, options?: any): AxiosPromise<ApiConnectorsGet200ResponseInner> {
            return localVarFp.apiConnectorsIdPatch(id, apiConnectorsIdPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a connector with the given data.
         * @summary Create connector
         * @param {ApiConnectorsPostRequest} apiConnectorsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorsPost(apiConnectorsPostRequest: ApiConnectorsPostRequest, options?: any): AxiosPromise<ApiConnectorsGet200ResponseInner> {
            return localVarFp.apiConnectorsPost(apiConnectorsPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConnectorsApi - object-oriented interface
 * @export
 * @class ConnectorsApi
 * @extends {BaseAPI}
 */
export class ConnectorsApi extends BaseAPI {
    /**
     * Get authorization URI for specified connector by providing redirect URI and randomly generated state.
     * @summary Get connector\'s authorization URI
     * @param {string} connectorId The unique identifier of the connector.
     * @param {ApiConnectorsConnectorIdAuthorizationUriPostRequest} apiConnectorsConnectorIdAuthorizationUriPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public apiConnectorsConnectorIdAuthorizationUriPost(connectorId: string, apiConnectorsConnectorIdAuthorizationUriPostRequest: ApiConnectorsConnectorIdAuthorizationUriPostRequest, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).apiConnectorsConnectorIdAuthorizationUriPost(connectorId, apiConnectorsConnectorIdAuthorizationUriPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test a passwordless (email or SMS) connector by sending a test message to the given phone number or email address.
     * @summary Test passwordless connector
     * @param {string} factoryId The unique identifier of the factory.
     * @param {ApiConnectorsFactoryIdTestPostRequest} apiConnectorsFactoryIdTestPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public apiConnectorsFactoryIdTestPost(factoryId: string, apiConnectorsFactoryIdTestPostRequest: ApiConnectorsFactoryIdTestPostRequest, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).apiConnectorsFactoryIdTestPost(factoryId, apiConnectorsFactoryIdTestPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all connectors in the current tenant.
     * @summary Get connectors
     * @param {string} [target] Filter connectors by target.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public apiConnectorsGet(target?: string, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).apiConnectorsGet(target, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete connector by ID.
     * @summary Delete connector
     * @param {string} id The unique identifier of the connector.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public apiConnectorsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).apiConnectorsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get connector data by ID
     * @summary Get connector
     * @param {string} id The unique identifier of the connector.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public apiConnectorsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).apiConnectorsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update connector by ID with the given data. This methods performs a partial update.
     * @summary Update connector
     * @param {string} id The unique identifier of the connector.
     * @param {ApiConnectorsIdPatchRequest} apiConnectorsIdPatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public apiConnectorsIdPatch(id: string, apiConnectorsIdPatchRequest: ApiConnectorsIdPatchRequest, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).apiConnectorsIdPatch(id, apiConnectorsIdPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a connector with the given data.
     * @summary Create connector
     * @param {ApiConnectorsPostRequest} apiConnectorsPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public apiConnectorsPost(apiConnectorsPostRequest: ApiConnectorsPostRequest, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).apiConnectorsPost(apiConnectorsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CustomPhrasesApi - axios parameter creator
 * @export
 */
export const CustomPhrasesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all custom phrases for all languages.
         * @summary Get all custom phrases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomPhrasesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/custom-phrases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete custom phrases for the specified language tag.
         * @summary Delete custom phrase
         * @param {ApiCustomPhrasesLanguageTagDeleteLanguageTagEnum} languageTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomPhrasesLanguageTagDelete: async (languageTag: ApiCustomPhrasesLanguageTagDeleteLanguageTagEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'languageTag' is not null or undefined
            assertParamExists('apiCustomPhrasesLanguageTagDelete', 'languageTag', languageTag)
            const localVarPath = `/api/custom-phrases/{languageTag}`
                .replace(`{${"languageTag"}}`, encodeURIComponent(String(languageTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get custom phrases for the specified language tag.
         * @summary Get custom phrases
         * @param {ApiCustomPhrasesLanguageTagGetLanguageTagEnum} languageTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomPhrasesLanguageTagGet: async (languageTag: ApiCustomPhrasesLanguageTagGetLanguageTagEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'languageTag' is not null or undefined
            assertParamExists('apiCustomPhrasesLanguageTagGet', 'languageTag', languageTag)
            const localVarPath = `/api/custom-phrases/{languageTag}`
                .replace(`{${"languageTag"}}`, encodeURIComponent(String(languageTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upsert custom phrases for the specified language tag. Upsert means that if the custom phrases already exist, they will be updated. Otherwise, they will be created.
         * @summary Upsert custom phrases
         * @param {ApiCustomPhrasesLanguageTagPutLanguageTagEnum} languageTag 
         * @param {TranslationObject} translationObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomPhrasesLanguageTagPut: async (languageTag: ApiCustomPhrasesLanguageTagPutLanguageTagEnum, translationObject: TranslationObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'languageTag' is not null or undefined
            assertParamExists('apiCustomPhrasesLanguageTagPut', 'languageTag', languageTag)
            // verify required parameter 'translationObject' is not null or undefined
            assertParamExists('apiCustomPhrasesLanguageTagPut', 'translationObject', translationObject)
            const localVarPath = `/api/custom-phrases/{languageTag}`
                .replace(`{${"languageTag"}}`, encodeURIComponent(String(languageTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(translationObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomPhrasesApi - functional programming interface
 * @export
 */
export const CustomPhrasesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomPhrasesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all custom phrases for all languages.
         * @summary Get all custom phrases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCustomPhrasesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiCustomPhrasesGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCustomPhrasesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomPhrasesApi.apiCustomPhrasesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete custom phrases for the specified language tag.
         * @summary Delete custom phrase
         * @param {ApiCustomPhrasesLanguageTagDeleteLanguageTagEnum} languageTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCustomPhrasesLanguageTagDelete(languageTag: ApiCustomPhrasesLanguageTagDeleteLanguageTagEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCustomPhrasesLanguageTagDelete(languageTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomPhrasesApi.apiCustomPhrasesLanguageTagDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get custom phrases for the specified language tag.
         * @summary Get custom phrases
         * @param {ApiCustomPhrasesLanguageTagGetLanguageTagEnum} languageTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCustomPhrasesLanguageTagGet(languageTag: ApiCustomPhrasesLanguageTagGetLanguageTagEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiCustomPhrasesGet200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCustomPhrasesLanguageTagGet(languageTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomPhrasesApi.apiCustomPhrasesLanguageTagGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upsert custom phrases for the specified language tag. Upsert means that if the custom phrases already exist, they will be updated. Otherwise, they will be created.
         * @summary Upsert custom phrases
         * @param {ApiCustomPhrasesLanguageTagPutLanguageTagEnum} languageTag 
         * @param {TranslationObject} translationObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCustomPhrasesLanguageTagPut(languageTag: ApiCustomPhrasesLanguageTagPutLanguageTagEnum, translationObject: TranslationObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCustomPhrasesLanguageTagPut(languageTag, translationObject, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomPhrasesApi.apiCustomPhrasesLanguageTagPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CustomPhrasesApi - factory interface
 * @export
 */
export const CustomPhrasesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomPhrasesApiFp(configuration)
    return {
        /**
         * Get all custom phrases for all languages.
         * @summary Get all custom phrases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomPhrasesGet(options?: any): AxiosPromise<Array<ApiCustomPhrasesGet200ResponseInner>> {
            return localVarFp.apiCustomPhrasesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete custom phrases for the specified language tag.
         * @summary Delete custom phrase
         * @param {ApiCustomPhrasesLanguageTagDeleteLanguageTagEnum} languageTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomPhrasesLanguageTagDelete(languageTag: ApiCustomPhrasesLanguageTagDeleteLanguageTagEnum, options?: any): AxiosPromise<void> {
            return localVarFp.apiCustomPhrasesLanguageTagDelete(languageTag, options).then((request) => request(axios, basePath));
        },
        /**
         * Get custom phrases for the specified language tag.
         * @summary Get custom phrases
         * @param {ApiCustomPhrasesLanguageTagGetLanguageTagEnum} languageTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomPhrasesLanguageTagGet(languageTag: ApiCustomPhrasesLanguageTagGetLanguageTagEnum, options?: any): AxiosPromise<ApiCustomPhrasesGet200ResponseInner> {
            return localVarFp.apiCustomPhrasesLanguageTagGet(languageTag, options).then((request) => request(axios, basePath));
        },
        /**
         * Upsert custom phrases for the specified language tag. Upsert means that if the custom phrases already exist, they will be updated. Otherwise, they will be created.
         * @summary Upsert custom phrases
         * @param {ApiCustomPhrasesLanguageTagPutLanguageTagEnum} languageTag 
         * @param {TranslationObject} translationObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomPhrasesLanguageTagPut(languageTag: ApiCustomPhrasesLanguageTagPutLanguageTagEnum, translationObject: TranslationObject, options?: any): AxiosPromise<void> {
            return localVarFp.apiCustomPhrasesLanguageTagPut(languageTag, translationObject, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomPhrasesApi - object-oriented interface
 * @export
 * @class CustomPhrasesApi
 * @extends {BaseAPI}
 */
export class CustomPhrasesApi extends BaseAPI {
    /**
     * Get all custom phrases for all languages.
     * @summary Get all custom phrases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomPhrasesApi
     */
    public apiCustomPhrasesGet(options?: RawAxiosRequestConfig) {
        return CustomPhrasesApiFp(this.configuration).apiCustomPhrasesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete custom phrases for the specified language tag.
     * @summary Delete custom phrase
     * @param {ApiCustomPhrasesLanguageTagDeleteLanguageTagEnum} languageTag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomPhrasesApi
     */
    public apiCustomPhrasesLanguageTagDelete(languageTag: ApiCustomPhrasesLanguageTagDeleteLanguageTagEnum, options?: RawAxiosRequestConfig) {
        return CustomPhrasesApiFp(this.configuration).apiCustomPhrasesLanguageTagDelete(languageTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get custom phrases for the specified language tag.
     * @summary Get custom phrases
     * @param {ApiCustomPhrasesLanguageTagGetLanguageTagEnum} languageTag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomPhrasesApi
     */
    public apiCustomPhrasesLanguageTagGet(languageTag: ApiCustomPhrasesLanguageTagGetLanguageTagEnum, options?: RawAxiosRequestConfig) {
        return CustomPhrasesApiFp(this.configuration).apiCustomPhrasesLanguageTagGet(languageTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upsert custom phrases for the specified language tag. Upsert means that if the custom phrases already exist, they will be updated. Otherwise, they will be created.
     * @summary Upsert custom phrases
     * @param {ApiCustomPhrasesLanguageTagPutLanguageTagEnum} languageTag 
     * @param {TranslationObject} translationObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomPhrasesApi
     */
    public apiCustomPhrasesLanguageTagPut(languageTag: ApiCustomPhrasesLanguageTagPutLanguageTagEnum, translationObject: TranslationObject, options?: RawAxiosRequestConfig) {
        return CustomPhrasesApiFp(this.configuration).apiCustomPhrasesLanguageTagPut(languageTag, translationObject, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ApiCustomPhrasesLanguageTagDeleteLanguageTagEnum = {
    AfZa: 'af-ZA',
    AmEt: 'am-ET',
    ArAr: 'ar-AR',
    AsIn: 'as-IN',
    AzAz: 'az-AZ',
    BeBy: 'be-BY',
    BgBg: 'bg-BG',
    BnIn: 'bn-IN',
    BrFr: 'br-FR',
    BsBa: 'bs-BA',
    CaEs: 'ca-ES',
    CbIq: 'cb-IQ',
    CoFr: 'co-FR',
    CsCz: 'cs-CZ',
    CxPh: 'cx-PH',
    CyGb: 'cy-GB',
    DaDk: 'da-DK',
    De: 'de',
    DeDe: 'de-DE',
    ElGr: 'el-GR',
    En: 'en',
    EnGb: 'en-GB',
    EnUs: 'en-US',
    EoEo: 'eo-EO',
    Es: 'es',
    EsEs: 'es-ES',
    Es419: 'es-419',
    EtEe: 'et-EE',
    EuEs: 'eu-ES',
    FaIr: 'fa-IR',
    FfNg: 'ff-NG',
    FiFi: 'fi-FI',
    FoFo: 'fo-FO',
    Fr: 'fr',
    FrCa: 'fr-CA',
    FrFr: 'fr-FR',
    FyNl: 'fy-NL',
    GaIe: 'ga-IE',
    GlEs: 'gl-ES',
    GnPy: 'gn-PY',
    GuIn: 'gu-IN',
    HaNg: 'ha-NG',
    HeIl: 'he-IL',
    HiIn: 'hi-IN',
    HrHr: 'hr-HR',
    HtHt: 'ht-HT',
    HuHu: 'hu-HU',
    HyAm: 'hy-AM',
    IdId: 'id-ID',
    IkUs: 'ik-US',
    IsIs: 'is-IS',
    It: 'it',
    ItIt: 'it-IT',
    IuCa: 'iu-CA',
    Ja: 'ja',
    JaJp: 'ja-JP',
    JaKs: 'ja-KS',
    JvId: 'jv-ID',
    KaGe: 'ka-GE',
    KkKz: 'kk-KZ',
    KmKh: 'km-KH',
    KnIn: 'kn-IN',
    Ko: 'ko',
    KoKr: 'ko-KR',
    KuTr: 'ku-TR',
    KyKg: 'ky-KG',
    LoLa: 'lo-LA',
    LtLt: 'lt-LT',
    LvLv: 'lv-LV',
    MgMg: 'mg-MG',
    MkMk: 'mk-MK',
    MlIn: 'ml-IN',
    MnMn: 'mn-MN',
    MrIn: 'mr-IN',
    MsMy: 'ms-MY',
    MtMt: 'mt-MT',
    MyMm: 'my-MM',
    NbNo: 'nb-NO',
    NeNp: 'ne-NP',
    NlBe: 'nl-BE',
    NlNl: 'nl-NL',
    NnNo: 'nn-NO',
    OrIn: 'or-IN',
    PaIn: 'pa-IN',
    PlPl: 'pl-PL',
    PsAf: 'ps-AF',
    Pt: 'pt',
    PtBr: 'pt-BR',
    PtPt: 'pt-PT',
    RoRo: 'ro-RO',
    Ru: 'ru',
    RuRu: 'ru-RU',
    RwRw: 'rw-RW',
    ScIt: 'sc-IT',
    SiLk: 'si-LK',
    SkSk: 'sk-SK',
    SlSi: 'sl-SI',
    SnZw: 'sn-ZW',
    SqAl: 'sq-AL',
    SrRs: 'sr-RS',
    SvSe: 'sv-SE',
    SwKe: 'sw-KE',
    SySy: 'sy-SY',
    SzPl: 'sz-PL',
    TaIn: 'ta-IN',
    TeIn: 'te-IN',
    TgTj: 'tg-TJ',
    ThTh: 'th-TH',
    TlPh: 'tl-PH',
    Tr: 'tr',
    TrTr: 'tr-TR',
    TtRu: 'tt-RU',
    TzMa: 'tz-MA',
    UkUa: 'uk-UA',
    UrPk: 'ur-PK',
    UzUz: 'uz-UZ',
    ViVn: 'vi-VN',
    Zh: 'zh',
    ZhCn: 'zh-CN',
    ZhHk: 'zh-HK',
    ZhMo: 'zh-MO',
    ZhTw: 'zh-TW',
    ZzTr: 'zz-TR'
} as const;
export type ApiCustomPhrasesLanguageTagDeleteLanguageTagEnum = typeof ApiCustomPhrasesLanguageTagDeleteLanguageTagEnum[keyof typeof ApiCustomPhrasesLanguageTagDeleteLanguageTagEnum];
/**
 * @export
 */
export const ApiCustomPhrasesLanguageTagGetLanguageTagEnum = {
    AfZa: 'af-ZA',
    AmEt: 'am-ET',
    ArAr: 'ar-AR',
    AsIn: 'as-IN',
    AzAz: 'az-AZ',
    BeBy: 'be-BY',
    BgBg: 'bg-BG',
    BnIn: 'bn-IN',
    BrFr: 'br-FR',
    BsBa: 'bs-BA',
    CaEs: 'ca-ES',
    CbIq: 'cb-IQ',
    CoFr: 'co-FR',
    CsCz: 'cs-CZ',
    CxPh: 'cx-PH',
    CyGb: 'cy-GB',
    DaDk: 'da-DK',
    De: 'de',
    DeDe: 'de-DE',
    ElGr: 'el-GR',
    En: 'en',
    EnGb: 'en-GB',
    EnUs: 'en-US',
    EoEo: 'eo-EO',
    Es: 'es',
    EsEs: 'es-ES',
    Es419: 'es-419',
    EtEe: 'et-EE',
    EuEs: 'eu-ES',
    FaIr: 'fa-IR',
    FfNg: 'ff-NG',
    FiFi: 'fi-FI',
    FoFo: 'fo-FO',
    Fr: 'fr',
    FrCa: 'fr-CA',
    FrFr: 'fr-FR',
    FyNl: 'fy-NL',
    GaIe: 'ga-IE',
    GlEs: 'gl-ES',
    GnPy: 'gn-PY',
    GuIn: 'gu-IN',
    HaNg: 'ha-NG',
    HeIl: 'he-IL',
    HiIn: 'hi-IN',
    HrHr: 'hr-HR',
    HtHt: 'ht-HT',
    HuHu: 'hu-HU',
    HyAm: 'hy-AM',
    IdId: 'id-ID',
    IkUs: 'ik-US',
    IsIs: 'is-IS',
    It: 'it',
    ItIt: 'it-IT',
    IuCa: 'iu-CA',
    Ja: 'ja',
    JaJp: 'ja-JP',
    JaKs: 'ja-KS',
    JvId: 'jv-ID',
    KaGe: 'ka-GE',
    KkKz: 'kk-KZ',
    KmKh: 'km-KH',
    KnIn: 'kn-IN',
    Ko: 'ko',
    KoKr: 'ko-KR',
    KuTr: 'ku-TR',
    KyKg: 'ky-KG',
    LoLa: 'lo-LA',
    LtLt: 'lt-LT',
    LvLv: 'lv-LV',
    MgMg: 'mg-MG',
    MkMk: 'mk-MK',
    MlIn: 'ml-IN',
    MnMn: 'mn-MN',
    MrIn: 'mr-IN',
    MsMy: 'ms-MY',
    MtMt: 'mt-MT',
    MyMm: 'my-MM',
    NbNo: 'nb-NO',
    NeNp: 'ne-NP',
    NlBe: 'nl-BE',
    NlNl: 'nl-NL',
    NnNo: 'nn-NO',
    OrIn: 'or-IN',
    PaIn: 'pa-IN',
    PlPl: 'pl-PL',
    PsAf: 'ps-AF',
    Pt: 'pt',
    PtBr: 'pt-BR',
    PtPt: 'pt-PT',
    RoRo: 'ro-RO',
    Ru: 'ru',
    RuRu: 'ru-RU',
    RwRw: 'rw-RW',
    ScIt: 'sc-IT',
    SiLk: 'si-LK',
    SkSk: 'sk-SK',
    SlSi: 'sl-SI',
    SnZw: 'sn-ZW',
    SqAl: 'sq-AL',
    SrRs: 'sr-RS',
    SvSe: 'sv-SE',
    SwKe: 'sw-KE',
    SySy: 'sy-SY',
    SzPl: 'sz-PL',
    TaIn: 'ta-IN',
    TeIn: 'te-IN',
    TgTj: 'tg-TJ',
    ThTh: 'th-TH',
    TlPh: 'tl-PH',
    Tr: 'tr',
    TrTr: 'tr-TR',
    TtRu: 'tt-RU',
    TzMa: 'tz-MA',
    UkUa: 'uk-UA',
    UrPk: 'ur-PK',
    UzUz: 'uz-UZ',
    ViVn: 'vi-VN',
    Zh: 'zh',
    ZhCn: 'zh-CN',
    ZhHk: 'zh-HK',
    ZhMo: 'zh-MO',
    ZhTw: 'zh-TW',
    ZzTr: 'zz-TR'
} as const;
export type ApiCustomPhrasesLanguageTagGetLanguageTagEnum = typeof ApiCustomPhrasesLanguageTagGetLanguageTagEnum[keyof typeof ApiCustomPhrasesLanguageTagGetLanguageTagEnum];
/**
 * @export
 */
export const ApiCustomPhrasesLanguageTagPutLanguageTagEnum = {
    AfZa: 'af-ZA',
    AmEt: 'am-ET',
    ArAr: 'ar-AR',
    AsIn: 'as-IN',
    AzAz: 'az-AZ',
    BeBy: 'be-BY',
    BgBg: 'bg-BG',
    BnIn: 'bn-IN',
    BrFr: 'br-FR',
    BsBa: 'bs-BA',
    CaEs: 'ca-ES',
    CbIq: 'cb-IQ',
    CoFr: 'co-FR',
    CsCz: 'cs-CZ',
    CxPh: 'cx-PH',
    CyGb: 'cy-GB',
    DaDk: 'da-DK',
    De: 'de',
    DeDe: 'de-DE',
    ElGr: 'el-GR',
    En: 'en',
    EnGb: 'en-GB',
    EnUs: 'en-US',
    EoEo: 'eo-EO',
    Es: 'es',
    EsEs: 'es-ES',
    Es419: 'es-419',
    EtEe: 'et-EE',
    EuEs: 'eu-ES',
    FaIr: 'fa-IR',
    FfNg: 'ff-NG',
    FiFi: 'fi-FI',
    FoFo: 'fo-FO',
    Fr: 'fr',
    FrCa: 'fr-CA',
    FrFr: 'fr-FR',
    FyNl: 'fy-NL',
    GaIe: 'ga-IE',
    GlEs: 'gl-ES',
    GnPy: 'gn-PY',
    GuIn: 'gu-IN',
    HaNg: 'ha-NG',
    HeIl: 'he-IL',
    HiIn: 'hi-IN',
    HrHr: 'hr-HR',
    HtHt: 'ht-HT',
    HuHu: 'hu-HU',
    HyAm: 'hy-AM',
    IdId: 'id-ID',
    IkUs: 'ik-US',
    IsIs: 'is-IS',
    It: 'it',
    ItIt: 'it-IT',
    IuCa: 'iu-CA',
    Ja: 'ja',
    JaJp: 'ja-JP',
    JaKs: 'ja-KS',
    JvId: 'jv-ID',
    KaGe: 'ka-GE',
    KkKz: 'kk-KZ',
    KmKh: 'km-KH',
    KnIn: 'kn-IN',
    Ko: 'ko',
    KoKr: 'ko-KR',
    KuTr: 'ku-TR',
    KyKg: 'ky-KG',
    LoLa: 'lo-LA',
    LtLt: 'lt-LT',
    LvLv: 'lv-LV',
    MgMg: 'mg-MG',
    MkMk: 'mk-MK',
    MlIn: 'ml-IN',
    MnMn: 'mn-MN',
    MrIn: 'mr-IN',
    MsMy: 'ms-MY',
    MtMt: 'mt-MT',
    MyMm: 'my-MM',
    NbNo: 'nb-NO',
    NeNp: 'ne-NP',
    NlBe: 'nl-BE',
    NlNl: 'nl-NL',
    NnNo: 'nn-NO',
    OrIn: 'or-IN',
    PaIn: 'pa-IN',
    PlPl: 'pl-PL',
    PsAf: 'ps-AF',
    Pt: 'pt',
    PtBr: 'pt-BR',
    PtPt: 'pt-PT',
    RoRo: 'ro-RO',
    Ru: 'ru',
    RuRu: 'ru-RU',
    RwRw: 'rw-RW',
    ScIt: 'sc-IT',
    SiLk: 'si-LK',
    SkSk: 'sk-SK',
    SlSi: 'sl-SI',
    SnZw: 'sn-ZW',
    SqAl: 'sq-AL',
    SrRs: 'sr-RS',
    SvSe: 'sv-SE',
    SwKe: 'sw-KE',
    SySy: 'sy-SY',
    SzPl: 'sz-PL',
    TaIn: 'ta-IN',
    TeIn: 'te-IN',
    TgTj: 'tg-TJ',
    ThTh: 'th-TH',
    TlPh: 'tl-PH',
    Tr: 'tr',
    TrTr: 'tr-TR',
    TtRu: 'tt-RU',
    TzMa: 'tz-MA',
    UkUa: 'uk-UA',
    UrPk: 'ur-PK',
    UzUz: 'uz-UZ',
    ViVn: 'vi-VN',
    Zh: 'zh',
    ZhCn: 'zh-CN',
    ZhHk: 'zh-HK',
    ZhMo: 'zh-MO',
    ZhTw: 'zh-TW',
    ZzTr: 'zz-TR'
} as const;
export type ApiCustomPhrasesLanguageTagPutLanguageTagEnum = typeof ApiCustomPhrasesLanguageTagPutLanguageTagEnum[keyof typeof ApiCustomPhrasesLanguageTagPutLanguageTagEnum];


/**
 * DashboardApi - axios parameter creator
 * @export
 */
export const DashboardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get active user data, including daily active user (DAU), weekly active user (WAU) and monthly active user (MAU). It also includes an array of DAU in the past 30 days.
         * @summary Get active user data
         * @param {string} [date] The date to get active user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDashboardUsersActiveGet: async (date?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/dashboard/users/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get new user count in the past 7 days.
         * @summary Get new user count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDashboardUsersNewGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/dashboard/users/new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get total user count in the current tenant.
         * @summary Get total user count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDashboardUsersTotalGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/dashboard/users/total`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardApi - functional programming interface
 * @export
 */
export const DashboardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DashboardApiAxiosParamCreator(configuration)
    return {
        /**
         * Get active user data, including daily active user (DAU), weekly active user (WAU) and monthly active user (MAU). It also includes an array of DAU in the past 30 days.
         * @summary Get active user data
         * @param {string} [date] The date to get active user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDashboardUsersActiveGet(date?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiDashboardUsersActiveGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDashboardUsersActiveGet(date, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.apiDashboardUsersActiveGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get new user count in the past 7 days.
         * @summary Get new user count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDashboardUsersNewGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiDashboardUsersNewGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDashboardUsersNewGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.apiDashboardUsersNewGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get total user count in the current tenant.
         * @summary Get total user count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDashboardUsersTotalGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiDashboardUsersTotalGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDashboardUsersTotalGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.apiDashboardUsersTotalGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DashboardApi - factory interface
 * @export
 */
export const DashboardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DashboardApiFp(configuration)
    return {
        /**
         * Get active user data, including daily active user (DAU), weekly active user (WAU) and monthly active user (MAU). It also includes an array of DAU in the past 30 days.
         * @summary Get active user data
         * @param {string} [date] The date to get active user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDashboardUsersActiveGet(date?: string, options?: any): AxiosPromise<ApiDashboardUsersActiveGet200Response> {
            return localVarFp.apiDashboardUsersActiveGet(date, options).then((request) => request(axios, basePath));
        },
        /**
         * Get new user count in the past 7 days.
         * @summary Get new user count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDashboardUsersNewGet(options?: any): AxiosPromise<ApiDashboardUsersNewGet200Response> {
            return localVarFp.apiDashboardUsersNewGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get total user count in the current tenant.
         * @summary Get total user count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDashboardUsersTotalGet(options?: any): AxiosPromise<ApiDashboardUsersTotalGet200Response> {
            return localVarFp.apiDashboardUsersTotalGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DashboardApi - object-oriented interface
 * @export
 * @class DashboardApi
 * @extends {BaseAPI}
 */
export class DashboardApi extends BaseAPI {
    /**
     * Get active user data, including daily active user (DAU), weekly active user (WAU) and monthly active user (MAU). It also includes an array of DAU in the past 30 days.
     * @summary Get active user data
     * @param {string} [date] The date to get active user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public apiDashboardUsersActiveGet(date?: string, options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).apiDashboardUsersActiveGet(date, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get new user count in the past 7 days.
     * @summary Get new user count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public apiDashboardUsersNewGet(options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).apiDashboardUsersNewGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get total user count in the current tenant.
     * @summary Get total user count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public apiDashboardUsersTotalGet(options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).apiDashboardUsersTotalGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DomainsApi - axios parameter creator
 * @export
 */
export const DomainsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all of your custom domains.
         * @summary Get domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDomainsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/domains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete domain by ID.
         * @summary Delete domain
         * @param {string} id The unique identifier of the domain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDomainsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiDomainsIdDelete', 'id', id)
            const localVarPath = `/api/domains/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get domain details by ID, by calling this API, the domain status will be synced from remote provider.
         * @summary Get domain
         * @param {string} id The unique identifier of the domain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDomainsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiDomainsIdGet', 'id', id)
            const localVarPath = `/api/domains/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new domain with the given data. The maximum domain number is 1, once created, can not be modified, you\'ll have to delete and recreate one.
         * @summary Create domain
         * @param {ApiDomainsPostRequest} apiDomainsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDomainsPost: async (apiDomainsPostRequest: ApiDomainsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiDomainsPostRequest' is not null or undefined
            assertParamExists('apiDomainsPost', 'apiDomainsPostRequest', apiDomainsPostRequest)
            const localVarPath = `/api/domains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiDomainsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DomainsApi - functional programming interface
 * @export
 */
export const DomainsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DomainsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all of your custom domains.
         * @summary Get domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDomainsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiDomainsGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDomainsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainsApi.apiDomainsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete domain by ID.
         * @summary Delete domain
         * @param {string} id The unique identifier of the domain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDomainsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDomainsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainsApi.apiDomainsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get domain details by ID, by calling this API, the domain status will be synced from remote provider.
         * @summary Get domain
         * @param {string} id The unique identifier of the domain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDomainsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiDomainsGet200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDomainsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainsApi.apiDomainsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new domain with the given data. The maximum domain number is 1, once created, can not be modified, you\'ll have to delete and recreate one.
         * @summary Create domain
         * @param {ApiDomainsPostRequest} apiDomainsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDomainsPost(apiDomainsPostRequest: ApiDomainsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDomainsPost(apiDomainsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainsApi.apiDomainsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DomainsApi - factory interface
 * @export
 */
export const DomainsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DomainsApiFp(configuration)
    return {
        /**
         * Get all of your custom domains.
         * @summary Get domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDomainsGet(options?: any): AxiosPromise<Array<ApiDomainsGet200ResponseInner>> {
            return localVarFp.apiDomainsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete domain by ID.
         * @summary Delete domain
         * @param {string} id The unique identifier of the domain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDomainsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiDomainsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get domain details by ID, by calling this API, the domain status will be synced from remote provider.
         * @summary Get domain
         * @param {string} id The unique identifier of the domain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDomainsIdGet(id: string, options?: any): AxiosPromise<ApiDomainsGet200ResponseInner> {
            return localVarFp.apiDomainsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new domain with the given data. The maximum domain number is 1, once created, can not be modified, you\'ll have to delete and recreate one.
         * @summary Create domain
         * @param {ApiDomainsPostRequest} apiDomainsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDomainsPost(apiDomainsPostRequest: ApiDomainsPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiDomainsPost(apiDomainsPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DomainsApi - object-oriented interface
 * @export
 * @class DomainsApi
 * @extends {BaseAPI}
 */
export class DomainsApi extends BaseAPI {
    /**
     * Get all of your custom domains.
     * @summary Get domains
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApi
     */
    public apiDomainsGet(options?: RawAxiosRequestConfig) {
        return DomainsApiFp(this.configuration).apiDomainsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete domain by ID.
     * @summary Delete domain
     * @param {string} id The unique identifier of the domain.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApi
     */
    public apiDomainsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return DomainsApiFp(this.configuration).apiDomainsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get domain details by ID, by calling this API, the domain status will be synced from remote provider.
     * @summary Get domain
     * @param {string} id The unique identifier of the domain.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApi
     */
    public apiDomainsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return DomainsApiFp(this.configuration).apiDomainsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new domain with the given data. The maximum domain number is 1, once created, can not be modified, you\'ll have to delete and recreate one.
     * @summary Create domain
     * @param {ApiDomainsPostRequest} apiDomainsPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApi
     */
    public apiDomainsPost(apiDomainsPostRequest: ApiDomainsPostRequest, options?: RawAxiosRequestConfig) {
        return DomainsApiFp(this.configuration).apiDomainsPost(apiDomainsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HooksApi - axios parameter creator
 * @export
 */
export const HooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of hooks with optional pagination.
         * @summary Get hooks
         * @param {string} [includeExecutionStats] Whether to include execution stats in the response.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHooksGet: async (includeExecutionStats?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/hooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeExecutionStats !== undefined) {
                localVarQueryParameter['includeExecutionStats'] = includeExecutionStats;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete hook by ID.
         * @summary Delete hook
         * @param {string} id The unique identifier of the hook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHooksIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiHooksIdDelete', 'id', id)
            const localVarPath = `/api/hooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get hook details by ID.
         * @summary Get hook
         * @param {string} id The unique identifier of the hook.
         * @param {string} [includeExecutionStats] Whether to include execution stats in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHooksIdGet: async (id: string, includeExecutionStats?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiHooksIdGet', 'id', id)
            const localVarPath = `/api/hooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeExecutionStats !== undefined) {
                localVarQueryParameter['includeExecutionStats'] = includeExecutionStats;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update hook details by ID with the given data.
         * @summary Update hook
         * @param {string} id The unique identifier of the hook.
         * @param {ApiHooksIdPatchRequest} apiHooksIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHooksIdPatch: async (id: string, apiHooksIdPatchRequest: ApiHooksIdPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiHooksIdPatch', 'id', id)
            // verify required parameter 'apiHooksIdPatchRequest' is not null or undefined
            assertParamExists('apiHooksIdPatch', 'apiHooksIdPatchRequest', apiHooksIdPatchRequest)
            const localVarPath = `/api/hooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiHooksIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recent logs that match the given query for the specified hook with pagination.
         * @summary Get recent logs for a hook
         * @param {string} id The unique identifier of the hook.
         * @param {string} [logKey] The log key to filter logs.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHooksIdRecentLogsGet: async (id: string, logKey?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiHooksIdRecentLogsGet', 'id', id)
            const localVarPath = `/api/hooks/{id}/recent-logs`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (logKey !== undefined) {
                localVarQueryParameter['logKey'] = logKey;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the signing key for the specified hook.
         * @summary Update signing key for a hook
         * @param {string} id The unique identifier of the hook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHooksIdSigningKeyPatch: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiHooksIdSigningKeyPatch', 'id', id)
            const localVarPath = `/api/hooks/{id}/signing-key`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test the specified hook with the given events and config.
         * @summary Test hook
         * @param {string} id The unique identifier of the hook.
         * @param {ApiHooksIdTestPostRequest} apiHooksIdTestPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHooksIdTestPost: async (id: string, apiHooksIdTestPostRequest: ApiHooksIdTestPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiHooksIdTestPost', 'id', id)
            // verify required parameter 'apiHooksIdTestPostRequest' is not null or undefined
            assertParamExists('apiHooksIdTestPost', 'apiHooksIdTestPostRequest', apiHooksIdTestPostRequest)
            const localVarPath = `/api/hooks/{id}/test`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiHooksIdTestPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new hook with the given data.
         * @summary Create a hook
         * @param {ApiHooksPostRequest} apiHooksPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHooksPost: async (apiHooksPostRequest: ApiHooksPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiHooksPostRequest' is not null or undefined
            assertParamExists('apiHooksPost', 'apiHooksPostRequest', apiHooksPostRequest)
            const localVarPath = `/api/hooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiHooksPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HooksApi - functional programming interface
 * @export
 */
export const HooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of hooks with optional pagination.
         * @summary Get hooks
         * @param {string} [includeExecutionStats] Whether to include execution stats in the response.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHooksGet(includeExecutionStats?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiHooksGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiHooksGet(includeExecutionStats, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HooksApi.apiHooksGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete hook by ID.
         * @summary Delete hook
         * @param {string} id The unique identifier of the hook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHooksIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiHooksIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HooksApi.apiHooksIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get hook details by ID.
         * @summary Get hook
         * @param {string} id The unique identifier of the hook.
         * @param {string} [includeExecutionStats] Whether to include execution stats in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHooksIdGet(id: string, includeExecutionStats?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiHooksGet200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiHooksIdGet(id, includeExecutionStats, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HooksApi.apiHooksIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update hook details by ID with the given data.
         * @summary Update hook
         * @param {string} id The unique identifier of the hook.
         * @param {ApiHooksIdPatchRequest} apiHooksIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHooksIdPatch(id: string, apiHooksIdPatchRequest: ApiHooksIdPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiHooksIdPatch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiHooksIdPatch(id, apiHooksIdPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HooksApi.apiHooksIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get recent logs that match the given query for the specified hook with pagination.
         * @summary Get recent logs for a hook
         * @param {string} id The unique identifier of the hook.
         * @param {string} [logKey] The log key to filter logs.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHooksIdRecentLogsGet(id: string, logKey?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiLogsGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiHooksIdRecentLogsGet(id, logKey, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HooksApi.apiHooksIdRecentLogsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the signing key for the specified hook.
         * @summary Update signing key for a hook
         * @param {string} id The unique identifier of the hook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHooksIdSigningKeyPatch(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiHooksIdPatch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiHooksIdSigningKeyPatch(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HooksApi.apiHooksIdSigningKeyPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test the specified hook with the given events and config.
         * @summary Test hook
         * @param {string} id The unique identifier of the hook.
         * @param {ApiHooksIdTestPostRequest} apiHooksIdTestPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHooksIdTestPost(id: string, apiHooksIdTestPostRequest: ApiHooksIdTestPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiHooksIdTestPost(id, apiHooksIdTestPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HooksApi.apiHooksIdTestPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new hook with the given data.
         * @summary Create a hook
         * @param {ApiHooksPostRequest} apiHooksPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHooksPost(apiHooksPostRequest: ApiHooksPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiHooksPost(apiHooksPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HooksApi.apiHooksPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HooksApi - factory interface
 * @export
 */
export const HooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HooksApiFp(configuration)
    return {
        /**
         * Get a list of hooks with optional pagination.
         * @summary Get hooks
         * @param {string} [includeExecutionStats] Whether to include execution stats in the response.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHooksGet(includeExecutionStats?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ApiHooksGet200ResponseInner>> {
            return localVarFp.apiHooksGet(includeExecutionStats, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete hook by ID.
         * @summary Delete hook
         * @param {string} id The unique identifier of the hook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHooksIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiHooksIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get hook details by ID.
         * @summary Get hook
         * @param {string} id The unique identifier of the hook.
         * @param {string} [includeExecutionStats] Whether to include execution stats in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHooksIdGet(id: string, includeExecutionStats?: string, options?: any): AxiosPromise<ApiHooksGet200ResponseInner> {
            return localVarFp.apiHooksIdGet(id, includeExecutionStats, options).then((request) => request(axios, basePath));
        },
        /**
         * Update hook details by ID with the given data.
         * @summary Update hook
         * @param {string} id The unique identifier of the hook.
         * @param {ApiHooksIdPatchRequest} apiHooksIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHooksIdPatch(id: string, apiHooksIdPatchRequest: ApiHooksIdPatchRequest, options?: any): AxiosPromise<ApiHooksIdPatch200Response> {
            return localVarFp.apiHooksIdPatch(id, apiHooksIdPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get recent logs that match the given query for the specified hook with pagination.
         * @summary Get recent logs for a hook
         * @param {string} id The unique identifier of the hook.
         * @param {string} [logKey] The log key to filter logs.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHooksIdRecentLogsGet(id: string, logKey?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ApiLogsGet200ResponseInner>> {
            return localVarFp.apiHooksIdRecentLogsGet(id, logKey, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the signing key for the specified hook.
         * @summary Update signing key for a hook
         * @param {string} id The unique identifier of the hook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHooksIdSigningKeyPatch(id: string, options?: any): AxiosPromise<ApiHooksIdPatch200Response> {
            return localVarFp.apiHooksIdSigningKeyPatch(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Test the specified hook with the given events and config.
         * @summary Test hook
         * @param {string} id The unique identifier of the hook.
         * @param {ApiHooksIdTestPostRequest} apiHooksIdTestPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHooksIdTestPost(id: string, apiHooksIdTestPostRequest: ApiHooksIdTestPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiHooksIdTestPost(id, apiHooksIdTestPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new hook with the given data.
         * @summary Create a hook
         * @param {ApiHooksPostRequest} apiHooksPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHooksPost(apiHooksPostRequest: ApiHooksPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiHooksPost(apiHooksPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HooksApi - object-oriented interface
 * @export
 * @class HooksApi
 * @extends {BaseAPI}
 */
export class HooksApi extends BaseAPI {
    /**
     * Get a list of hooks with optional pagination.
     * @summary Get hooks
     * @param {string} [includeExecutionStats] Whether to include execution stats in the response.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HooksApi
     */
    public apiHooksGet(includeExecutionStats?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return HooksApiFp(this.configuration).apiHooksGet(includeExecutionStats, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete hook by ID.
     * @summary Delete hook
     * @param {string} id The unique identifier of the hook.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HooksApi
     */
    public apiHooksIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return HooksApiFp(this.configuration).apiHooksIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get hook details by ID.
     * @summary Get hook
     * @param {string} id The unique identifier of the hook.
     * @param {string} [includeExecutionStats] Whether to include execution stats in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HooksApi
     */
    public apiHooksIdGet(id: string, includeExecutionStats?: string, options?: RawAxiosRequestConfig) {
        return HooksApiFp(this.configuration).apiHooksIdGet(id, includeExecutionStats, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update hook details by ID with the given data.
     * @summary Update hook
     * @param {string} id The unique identifier of the hook.
     * @param {ApiHooksIdPatchRequest} apiHooksIdPatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HooksApi
     */
    public apiHooksIdPatch(id: string, apiHooksIdPatchRequest: ApiHooksIdPatchRequest, options?: RawAxiosRequestConfig) {
        return HooksApiFp(this.configuration).apiHooksIdPatch(id, apiHooksIdPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recent logs that match the given query for the specified hook with pagination.
     * @summary Get recent logs for a hook
     * @param {string} id The unique identifier of the hook.
     * @param {string} [logKey] The log key to filter logs.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HooksApi
     */
    public apiHooksIdRecentLogsGet(id: string, logKey?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return HooksApiFp(this.configuration).apiHooksIdRecentLogsGet(id, logKey, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the signing key for the specified hook.
     * @summary Update signing key for a hook
     * @param {string} id The unique identifier of the hook.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HooksApi
     */
    public apiHooksIdSigningKeyPatch(id: string, options?: RawAxiosRequestConfig) {
        return HooksApiFp(this.configuration).apiHooksIdSigningKeyPatch(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test the specified hook with the given events and config.
     * @summary Test hook
     * @param {string} id The unique identifier of the hook.
     * @param {ApiHooksIdTestPostRequest} apiHooksIdTestPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HooksApi
     */
    public apiHooksIdTestPost(id: string, apiHooksIdTestPostRequest: ApiHooksIdTestPostRequest, options?: RawAxiosRequestConfig) {
        return HooksApiFp(this.configuration).apiHooksIdTestPost(id, apiHooksIdTestPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new hook with the given data.
     * @summary Create a hook
     * @param {ApiHooksPostRequest} apiHooksPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HooksApi
     */
    public apiHooksPost(apiHooksPostRequest: ApiHooksPostRequest, options?: RawAxiosRequestConfig) {
        return HooksApiFp(this.configuration).apiHooksPost(apiHooksPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InteractionApi - axios parameter creator
 * @export
 */
export const InteractionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ApiInteractionBindMfaPostRequest} apiInteractionBindMfaPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionBindMfaPost: async (apiInteractionBindMfaPostRequest: ApiInteractionBindMfaPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiInteractionBindMfaPostRequest' is not null or undefined
            assertParamExists('apiInteractionBindMfaPost', 'apiInteractionBindMfaPostRequest', apiInteractionBindMfaPostRequest)
            const localVarPath = `/api/interaction/bind-mfa`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiInteractionBindMfaPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionConsentGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/interaction/consent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiInteractionConsentPostRequest} apiInteractionConsentPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionConsentPost: async (apiInteractionConsentPostRequest: ApiInteractionConsentPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiInteractionConsentPostRequest' is not null or undefined
            assertParamExists('apiInteractionConsentPost', 'apiInteractionConsentPostRequest', apiInteractionConsentPostRequest)
            const localVarPath = `/api/interaction/consent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiInteractionConsentPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionDelete: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/interaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiInteractionEventPutRequest} apiInteractionEventPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionEventPut: async (apiInteractionEventPutRequest: ApiInteractionEventPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiInteractionEventPutRequest' is not null or undefined
            assertParamExists('apiInteractionEventPut', 'apiInteractionEventPutRequest', apiInteractionEventPutRequest)
            const localVarPath = `/api/interaction/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiInteractionEventPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiInteractionPutRequestIdentifier} apiInteractionPutRequestIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionIdentifiersPatch: async (apiInteractionPutRequestIdentifier: ApiInteractionPutRequestIdentifier, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiInteractionPutRequestIdentifier' is not null or undefined
            assertParamExists('apiInteractionIdentifiersPatch', 'apiInteractionPutRequestIdentifier', apiInteractionPutRequestIdentifier)
            const localVarPath = `/api/interaction/identifiers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiInteractionPutRequestIdentifier, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiInteractionMfaPutRequest} apiInteractionMfaPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionMfaPut: async (apiInteractionMfaPutRequest: ApiInteractionMfaPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiInteractionMfaPutRequest' is not null or undefined
            assertParamExists('apiInteractionMfaPut', 'apiInteractionMfaPutRequest', apiInteractionMfaPutRequest)
            const localVarPath = `/api/interaction/mfa`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiInteractionMfaPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiInteractionMfaSkippedPutRequest} apiInteractionMfaSkippedPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionMfaSkippedPut: async (apiInteractionMfaSkippedPutRequest: ApiInteractionMfaSkippedPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiInteractionMfaSkippedPutRequest' is not null or undefined
            assertParamExists('apiInteractionMfaSkippedPut', 'apiInteractionMfaSkippedPutRequest', apiInteractionMfaSkippedPutRequest)
            const localVarPath = `/api/interaction/mfa-skipped`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiInteractionMfaSkippedPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionProfileDelete: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/interaction/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiInteractionPutRequestProfile} apiInteractionPutRequestProfile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionProfilePatch: async (apiInteractionPutRequestProfile: ApiInteractionPutRequestProfile, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiInteractionPutRequestProfile' is not null or undefined
            assertParamExists('apiInteractionProfilePatch', 'apiInteractionPutRequestProfile', apiInteractionPutRequestProfile)
            const localVarPath = `/api/interaction/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiInteractionPutRequestProfile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiInteractionPutRequestProfile} apiInteractionPutRequestProfile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionProfilePut: async (apiInteractionPutRequestProfile: ApiInteractionPutRequestProfile, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiInteractionPutRequestProfile' is not null or undefined
            assertParamExists('apiInteractionProfilePut', 'apiInteractionPutRequestProfile', apiInteractionPutRequestProfile)
            const localVarPath = `/api/interaction/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiInteractionPutRequestProfile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiInteractionPutRequest} apiInteractionPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionPut: async (apiInteractionPutRequest: ApiInteractionPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiInteractionPutRequest' is not null or undefined
            assertParamExists('apiInteractionPut', 'apiInteractionPutRequest', apiInteractionPutRequest)
            const localVarPath = `/api/interaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiInteractionPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} connectorId The unique identifier of the connector.
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionSingleSignOnConnectorIdAuthenticationPost: async (connectorId: string, requestBody: { [key: string]: any; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('apiInteractionSingleSignOnConnectorIdAuthenticationPost', 'connectorId', connectorId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('apiInteractionSingleSignOnConnectorIdAuthenticationPost', 'requestBody', requestBody)
            const localVarPath = `/api/interaction/single-sign-on/{connectorId}/authentication`
                .replace(`{${"connectorId"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} connectorId The unique identifier of the connector.
         * @param {ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest} apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionSingleSignOnConnectorIdAuthorizationUrlPost: async (connectorId: string, apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest: ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('apiInteractionSingleSignOnConnectorIdAuthorizationUrlPost', 'connectorId', connectorId)
            // verify required parameter 'apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest' is not null or undefined
            assertParamExists('apiInteractionSingleSignOnConnectorIdAuthorizationUrlPost', 'apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest', apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest)
            const localVarPath = `/api/interaction/single-sign-on/{connectorId}/authorization-url`
                .replace(`{${"connectorId"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} connectorId The unique identifier of the connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionSingleSignOnConnectorIdRegistrationPost: async (connectorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('apiInteractionSingleSignOnConnectorIdRegistrationPost', 'connectorId', connectorId)
            const localVarPath = `/api/interaction/single-sign-on/{connectorId}/registration`
                .replace(`{${"connectorId"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionSingleSignOnConnectorsGet: async (email: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('apiInteractionSingleSignOnConnectorsGet', 'email', email)
            const localVarPath = `/api/interaction/single-sign-on/connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionSubmitPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/interaction/submit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiInteractionVerificationSocialAuthorizationUriPostRequest} apiInteractionVerificationSocialAuthorizationUriPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionVerificationSocialAuthorizationUriPost: async (apiInteractionVerificationSocialAuthorizationUriPostRequest: ApiInteractionVerificationSocialAuthorizationUriPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiInteractionVerificationSocialAuthorizationUriPostRequest' is not null or undefined
            assertParamExists('apiInteractionVerificationSocialAuthorizationUriPost', 'apiInteractionVerificationSocialAuthorizationUriPostRequest', apiInteractionVerificationSocialAuthorizationUriPostRequest)
            const localVarPath = `/api/interaction/verification/social-authorization-uri`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiInteractionVerificationSocialAuthorizationUriPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionVerificationTotpPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/interaction/verification/totp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiInteractionVerificationVerificationCodePostRequest} apiInteractionVerificationVerificationCodePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionVerificationVerificationCodePost: async (apiInteractionVerificationVerificationCodePostRequest: ApiInteractionVerificationVerificationCodePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiInteractionVerificationVerificationCodePostRequest' is not null or undefined
            assertParamExists('apiInteractionVerificationVerificationCodePost', 'apiInteractionVerificationVerificationCodePostRequest', apiInteractionVerificationVerificationCodePostRequest)
            const localVarPath = `/api/interaction/verification/verification-code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiInteractionVerificationVerificationCodePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionVerificationWebauthnAuthenticationPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/interaction/verification/webauthn-authentication`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionVerificationWebauthnRegistrationPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/interaction/verification/webauthn-registration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InteractionApi - functional programming interface
 * @export
 */
export const InteractionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InteractionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ApiInteractionBindMfaPostRequest} apiInteractionBindMfaPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionBindMfaPost(apiInteractionBindMfaPostRequest: ApiInteractionBindMfaPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionBindMfaPost(apiInteractionBindMfaPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionBindMfaPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionConsentGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiInteractionConsentGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionConsentGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionConsentGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiInteractionConsentPostRequest} apiInteractionConsentPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionConsentPost(apiInteractionConsentPostRequest: ApiInteractionConsentPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionConsentPost(apiInteractionConsentPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionConsentPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionDelete(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionDelete(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiInteractionEventPutRequest} apiInteractionEventPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionEventPut(apiInteractionEventPutRequest: ApiInteractionEventPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionEventPut(apiInteractionEventPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionEventPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiInteractionPutRequestIdentifier} apiInteractionPutRequestIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionIdentifiersPatch(apiInteractionPutRequestIdentifier: ApiInteractionPutRequestIdentifier, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionIdentifiersPatch(apiInteractionPutRequestIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionIdentifiersPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiInteractionMfaPutRequest} apiInteractionMfaPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionMfaPut(apiInteractionMfaPutRequest: ApiInteractionMfaPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionMfaPut(apiInteractionMfaPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionMfaPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiInteractionMfaSkippedPutRequest} apiInteractionMfaSkippedPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionMfaSkippedPut(apiInteractionMfaSkippedPutRequest: ApiInteractionMfaSkippedPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionMfaSkippedPut(apiInteractionMfaSkippedPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionMfaSkippedPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionProfileDelete(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionProfileDelete(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionProfileDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiInteractionPutRequestProfile} apiInteractionPutRequestProfile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionProfilePatch(apiInteractionPutRequestProfile: ApiInteractionPutRequestProfile, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionProfilePatch(apiInteractionPutRequestProfile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionProfilePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiInteractionPutRequestProfile} apiInteractionPutRequestProfile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionProfilePut(apiInteractionPutRequestProfile: ApiInteractionPutRequestProfile, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionProfilePut(apiInteractionPutRequestProfile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionProfilePut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiInteractionPutRequest} apiInteractionPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionPut(apiInteractionPutRequest: ApiInteractionPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionPut(apiInteractionPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} connectorId The unique identifier of the connector.
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionSingleSignOnConnectorIdAuthenticationPost(connectorId: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiInteractionSubmitPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionSingleSignOnConnectorIdAuthenticationPost(connectorId, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionSingleSignOnConnectorIdAuthenticationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} connectorId The unique identifier of the connector.
         * @param {ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest} apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionSingleSignOnConnectorIdAuthorizationUrlPost(connectorId: string, apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest: ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiInteractionSubmitPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionSingleSignOnConnectorIdAuthorizationUrlPost(connectorId, apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionSingleSignOnConnectorIdAuthorizationUrlPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} connectorId The unique identifier of the connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionSingleSignOnConnectorIdRegistrationPost(connectorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiInteractionSubmitPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionSingleSignOnConnectorIdRegistrationPost(connectorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionSingleSignOnConnectorIdRegistrationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionSingleSignOnConnectorsGet(email: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionSingleSignOnConnectorsGet(email, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionSingleSignOnConnectorsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionSubmitPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiInteractionSubmitPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionSubmitPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionSubmitPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiInteractionVerificationSocialAuthorizationUriPostRequest} apiInteractionVerificationSocialAuthorizationUriPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionVerificationSocialAuthorizationUriPost(apiInteractionVerificationSocialAuthorizationUriPostRequest: ApiInteractionVerificationSocialAuthorizationUriPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiInteractionSubmitPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionVerificationSocialAuthorizationUriPost(apiInteractionVerificationSocialAuthorizationUriPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionVerificationSocialAuthorizationUriPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionVerificationTotpPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiInteractionVerificationTotpPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionVerificationTotpPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionVerificationTotpPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiInteractionVerificationVerificationCodePostRequest} apiInteractionVerificationVerificationCodePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionVerificationVerificationCodePost(apiInteractionVerificationVerificationCodePostRequest: ApiInteractionVerificationVerificationCodePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionVerificationVerificationCodePost(apiInteractionVerificationVerificationCodePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionVerificationVerificationCodePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionVerificationWebauthnAuthenticationPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiInteractionVerificationWebauthnAuthenticationPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionVerificationWebauthnAuthenticationPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionVerificationWebauthnAuthenticationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionVerificationWebauthnRegistrationPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiInteractionVerificationWebauthnRegistrationPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionVerificationWebauthnRegistrationPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionVerificationWebauthnRegistrationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InteractionApi - factory interface
 * @export
 */
export const InteractionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InteractionApiFp(configuration)
    return {
        /**
         * 
         * @param {ApiInteractionBindMfaPostRequest} apiInteractionBindMfaPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionBindMfaPost(apiInteractionBindMfaPostRequest: ApiInteractionBindMfaPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiInteractionBindMfaPost(apiInteractionBindMfaPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionConsentGet(options?: any): AxiosPromise<ApiInteractionConsentGet200Response> {
            return localVarFp.apiInteractionConsentGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiInteractionConsentPostRequest} apiInteractionConsentPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionConsentPost(apiInteractionConsentPostRequest: ApiInteractionConsentPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiInteractionConsentPost(apiInteractionConsentPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionDelete(options?: any): AxiosPromise<void> {
            return localVarFp.apiInteractionDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiInteractionEventPutRequest} apiInteractionEventPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionEventPut(apiInteractionEventPutRequest: ApiInteractionEventPutRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiInteractionEventPut(apiInteractionEventPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiInteractionPutRequestIdentifier} apiInteractionPutRequestIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionIdentifiersPatch(apiInteractionPutRequestIdentifier: ApiInteractionPutRequestIdentifier, options?: any): AxiosPromise<void> {
            return localVarFp.apiInteractionIdentifiersPatch(apiInteractionPutRequestIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiInteractionMfaPutRequest} apiInteractionMfaPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionMfaPut(apiInteractionMfaPutRequest: ApiInteractionMfaPutRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiInteractionMfaPut(apiInteractionMfaPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiInteractionMfaSkippedPutRequest} apiInteractionMfaSkippedPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionMfaSkippedPut(apiInteractionMfaSkippedPutRequest: ApiInteractionMfaSkippedPutRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiInteractionMfaSkippedPut(apiInteractionMfaSkippedPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionProfileDelete(options?: any): AxiosPromise<void> {
            return localVarFp.apiInteractionProfileDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiInteractionPutRequestProfile} apiInteractionPutRequestProfile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionProfilePatch(apiInteractionPutRequestProfile: ApiInteractionPutRequestProfile, options?: any): AxiosPromise<void> {
            return localVarFp.apiInteractionProfilePatch(apiInteractionPutRequestProfile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiInteractionPutRequestProfile} apiInteractionPutRequestProfile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionProfilePut(apiInteractionPutRequestProfile: ApiInteractionPutRequestProfile, options?: any): AxiosPromise<void> {
            return localVarFp.apiInteractionProfilePut(apiInteractionPutRequestProfile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiInteractionPutRequest} apiInteractionPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionPut(apiInteractionPutRequest: ApiInteractionPutRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiInteractionPut(apiInteractionPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} connectorId The unique identifier of the connector.
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionSingleSignOnConnectorIdAuthenticationPost(connectorId: string, requestBody: { [key: string]: any; }, options?: any): AxiosPromise<ApiInteractionSubmitPost200Response> {
            return localVarFp.apiInteractionSingleSignOnConnectorIdAuthenticationPost(connectorId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} connectorId The unique identifier of the connector.
         * @param {ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest} apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionSingleSignOnConnectorIdAuthorizationUrlPost(connectorId: string, apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest: ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest, options?: any): AxiosPromise<ApiInteractionSubmitPost200Response> {
            return localVarFp.apiInteractionSingleSignOnConnectorIdAuthorizationUrlPost(connectorId, apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} connectorId The unique identifier of the connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionSingleSignOnConnectorIdRegistrationPost(connectorId: string, options?: any): AxiosPromise<ApiInteractionSubmitPost200Response> {
            return localVarFp.apiInteractionSingleSignOnConnectorIdRegistrationPost(connectorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionSingleSignOnConnectorsGet(email: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.apiInteractionSingleSignOnConnectorsGet(email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionSubmitPost(options?: any): AxiosPromise<ApiInteractionSubmitPost200Response> {
            return localVarFp.apiInteractionSubmitPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiInteractionVerificationSocialAuthorizationUriPostRequest} apiInteractionVerificationSocialAuthorizationUriPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionVerificationSocialAuthorizationUriPost(apiInteractionVerificationSocialAuthorizationUriPostRequest: ApiInteractionVerificationSocialAuthorizationUriPostRequest, options?: any): AxiosPromise<ApiInteractionSubmitPost200Response> {
            return localVarFp.apiInteractionVerificationSocialAuthorizationUriPost(apiInteractionVerificationSocialAuthorizationUriPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionVerificationTotpPost(options?: any): AxiosPromise<ApiInteractionVerificationTotpPost200Response> {
            return localVarFp.apiInteractionVerificationTotpPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiInteractionVerificationVerificationCodePostRequest} apiInteractionVerificationVerificationCodePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionVerificationVerificationCodePost(apiInteractionVerificationVerificationCodePostRequest: ApiInteractionVerificationVerificationCodePostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiInteractionVerificationVerificationCodePost(apiInteractionVerificationVerificationCodePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionVerificationWebauthnAuthenticationPost(options?: any): AxiosPromise<ApiInteractionVerificationWebauthnAuthenticationPost200Response> {
            return localVarFp.apiInteractionVerificationWebauthnAuthenticationPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionVerificationWebauthnRegistrationPost(options?: any): AxiosPromise<ApiInteractionVerificationWebauthnRegistrationPost200Response> {
            return localVarFp.apiInteractionVerificationWebauthnRegistrationPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InteractionApi - object-oriented interface
 * @export
 * @class InteractionApi
 * @extends {BaseAPI}
 */
export class InteractionApi extends BaseAPI {
    /**
     * 
     * @param {ApiInteractionBindMfaPostRequest} apiInteractionBindMfaPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionBindMfaPost(apiInteractionBindMfaPostRequest: ApiInteractionBindMfaPostRequest, options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionBindMfaPost(apiInteractionBindMfaPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionConsentGet(options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionConsentGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiInteractionConsentPostRequest} apiInteractionConsentPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionConsentPost(apiInteractionConsentPostRequest: ApiInteractionConsentPostRequest, options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionConsentPost(apiInteractionConsentPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionDelete(options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiInteractionEventPutRequest} apiInteractionEventPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionEventPut(apiInteractionEventPutRequest: ApiInteractionEventPutRequest, options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionEventPut(apiInteractionEventPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiInteractionPutRequestIdentifier} apiInteractionPutRequestIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionIdentifiersPatch(apiInteractionPutRequestIdentifier: ApiInteractionPutRequestIdentifier, options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionIdentifiersPatch(apiInteractionPutRequestIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiInteractionMfaPutRequest} apiInteractionMfaPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionMfaPut(apiInteractionMfaPutRequest: ApiInteractionMfaPutRequest, options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionMfaPut(apiInteractionMfaPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiInteractionMfaSkippedPutRequest} apiInteractionMfaSkippedPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionMfaSkippedPut(apiInteractionMfaSkippedPutRequest: ApiInteractionMfaSkippedPutRequest, options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionMfaSkippedPut(apiInteractionMfaSkippedPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionProfileDelete(options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionProfileDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiInteractionPutRequestProfile} apiInteractionPutRequestProfile 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionProfilePatch(apiInteractionPutRequestProfile: ApiInteractionPutRequestProfile, options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionProfilePatch(apiInteractionPutRequestProfile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiInteractionPutRequestProfile} apiInteractionPutRequestProfile 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionProfilePut(apiInteractionPutRequestProfile: ApiInteractionPutRequestProfile, options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionProfilePut(apiInteractionPutRequestProfile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiInteractionPutRequest} apiInteractionPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionPut(apiInteractionPutRequest: ApiInteractionPutRequest, options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionPut(apiInteractionPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} connectorId The unique identifier of the connector.
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionSingleSignOnConnectorIdAuthenticationPost(connectorId: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionSingleSignOnConnectorIdAuthenticationPost(connectorId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} connectorId The unique identifier of the connector.
     * @param {ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest} apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionSingleSignOnConnectorIdAuthorizationUrlPost(connectorId: string, apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest: ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest, options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionSingleSignOnConnectorIdAuthorizationUrlPost(connectorId, apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} connectorId The unique identifier of the connector.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionSingleSignOnConnectorIdRegistrationPost(connectorId: string, options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionSingleSignOnConnectorIdRegistrationPost(connectorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionSingleSignOnConnectorsGet(email: string, options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionSingleSignOnConnectorsGet(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionSubmitPost(options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionSubmitPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiInteractionVerificationSocialAuthorizationUriPostRequest} apiInteractionVerificationSocialAuthorizationUriPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionVerificationSocialAuthorizationUriPost(apiInteractionVerificationSocialAuthorizationUriPostRequest: ApiInteractionVerificationSocialAuthorizationUriPostRequest, options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionVerificationSocialAuthorizationUriPost(apiInteractionVerificationSocialAuthorizationUriPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionVerificationTotpPost(options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionVerificationTotpPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiInteractionVerificationVerificationCodePostRequest} apiInteractionVerificationVerificationCodePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionVerificationVerificationCodePost(apiInteractionVerificationVerificationCodePostRequest: ApiInteractionVerificationVerificationCodePostRequest, options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionVerificationVerificationCodePost(apiInteractionVerificationVerificationCodePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionVerificationWebauthnAuthenticationPost(options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionVerificationWebauthnAuthenticationPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionVerificationWebauthnRegistrationPost(options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionVerificationWebauthnRegistrationPost(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationInvitationsApi - axios parameter creator
 * @export
 */
export const OrganizationInvitationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get organization invitations.
         * @summary Get organization invitations
         * @param {string} [organizationId] 
         * @param {string} [inviterId] 
         * @param {string} [invitee] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationInvitationsGet: async (organizationId?: string, inviterId?: string, invitee?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/organization-invitations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (inviterId !== undefined) {
                localVarQueryParameter['inviterId'] = inviterId;
            }

            if (invitee !== undefined) {
                localVarQueryParameter['invitee'] = invitee;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an organization invitation by ID.
         * @summary Delete organization invitation
         * @param {string} id The unique identifier of the organization invitation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationInvitationsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationInvitationsIdDelete', 'id', id)
            const localVarPath = `/api/organization-invitations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an organization invitation by ID.
         * @summary Get organization invitation
         * @param {string} id The unique identifier of the organization invitation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationInvitationsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationInvitationsIdGet', 'id', id)
            const localVarPath = `/api/organization-invitations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resend the invitation message to the invitee.
         * @summary Resend invitation message
         * @param {string} id The unique identifier of the organization invitation.
         * @param {ApiOrganizationInvitationsPostRequestMessagePayloadOneOf} apiOrganizationInvitationsPostRequestMessagePayloadOneOf The message payload for the \&quot;OrganizationInvitation\&quot; template to use when sending the invitation via email.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationInvitationsIdMessagePost: async (id: string, apiOrganizationInvitationsPostRequestMessagePayloadOneOf: ApiOrganizationInvitationsPostRequestMessagePayloadOneOf, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationInvitationsIdMessagePost', 'id', id)
            // verify required parameter 'apiOrganizationInvitationsPostRequestMessagePayloadOneOf' is not null or undefined
            assertParamExists('apiOrganizationInvitationsIdMessagePost', 'apiOrganizationInvitationsPostRequestMessagePayloadOneOf', apiOrganizationInvitationsPostRequestMessagePayloadOneOf)
            const localVarPath = `/api/organization-invitations/{id}/message`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiOrganizationInvitationsPostRequestMessagePayloadOneOf, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the status of an organization invitation by ID.
         * @summary Update organization invitation status
         * @param {string} id The unique identifier of the organization invitation.
         * @param {ApiOrganizationInvitationsIdStatusPutRequest} apiOrganizationInvitationsIdStatusPutRequest The organization invitation status to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationInvitationsIdStatusPut: async (id: string, apiOrganizationInvitationsIdStatusPutRequest: ApiOrganizationInvitationsIdStatusPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationInvitationsIdStatusPut', 'id', id)
            // verify required parameter 'apiOrganizationInvitationsIdStatusPutRequest' is not null or undefined
            assertParamExists('apiOrganizationInvitationsIdStatusPut', 'apiOrganizationInvitationsIdStatusPutRequest', apiOrganizationInvitationsIdStatusPutRequest)
            const localVarPath = `/api/organization-invitations/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiOrganizationInvitationsIdStatusPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an organization invitation and optionally send it via email. The tenant should have an email connector configured if you want to send the invitation via email at this point.
         * @summary Create organization invitation
         * @param {ApiOrganizationInvitationsPostRequest} apiOrganizationInvitationsPostRequest The organization invitation to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationInvitationsPost: async (apiOrganizationInvitationsPostRequest: ApiOrganizationInvitationsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiOrganizationInvitationsPostRequest' is not null or undefined
            assertParamExists('apiOrganizationInvitationsPost', 'apiOrganizationInvitationsPostRequest', apiOrganizationInvitationsPostRequest)
            const localVarPath = `/api/organization-invitations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiOrganizationInvitationsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationInvitationsApi - functional programming interface
 * @export
 */
export const OrganizationInvitationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationInvitationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get organization invitations.
         * @summary Get organization invitations
         * @param {string} [organizationId] 
         * @param {string} [inviterId] 
         * @param {string} [invitee] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationInvitationsGet(organizationId?: string, inviterId?: string, invitee?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiOrganizationInvitationsIdGet200Response>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationInvitationsGet(organizationId, inviterId, invitee, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationInvitationsApi.apiOrganizationInvitationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an organization invitation by ID.
         * @summary Delete organization invitation
         * @param {string} id The unique identifier of the organization invitation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationInvitationsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationInvitationsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationInvitationsApi.apiOrganizationInvitationsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an organization invitation by ID.
         * @summary Get organization invitation
         * @param {string} id The unique identifier of the organization invitation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationInvitationsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiOrganizationInvitationsIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationInvitationsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationInvitationsApi.apiOrganizationInvitationsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resend the invitation message to the invitee.
         * @summary Resend invitation message
         * @param {string} id The unique identifier of the organization invitation.
         * @param {ApiOrganizationInvitationsPostRequestMessagePayloadOneOf} apiOrganizationInvitationsPostRequestMessagePayloadOneOf The message payload for the \&quot;OrganizationInvitation\&quot; template to use when sending the invitation via email.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationInvitationsIdMessagePost(id: string, apiOrganizationInvitationsPostRequestMessagePayloadOneOf: ApiOrganizationInvitationsPostRequestMessagePayloadOneOf, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationInvitationsIdMessagePost(id, apiOrganizationInvitationsPostRequestMessagePayloadOneOf, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationInvitationsApi.apiOrganizationInvitationsIdMessagePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the status of an organization invitation by ID.
         * @summary Update organization invitation status
         * @param {string} id The unique identifier of the organization invitation.
         * @param {ApiOrganizationInvitationsIdStatusPutRequest} apiOrganizationInvitationsIdStatusPutRequest The organization invitation status to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationInvitationsIdStatusPut(id: string, apiOrganizationInvitationsIdStatusPutRequest: ApiOrganizationInvitationsIdStatusPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiOrganizationInvitationsIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationInvitationsIdStatusPut(id, apiOrganizationInvitationsIdStatusPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationInvitationsApi.apiOrganizationInvitationsIdStatusPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an organization invitation and optionally send it via email. The tenant should have an email connector configured if you want to send the invitation via email at this point.
         * @summary Create organization invitation
         * @param {ApiOrganizationInvitationsPostRequest} apiOrganizationInvitationsPostRequest The organization invitation to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationInvitationsPost(apiOrganizationInvitationsPostRequest: ApiOrganizationInvitationsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationInvitationsPost(apiOrganizationInvitationsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationInvitationsApi.apiOrganizationInvitationsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationInvitationsApi - factory interface
 * @export
 */
export const OrganizationInvitationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationInvitationsApiFp(configuration)
    return {
        /**
         * Get organization invitations.
         * @summary Get organization invitations
         * @param {string} [organizationId] 
         * @param {string} [inviterId] 
         * @param {string} [invitee] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationInvitationsGet(organizationId?: string, inviterId?: string, invitee?: string, options?: any): AxiosPromise<Array<ApiOrganizationInvitationsIdGet200Response>> {
            return localVarFp.apiOrganizationInvitationsGet(organizationId, inviterId, invitee, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an organization invitation by ID.
         * @summary Delete organization invitation
         * @param {string} id The unique identifier of the organization invitation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationInvitationsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationInvitationsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an organization invitation by ID.
         * @summary Get organization invitation
         * @param {string} id The unique identifier of the organization invitation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationInvitationsIdGet(id: string, options?: any): AxiosPromise<ApiOrganizationInvitationsIdGet200Response> {
            return localVarFp.apiOrganizationInvitationsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Resend the invitation message to the invitee.
         * @summary Resend invitation message
         * @param {string} id The unique identifier of the organization invitation.
         * @param {ApiOrganizationInvitationsPostRequestMessagePayloadOneOf} apiOrganizationInvitationsPostRequestMessagePayloadOneOf The message payload for the \&quot;OrganizationInvitation\&quot; template to use when sending the invitation via email.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationInvitationsIdMessagePost(id: string, apiOrganizationInvitationsPostRequestMessagePayloadOneOf: ApiOrganizationInvitationsPostRequestMessagePayloadOneOf, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationInvitationsIdMessagePost(id, apiOrganizationInvitationsPostRequestMessagePayloadOneOf, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the status of an organization invitation by ID.
         * @summary Update organization invitation status
         * @param {string} id The unique identifier of the organization invitation.
         * @param {ApiOrganizationInvitationsIdStatusPutRequest} apiOrganizationInvitationsIdStatusPutRequest The organization invitation status to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationInvitationsIdStatusPut(id: string, apiOrganizationInvitationsIdStatusPutRequest: ApiOrganizationInvitationsIdStatusPutRequest, options?: any): AxiosPromise<ApiOrganizationInvitationsIdGet200Response> {
            return localVarFp.apiOrganizationInvitationsIdStatusPut(id, apiOrganizationInvitationsIdStatusPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an organization invitation and optionally send it via email. The tenant should have an email connector configured if you want to send the invitation via email at this point.
         * @summary Create organization invitation
         * @param {ApiOrganizationInvitationsPostRequest} apiOrganizationInvitationsPostRequest The organization invitation to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationInvitationsPost(apiOrganizationInvitationsPostRequest: ApiOrganizationInvitationsPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationInvitationsPost(apiOrganizationInvitationsPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationInvitationsApi - object-oriented interface
 * @export
 * @class OrganizationInvitationsApi
 * @extends {BaseAPI}
 */
export class OrganizationInvitationsApi extends BaseAPI {
    /**
     * Get organization invitations.
     * @summary Get organization invitations
     * @param {string} [organizationId] 
     * @param {string} [inviterId] 
     * @param {string} [invitee] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationInvitationsApi
     */
    public apiOrganizationInvitationsGet(organizationId?: string, inviterId?: string, invitee?: string, options?: RawAxiosRequestConfig) {
        return OrganizationInvitationsApiFp(this.configuration).apiOrganizationInvitationsGet(organizationId, inviterId, invitee, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an organization invitation by ID.
     * @summary Delete organization invitation
     * @param {string} id The unique identifier of the organization invitation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationInvitationsApi
     */
    public apiOrganizationInvitationsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return OrganizationInvitationsApiFp(this.configuration).apiOrganizationInvitationsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an organization invitation by ID.
     * @summary Get organization invitation
     * @param {string} id The unique identifier of the organization invitation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationInvitationsApi
     */
    public apiOrganizationInvitationsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return OrganizationInvitationsApiFp(this.configuration).apiOrganizationInvitationsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resend the invitation message to the invitee.
     * @summary Resend invitation message
     * @param {string} id The unique identifier of the organization invitation.
     * @param {ApiOrganizationInvitationsPostRequestMessagePayloadOneOf} apiOrganizationInvitationsPostRequestMessagePayloadOneOf The message payload for the \&quot;OrganizationInvitation\&quot; template to use when sending the invitation via email.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationInvitationsApi
     */
    public apiOrganizationInvitationsIdMessagePost(id: string, apiOrganizationInvitationsPostRequestMessagePayloadOneOf: ApiOrganizationInvitationsPostRequestMessagePayloadOneOf, options?: RawAxiosRequestConfig) {
        return OrganizationInvitationsApiFp(this.configuration).apiOrganizationInvitationsIdMessagePost(id, apiOrganizationInvitationsPostRequestMessagePayloadOneOf, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the status of an organization invitation by ID.
     * @summary Update organization invitation status
     * @param {string} id The unique identifier of the organization invitation.
     * @param {ApiOrganizationInvitationsIdStatusPutRequest} apiOrganizationInvitationsIdStatusPutRequest The organization invitation status to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationInvitationsApi
     */
    public apiOrganizationInvitationsIdStatusPut(id: string, apiOrganizationInvitationsIdStatusPutRequest: ApiOrganizationInvitationsIdStatusPutRequest, options?: RawAxiosRequestConfig) {
        return OrganizationInvitationsApiFp(this.configuration).apiOrganizationInvitationsIdStatusPut(id, apiOrganizationInvitationsIdStatusPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an organization invitation and optionally send it via email. The tenant should have an email connector configured if you want to send the invitation via email at this point.
     * @summary Create organization invitation
     * @param {ApiOrganizationInvitationsPostRequest} apiOrganizationInvitationsPostRequest The organization invitation to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationInvitationsApi
     */
    public apiOrganizationInvitationsPost(apiOrganizationInvitationsPostRequest: ApiOrganizationInvitationsPostRequest, options?: RawAxiosRequestConfig) {
        return OrganizationInvitationsApiFp(this.configuration).apiOrganizationInvitationsPost(apiOrganizationInvitationsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationRolesApi - axios parameter creator
 * @export
 */
export const OrganizationRolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get organization roles with pagination.
         * @summary Get organization roles
         * @param {string} [q] 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationRolesGet: async (q?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/organization-roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete organization role by ID.
         * @summary Delete organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationRolesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationRolesIdDelete', 'id', id)
            const localVarPath = `/api/organization-roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get organization role details by ID.
         * @summary Get organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationRolesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationRolesIdGet', 'id', id)
            const localVarPath = `/api/organization-roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update organization role details by ID with the given data.
         * @summary Update organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {ApiOrganizationRolesIdPatchRequest} apiOrganizationRolesIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationRolesIdPatch: async (id: string, apiOrganizationRolesIdPatchRequest: ApiOrganizationRolesIdPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationRolesIdPatch', 'id', id)
            // verify required parameter 'apiOrganizationRolesIdPatchRequest' is not null or undefined
            assertParamExists('apiOrganizationRolesIdPatch', 'apiOrganizationRolesIdPatchRequest', apiOrganizationRolesIdPatchRequest)
            const localVarPath = `/api/organization-roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiOrganizationRolesIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all resource scopes that are assigned to the specified organization role.
         * @summary Get organization role resource scopes
         * @param {string} id The unique identifier of the organization role.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationRolesIdResourceScopesGet: async (id: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationRolesIdResourceScopesGet', 'id', id)
            const localVarPath = `/api/organization-roles/{id}/resource-scopes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign resource scopes to the specified organization role
         * @summary Assign resource scopes to organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {ApiOrganizationRolesIdResourceScopesPostRequest} apiOrganizationRolesIdResourceScopesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationRolesIdResourceScopesPost: async (id: string, apiOrganizationRolesIdResourceScopesPostRequest: ApiOrganizationRolesIdResourceScopesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationRolesIdResourceScopesPost', 'id', id)
            // verify required parameter 'apiOrganizationRolesIdResourceScopesPostRequest' is not null or undefined
            assertParamExists('apiOrganizationRolesIdResourceScopesPost', 'apiOrganizationRolesIdResourceScopesPostRequest', apiOrganizationRolesIdResourceScopesPostRequest)
            const localVarPath = `/api/organization-roles/{id}/resource-scopes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiOrganizationRolesIdResourceScopesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace all resource scopes that are assigned to the specified organization role with the given resource scopes. This effectively removes all existing organization scope assignments and replaces them with the new ones.
         * @summary Replace resource scopes for organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {ApiOrganizationRolesIdResourceScopesPutRequest} apiOrganizationRolesIdResourceScopesPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationRolesIdResourceScopesPut: async (id: string, apiOrganizationRolesIdResourceScopesPutRequest: ApiOrganizationRolesIdResourceScopesPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationRolesIdResourceScopesPut', 'id', id)
            // verify required parameter 'apiOrganizationRolesIdResourceScopesPutRequest' is not null or undefined
            assertParamExists('apiOrganizationRolesIdResourceScopesPut', 'apiOrganizationRolesIdResourceScopesPutRequest', apiOrganizationRolesIdResourceScopesPutRequest)
            const localVarPath = `/api/organization-roles/{id}/resource-scopes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiOrganizationRolesIdResourceScopesPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a resource scope assignment from the specified organization role.
         * @summary Remove resource scope
         * @param {string} id The unique identifier of the organization role.
         * @param {string} scopeId The unique identifier of the scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationRolesIdResourceScopesScopeIdDelete: async (id: string, scopeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationRolesIdResourceScopesScopeIdDelete', 'id', id)
            // verify required parameter 'scopeId' is not null or undefined
            assertParamExists('apiOrganizationRolesIdResourceScopesScopeIdDelete', 'scopeId', scopeId)
            const localVarPath = `/api/organization-roles/{id}/resource-scopes/{scopeId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"scopeId"}}`, encodeURIComponent(String(scopeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all organization scopes that are assigned to the specified organization role.
         * @summary Get organization role scopes
         * @param {string} id The unique identifier of the organization role.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationRolesIdScopesGet: async (id: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationRolesIdScopesGet', 'id', id)
            const localVarPath = `/api/organization-roles/{id}/scopes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a organization scope assignment from the specified organization role.
         * @summary Remove organization scope
         * @param {string} id The unique identifier of the organization role.
         * @param {string} organizationScopeId The unique identifier of the organization scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationRolesIdScopesOrganizationScopeIdDelete: async (id: string, organizationScopeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationRolesIdScopesOrganizationScopeIdDelete', 'id', id)
            // verify required parameter 'organizationScopeId' is not null or undefined
            assertParamExists('apiOrganizationRolesIdScopesOrganizationScopeIdDelete', 'organizationScopeId', organizationScopeId)
            const localVarPath = `/api/organization-roles/{id}/scopes/{organizationScopeId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"organizationScopeId"}}`, encodeURIComponent(String(organizationScopeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign organization scopes to the specified organization role
         * @summary Assign organization scopes to organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {ApiOrganizationRolesIdScopesPostRequest} apiOrganizationRolesIdScopesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationRolesIdScopesPost: async (id: string, apiOrganizationRolesIdScopesPostRequest: ApiOrganizationRolesIdScopesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationRolesIdScopesPost', 'id', id)
            // verify required parameter 'apiOrganizationRolesIdScopesPostRequest' is not null or undefined
            assertParamExists('apiOrganizationRolesIdScopesPost', 'apiOrganizationRolesIdScopesPostRequest', apiOrganizationRolesIdScopesPostRequest)
            const localVarPath = `/api/organization-roles/{id}/scopes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiOrganizationRolesIdScopesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace all organization scopes that are assigned to the specified organization role with the given organization scopes. This effectively removes all existing organization scope assignments and replaces them with the new ones.
         * @summary Replace organization scopes for organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {ApiOrganizationRolesIdScopesPutRequest} apiOrganizationRolesIdScopesPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationRolesIdScopesPut: async (id: string, apiOrganizationRolesIdScopesPutRequest: ApiOrganizationRolesIdScopesPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationRolesIdScopesPut', 'id', id)
            // verify required parameter 'apiOrganizationRolesIdScopesPutRequest' is not null or undefined
            assertParamExists('apiOrganizationRolesIdScopesPut', 'apiOrganizationRolesIdScopesPutRequest', apiOrganizationRolesIdScopesPutRequest)
            const localVarPath = `/api/organization-roles/{id}/scopes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiOrganizationRolesIdScopesPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new organization role with the given data.
         * @summary Create an organization role
         * @param {ApiOrganizationRolesPostRequest} apiOrganizationRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationRolesPost: async (apiOrganizationRolesPostRequest: ApiOrganizationRolesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiOrganizationRolesPostRequest' is not null or undefined
            assertParamExists('apiOrganizationRolesPost', 'apiOrganizationRolesPostRequest', apiOrganizationRolesPostRequest)
            const localVarPath = `/api/organization-roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiOrganizationRolesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationRolesApi - functional programming interface
 * @export
 */
export const OrganizationRolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationRolesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get organization roles with pagination.
         * @summary Get organization roles
         * @param {string} [q] 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationRolesGet(q?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiOrganizationRolesGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationRolesGet(q, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationRolesApi.apiOrganizationRolesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete organization role by ID.
         * @summary Delete organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationRolesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationRolesIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationRolesApi.apiOrganizationRolesIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get organization role details by ID.
         * @summary Get organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationRolesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiApplicationsApplicationIdUserConsentScopesGet200ResponseOrganizationScopesInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationRolesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationRolesApi.apiOrganizationRolesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update organization role details by ID with the given data.
         * @summary Update organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {ApiOrganizationRolesIdPatchRequest} apiOrganizationRolesIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationRolesIdPatch(id: string, apiOrganizationRolesIdPatchRequest: ApiOrganizationRolesIdPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiApplicationsApplicationIdUserConsentScopesGet200ResponseOrganizationScopesInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationRolesIdPatch(id, apiOrganizationRolesIdPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationRolesApi.apiOrganizationRolesIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all resource scopes that are assigned to the specified organization role.
         * @summary Get organization role resource scopes
         * @param {string} id The unique identifier of the organization role.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationRolesIdResourceScopesGet(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiResourcesGet200ResponseInnerScopesInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationRolesIdResourceScopesGet(id, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationRolesApi.apiOrganizationRolesIdResourceScopesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Assign resource scopes to the specified organization role
         * @summary Assign resource scopes to organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {ApiOrganizationRolesIdResourceScopesPostRequest} apiOrganizationRolesIdResourceScopesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationRolesIdResourceScopesPost(id: string, apiOrganizationRolesIdResourceScopesPostRequest: ApiOrganizationRolesIdResourceScopesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationRolesIdResourceScopesPost(id, apiOrganizationRolesIdResourceScopesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationRolesApi.apiOrganizationRolesIdResourceScopesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replace all resource scopes that are assigned to the specified organization role with the given resource scopes. This effectively removes all existing organization scope assignments and replaces them with the new ones.
         * @summary Replace resource scopes for organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {ApiOrganizationRolesIdResourceScopesPutRequest} apiOrganizationRolesIdResourceScopesPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationRolesIdResourceScopesPut(id: string, apiOrganizationRolesIdResourceScopesPutRequest: ApiOrganizationRolesIdResourceScopesPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationRolesIdResourceScopesPut(id, apiOrganizationRolesIdResourceScopesPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationRolesApi.apiOrganizationRolesIdResourceScopesPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a resource scope assignment from the specified organization role.
         * @summary Remove resource scope
         * @param {string} id The unique identifier of the organization role.
         * @param {string} scopeId The unique identifier of the scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationRolesIdResourceScopesScopeIdDelete(id: string, scopeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationRolesIdResourceScopesScopeIdDelete(id, scopeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationRolesApi.apiOrganizationRolesIdResourceScopesScopeIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all organization scopes that are assigned to the specified organization role.
         * @summary Get organization role scopes
         * @param {string} id The unique identifier of the organization role.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationRolesIdScopesGet(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiApplicationsApplicationIdUserConsentScopesGet200ResponseOrganizationScopesInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationRolesIdScopesGet(id, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationRolesApi.apiOrganizationRolesIdScopesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a organization scope assignment from the specified organization role.
         * @summary Remove organization scope
         * @param {string} id The unique identifier of the organization role.
         * @param {string} organizationScopeId The unique identifier of the organization scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationRolesIdScopesOrganizationScopeIdDelete(id: string, organizationScopeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationRolesIdScopesOrganizationScopeIdDelete(id, organizationScopeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationRolesApi.apiOrganizationRolesIdScopesOrganizationScopeIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Assign organization scopes to the specified organization role
         * @summary Assign organization scopes to organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {ApiOrganizationRolesIdScopesPostRequest} apiOrganizationRolesIdScopesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationRolesIdScopesPost(id: string, apiOrganizationRolesIdScopesPostRequest: ApiOrganizationRolesIdScopesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationRolesIdScopesPost(id, apiOrganizationRolesIdScopesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationRolesApi.apiOrganizationRolesIdScopesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replace all organization scopes that are assigned to the specified organization role with the given organization scopes. This effectively removes all existing organization scope assignments and replaces them with the new ones.
         * @summary Replace organization scopes for organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {ApiOrganizationRolesIdScopesPutRequest} apiOrganizationRolesIdScopesPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationRolesIdScopesPut(id: string, apiOrganizationRolesIdScopesPutRequest: ApiOrganizationRolesIdScopesPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationRolesIdScopesPut(id, apiOrganizationRolesIdScopesPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationRolesApi.apiOrganizationRolesIdScopesPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new organization role with the given data.
         * @summary Create an organization role
         * @param {ApiOrganizationRolesPostRequest} apiOrganizationRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationRolesPost(apiOrganizationRolesPostRequest: ApiOrganizationRolesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationRolesPost(apiOrganizationRolesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationRolesApi.apiOrganizationRolesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationRolesApi - factory interface
 * @export
 */
export const OrganizationRolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationRolesApiFp(configuration)
    return {
        /**
         * Get organization roles with pagination.
         * @summary Get organization roles
         * @param {string} [q] 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationRolesGet(q?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ApiOrganizationRolesGet200ResponseInner>> {
            return localVarFp.apiOrganizationRolesGet(q, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete organization role by ID.
         * @summary Delete organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationRolesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationRolesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organization role details by ID.
         * @summary Get organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationRolesIdGet(id: string, options?: any): AxiosPromise<ApiApplicationsApplicationIdUserConsentScopesGet200ResponseOrganizationScopesInner> {
            return localVarFp.apiOrganizationRolesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update organization role details by ID with the given data.
         * @summary Update organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {ApiOrganizationRolesIdPatchRequest} apiOrganizationRolesIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationRolesIdPatch(id: string, apiOrganizationRolesIdPatchRequest: ApiOrganizationRolesIdPatchRequest, options?: any): AxiosPromise<ApiApplicationsApplicationIdUserConsentScopesGet200ResponseOrganizationScopesInner> {
            return localVarFp.apiOrganizationRolesIdPatch(id, apiOrganizationRolesIdPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all resource scopes that are assigned to the specified organization role.
         * @summary Get organization role resource scopes
         * @param {string} id The unique identifier of the organization role.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationRolesIdResourceScopesGet(id: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ApiResourcesGet200ResponseInnerScopesInner>> {
            return localVarFp.apiOrganizationRolesIdResourceScopesGet(id, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign resource scopes to the specified organization role
         * @summary Assign resource scopes to organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {ApiOrganizationRolesIdResourceScopesPostRequest} apiOrganizationRolesIdResourceScopesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationRolesIdResourceScopesPost(id: string, apiOrganizationRolesIdResourceScopesPostRequest: ApiOrganizationRolesIdResourceScopesPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationRolesIdResourceScopesPost(id, apiOrganizationRolesIdResourceScopesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace all resource scopes that are assigned to the specified organization role with the given resource scopes. This effectively removes all existing organization scope assignments and replaces them with the new ones.
         * @summary Replace resource scopes for organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {ApiOrganizationRolesIdResourceScopesPutRequest} apiOrganizationRolesIdResourceScopesPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationRolesIdResourceScopesPut(id: string, apiOrganizationRolesIdResourceScopesPutRequest: ApiOrganizationRolesIdResourceScopesPutRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationRolesIdResourceScopesPut(id, apiOrganizationRolesIdResourceScopesPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a resource scope assignment from the specified organization role.
         * @summary Remove resource scope
         * @param {string} id The unique identifier of the organization role.
         * @param {string} scopeId The unique identifier of the scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationRolesIdResourceScopesScopeIdDelete(id: string, scopeId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationRolesIdResourceScopesScopeIdDelete(id, scopeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all organization scopes that are assigned to the specified organization role.
         * @summary Get organization role scopes
         * @param {string} id The unique identifier of the organization role.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationRolesIdScopesGet(id: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ApiApplicationsApplicationIdUserConsentScopesGet200ResponseOrganizationScopesInner>> {
            return localVarFp.apiOrganizationRolesIdScopesGet(id, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a organization scope assignment from the specified organization role.
         * @summary Remove organization scope
         * @param {string} id The unique identifier of the organization role.
         * @param {string} organizationScopeId The unique identifier of the organization scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationRolesIdScopesOrganizationScopeIdDelete(id: string, organizationScopeId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationRolesIdScopesOrganizationScopeIdDelete(id, organizationScopeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign organization scopes to the specified organization role
         * @summary Assign organization scopes to organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {ApiOrganizationRolesIdScopesPostRequest} apiOrganizationRolesIdScopesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationRolesIdScopesPost(id: string, apiOrganizationRolesIdScopesPostRequest: ApiOrganizationRolesIdScopesPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationRolesIdScopesPost(id, apiOrganizationRolesIdScopesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace all organization scopes that are assigned to the specified organization role with the given organization scopes. This effectively removes all existing organization scope assignments and replaces them with the new ones.
         * @summary Replace organization scopes for organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {ApiOrganizationRolesIdScopesPutRequest} apiOrganizationRolesIdScopesPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationRolesIdScopesPut(id: string, apiOrganizationRolesIdScopesPutRequest: ApiOrganizationRolesIdScopesPutRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationRolesIdScopesPut(id, apiOrganizationRolesIdScopesPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new organization role with the given data.
         * @summary Create an organization role
         * @param {ApiOrganizationRolesPostRequest} apiOrganizationRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationRolesPost(apiOrganizationRolesPostRequest: ApiOrganizationRolesPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationRolesPost(apiOrganizationRolesPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationRolesApi - object-oriented interface
 * @export
 * @class OrganizationRolesApi
 * @extends {BaseAPI}
 */
export class OrganizationRolesApi extends BaseAPI {
    /**
     * Get organization roles with pagination.
     * @summary Get organization roles
     * @param {string} [q] 
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRolesApi
     */
    public apiOrganizationRolesGet(q?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return OrganizationRolesApiFp(this.configuration).apiOrganizationRolesGet(q, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete organization role by ID.
     * @summary Delete organization role
     * @param {string} id The unique identifier of the organization role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRolesApi
     */
    public apiOrganizationRolesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return OrganizationRolesApiFp(this.configuration).apiOrganizationRolesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get organization role details by ID.
     * @summary Get organization role
     * @param {string} id The unique identifier of the organization role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRolesApi
     */
    public apiOrganizationRolesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return OrganizationRolesApiFp(this.configuration).apiOrganizationRolesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update organization role details by ID with the given data.
     * @summary Update organization role
     * @param {string} id The unique identifier of the organization role.
     * @param {ApiOrganizationRolesIdPatchRequest} apiOrganizationRolesIdPatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRolesApi
     */
    public apiOrganizationRolesIdPatch(id: string, apiOrganizationRolesIdPatchRequest: ApiOrganizationRolesIdPatchRequest, options?: RawAxiosRequestConfig) {
        return OrganizationRolesApiFp(this.configuration).apiOrganizationRolesIdPatch(id, apiOrganizationRolesIdPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all resource scopes that are assigned to the specified organization role.
     * @summary Get organization role resource scopes
     * @param {string} id The unique identifier of the organization role.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRolesApi
     */
    public apiOrganizationRolesIdResourceScopesGet(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return OrganizationRolesApiFp(this.configuration).apiOrganizationRolesIdResourceScopesGet(id, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assign resource scopes to the specified organization role
     * @summary Assign resource scopes to organization role
     * @param {string} id The unique identifier of the organization role.
     * @param {ApiOrganizationRolesIdResourceScopesPostRequest} apiOrganizationRolesIdResourceScopesPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRolesApi
     */
    public apiOrganizationRolesIdResourceScopesPost(id: string, apiOrganizationRolesIdResourceScopesPostRequest: ApiOrganizationRolesIdResourceScopesPostRequest, options?: RawAxiosRequestConfig) {
        return OrganizationRolesApiFp(this.configuration).apiOrganizationRolesIdResourceScopesPost(id, apiOrganizationRolesIdResourceScopesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace all resource scopes that are assigned to the specified organization role with the given resource scopes. This effectively removes all existing organization scope assignments and replaces them with the new ones.
     * @summary Replace resource scopes for organization role
     * @param {string} id The unique identifier of the organization role.
     * @param {ApiOrganizationRolesIdResourceScopesPutRequest} apiOrganizationRolesIdResourceScopesPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRolesApi
     */
    public apiOrganizationRolesIdResourceScopesPut(id: string, apiOrganizationRolesIdResourceScopesPutRequest: ApiOrganizationRolesIdResourceScopesPutRequest, options?: RawAxiosRequestConfig) {
        return OrganizationRolesApiFp(this.configuration).apiOrganizationRolesIdResourceScopesPut(id, apiOrganizationRolesIdResourceScopesPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a resource scope assignment from the specified organization role.
     * @summary Remove resource scope
     * @param {string} id The unique identifier of the organization role.
     * @param {string} scopeId The unique identifier of the scope.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRolesApi
     */
    public apiOrganizationRolesIdResourceScopesScopeIdDelete(id: string, scopeId: string, options?: RawAxiosRequestConfig) {
        return OrganizationRolesApiFp(this.configuration).apiOrganizationRolesIdResourceScopesScopeIdDelete(id, scopeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all organization scopes that are assigned to the specified organization role.
     * @summary Get organization role scopes
     * @param {string} id The unique identifier of the organization role.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRolesApi
     */
    public apiOrganizationRolesIdScopesGet(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return OrganizationRolesApiFp(this.configuration).apiOrganizationRolesIdScopesGet(id, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a organization scope assignment from the specified organization role.
     * @summary Remove organization scope
     * @param {string} id The unique identifier of the organization role.
     * @param {string} organizationScopeId The unique identifier of the organization scope.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRolesApi
     */
    public apiOrganizationRolesIdScopesOrganizationScopeIdDelete(id: string, organizationScopeId: string, options?: RawAxiosRequestConfig) {
        return OrganizationRolesApiFp(this.configuration).apiOrganizationRolesIdScopesOrganizationScopeIdDelete(id, organizationScopeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assign organization scopes to the specified organization role
     * @summary Assign organization scopes to organization role
     * @param {string} id The unique identifier of the organization role.
     * @param {ApiOrganizationRolesIdScopesPostRequest} apiOrganizationRolesIdScopesPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRolesApi
     */
    public apiOrganizationRolesIdScopesPost(id: string, apiOrganizationRolesIdScopesPostRequest: ApiOrganizationRolesIdScopesPostRequest, options?: RawAxiosRequestConfig) {
        return OrganizationRolesApiFp(this.configuration).apiOrganizationRolesIdScopesPost(id, apiOrganizationRolesIdScopesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace all organization scopes that are assigned to the specified organization role with the given organization scopes. This effectively removes all existing organization scope assignments and replaces them with the new ones.
     * @summary Replace organization scopes for organization role
     * @param {string} id The unique identifier of the organization role.
     * @param {ApiOrganizationRolesIdScopesPutRequest} apiOrganizationRolesIdScopesPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRolesApi
     */
    public apiOrganizationRolesIdScopesPut(id: string, apiOrganizationRolesIdScopesPutRequest: ApiOrganizationRolesIdScopesPutRequest, options?: RawAxiosRequestConfig) {
        return OrganizationRolesApiFp(this.configuration).apiOrganizationRolesIdScopesPut(id, apiOrganizationRolesIdScopesPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new organization role with the given data.
     * @summary Create an organization role
     * @param {ApiOrganizationRolesPostRequest} apiOrganizationRolesPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRolesApi
     */
    public apiOrganizationRolesPost(apiOrganizationRolesPostRequest: ApiOrganizationRolesPostRequest, options?: RawAxiosRequestConfig) {
        return OrganizationRolesApiFp(this.configuration).apiOrganizationRolesPost(apiOrganizationRolesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationScopesApi - axios parameter creator
 * @export
 */
export const OrganizationScopesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get organization scopes that match with pagination.
         * @summary Get organization scopes
         * @param {string} [q] 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationScopesGet: async (q?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/organization-scopes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete organization scope by ID.
         * @summary Delete organization scope
         * @param {string} id The unique identifier of the organization scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationScopesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationScopesIdDelete', 'id', id)
            const localVarPath = `/api/organization-scopes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get organization scope details by ID.
         * @summary Get organization scope
         * @param {string} id The unique identifier of the organization scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationScopesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationScopesIdGet', 'id', id)
            const localVarPath = `/api/organization-scopes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update organization scope details by ID with the given data.
         * @summary Update organization scope
         * @param {string} id The unique identifier of the organization scope.
         * @param {ApiOrganizationScopesIdPatchRequest} apiOrganizationScopesIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationScopesIdPatch: async (id: string, apiOrganizationScopesIdPatchRequest: ApiOrganizationScopesIdPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationScopesIdPatch', 'id', id)
            // verify required parameter 'apiOrganizationScopesIdPatchRequest' is not null or undefined
            assertParamExists('apiOrganizationScopesIdPatch', 'apiOrganizationScopesIdPatchRequest', apiOrganizationScopesIdPatchRequest)
            const localVarPath = `/api/organization-scopes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiOrganizationScopesIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new organization scope with the given data.
         * @summary Create an organization scope
         * @param {ApiOrganizationScopesPostRequest} apiOrganizationScopesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationScopesPost: async (apiOrganizationScopesPostRequest: ApiOrganizationScopesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiOrganizationScopesPostRequest' is not null or undefined
            assertParamExists('apiOrganizationScopesPost', 'apiOrganizationScopesPostRequest', apiOrganizationScopesPostRequest)
            const localVarPath = `/api/organization-scopes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiOrganizationScopesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationScopesApi - functional programming interface
 * @export
 */
export const OrganizationScopesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationScopesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get organization scopes that match with pagination.
         * @summary Get organization scopes
         * @param {string} [q] 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationScopesGet(q?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiApplicationsApplicationIdUserConsentScopesGet200ResponseOrganizationScopesInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationScopesGet(q, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationScopesApi.apiOrganizationScopesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete organization scope by ID.
         * @summary Delete organization scope
         * @param {string} id The unique identifier of the organization scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationScopesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationScopesIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationScopesApi.apiOrganizationScopesIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get organization scope details by ID.
         * @summary Get organization scope
         * @param {string} id The unique identifier of the organization scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationScopesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiApplicationsApplicationIdUserConsentScopesGet200ResponseOrganizationScopesInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationScopesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationScopesApi.apiOrganizationScopesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update organization scope details by ID with the given data.
         * @summary Update organization scope
         * @param {string} id The unique identifier of the organization scope.
         * @param {ApiOrganizationScopesIdPatchRequest} apiOrganizationScopesIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationScopesIdPatch(id: string, apiOrganizationScopesIdPatchRequest: ApiOrganizationScopesIdPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiApplicationsApplicationIdUserConsentScopesGet200ResponseOrganizationScopesInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationScopesIdPatch(id, apiOrganizationScopesIdPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationScopesApi.apiOrganizationScopesIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new organization scope with the given data.
         * @summary Create an organization scope
         * @param {ApiOrganizationScopesPostRequest} apiOrganizationScopesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationScopesPost(apiOrganizationScopesPostRequest: ApiOrganizationScopesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationScopesPost(apiOrganizationScopesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationScopesApi.apiOrganizationScopesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationScopesApi - factory interface
 * @export
 */
export const OrganizationScopesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationScopesApiFp(configuration)
    return {
        /**
         * Get organization scopes that match with pagination.
         * @summary Get organization scopes
         * @param {string} [q] 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationScopesGet(q?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ApiApplicationsApplicationIdUserConsentScopesGet200ResponseOrganizationScopesInner>> {
            return localVarFp.apiOrganizationScopesGet(q, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete organization scope by ID.
         * @summary Delete organization scope
         * @param {string} id The unique identifier of the organization scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationScopesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationScopesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organization scope details by ID.
         * @summary Get organization scope
         * @param {string} id The unique identifier of the organization scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationScopesIdGet(id: string, options?: any): AxiosPromise<ApiApplicationsApplicationIdUserConsentScopesGet200ResponseOrganizationScopesInner> {
            return localVarFp.apiOrganizationScopesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update organization scope details by ID with the given data.
         * @summary Update organization scope
         * @param {string} id The unique identifier of the organization scope.
         * @param {ApiOrganizationScopesIdPatchRequest} apiOrganizationScopesIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationScopesIdPatch(id: string, apiOrganizationScopesIdPatchRequest: ApiOrganizationScopesIdPatchRequest, options?: any): AxiosPromise<ApiApplicationsApplicationIdUserConsentScopesGet200ResponseOrganizationScopesInner> {
            return localVarFp.apiOrganizationScopesIdPatch(id, apiOrganizationScopesIdPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new organization scope with the given data.
         * @summary Create an organization scope
         * @param {ApiOrganizationScopesPostRequest} apiOrganizationScopesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationScopesPost(apiOrganizationScopesPostRequest: ApiOrganizationScopesPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationScopesPost(apiOrganizationScopesPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationScopesApi - object-oriented interface
 * @export
 * @class OrganizationScopesApi
 * @extends {BaseAPI}
 */
export class OrganizationScopesApi extends BaseAPI {
    /**
     * Get organization scopes that match with pagination.
     * @summary Get organization scopes
     * @param {string} [q] 
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationScopesApi
     */
    public apiOrganizationScopesGet(q?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return OrganizationScopesApiFp(this.configuration).apiOrganizationScopesGet(q, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete organization scope by ID.
     * @summary Delete organization scope
     * @param {string} id The unique identifier of the organization scope.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationScopesApi
     */
    public apiOrganizationScopesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return OrganizationScopesApiFp(this.configuration).apiOrganizationScopesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get organization scope details by ID.
     * @summary Get organization scope
     * @param {string} id The unique identifier of the organization scope.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationScopesApi
     */
    public apiOrganizationScopesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return OrganizationScopesApiFp(this.configuration).apiOrganizationScopesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update organization scope details by ID with the given data.
     * @summary Update organization scope
     * @param {string} id The unique identifier of the organization scope.
     * @param {ApiOrganizationScopesIdPatchRequest} apiOrganizationScopesIdPatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationScopesApi
     */
    public apiOrganizationScopesIdPatch(id: string, apiOrganizationScopesIdPatchRequest: ApiOrganizationScopesIdPatchRequest, options?: RawAxiosRequestConfig) {
        return OrganizationScopesApiFp(this.configuration).apiOrganizationScopesIdPatch(id, apiOrganizationScopesIdPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new organization scope with the given data.
     * @summary Create an organization scope
     * @param {ApiOrganizationScopesPostRequest} apiOrganizationScopesPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationScopesApi
     */
    public apiOrganizationScopesPost(apiOrganizationScopesPostRequest: ApiOrganizationScopesPostRequest, options?: RawAxiosRequestConfig) {
        return OrganizationScopesApiFp(this.configuration).apiOrganizationScopesPost(apiOrganizationScopesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationsApi - axios parameter creator
 * @export
 */
export const OrganizationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get organizations that match the given query with pagination.
         * @summary Get organizations
         * @param {string} [q] The query to filter organizations. It can be a partial ID or name.  If not provided, all organizations will be returned.
         * @param {string} [showFeatured] Whether to show featured users in the organization. Featured users are randomly selected from the organization members.  If not provided, &#x60;featuredUsers&#x60; will not be included in the response.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsGet: async (q?: string, showFeatured?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (showFeatured !== undefined) {
                localVarQueryParameter['showFeatured'] = showFeatured;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete organization by ID.
         * @summary Delete organization
         * @param {string} id The unique identifier of the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdDelete', 'id', id)
            const localVarPath = `/api/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get organization details by ID.
         * @summary Get organization
         * @param {string} id The unique identifier of the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdGet', 'id', id)
            const localVarPath = `/api/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an email domain for just-in-time provisioning of users in the organization.
         * @summary Remove organization JIT email domain
         * @param {string} id The unique identifier of the organization.
         * @param {string} emailDomain The email domain to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdJitEmailDomainsEmailDomainDelete: async (id: string, emailDomain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdJitEmailDomainsEmailDomainDelete', 'id', id)
            // verify required parameter 'emailDomain' is not null or undefined
            assertParamExists('apiOrganizationsIdJitEmailDomainsEmailDomainDelete', 'emailDomain', emailDomain)
            const localVarPath = `/api/organizations/{id}/jit/email-domains/{emailDomain}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"emailDomain"}}`, encodeURIComponent(String(emailDomain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get email domains for just-in-time provisioning of users in the organization.
         * @summary Get organization JIT email domains
         * @param {string} id The unique identifier of the organization.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdJitEmailDomainsGet: async (id: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdJitEmailDomainsGet', 'id', id)
            const localVarPath = `/api/organizations/{id}/jit/email-domains`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new email domain for just-in-time provisioning of users in the organization.
         * @summary Add organization JIT email domain
         * @param {string} id The unique identifier of the organization.
         * @param {ApiOrganizationsIdJitEmailDomainsPostRequest} apiOrganizationsIdJitEmailDomainsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdJitEmailDomainsPost: async (id: string, apiOrganizationsIdJitEmailDomainsPostRequest: ApiOrganizationsIdJitEmailDomainsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdJitEmailDomainsPost', 'id', id)
            // verify required parameter 'apiOrganizationsIdJitEmailDomainsPostRequest' is not null or undefined
            assertParamExists('apiOrganizationsIdJitEmailDomainsPost', 'apiOrganizationsIdJitEmailDomainsPostRequest', apiOrganizationsIdJitEmailDomainsPostRequest)
            const localVarPath = `/api/organizations/{id}/jit/email-domains`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiOrganizationsIdJitEmailDomainsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace all just-in-time provisioning email domains for the organization with the given data.
         * @summary Replace organization JIT email domains
         * @param {string} id The unique identifier of the organization.
         * @param {ApiOrganizationsIdJitEmailDomainsPutRequest} apiOrganizationsIdJitEmailDomainsPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdJitEmailDomainsPut: async (id: string, apiOrganizationsIdJitEmailDomainsPutRequest: ApiOrganizationsIdJitEmailDomainsPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdJitEmailDomainsPut', 'id', id)
            // verify required parameter 'apiOrganizationsIdJitEmailDomainsPutRequest' is not null or undefined
            assertParamExists('apiOrganizationsIdJitEmailDomainsPut', 'apiOrganizationsIdJitEmailDomainsPutRequest', apiOrganizationsIdJitEmailDomainsPutRequest)
            const localVarPath = `/api/organizations/{id}/jit/email-domains`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiOrganizationsIdJitEmailDomainsPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get organization roles that will be assigned to users during just-in-time provisioning.
         * @summary Get organization JIT default roles
         * @param {string} id The unique identifier of the organization.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdJitRolesGet: async (id: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdJitRolesGet', 'id', id)
            const localVarPath = `/api/organizations/{id}/jit/roles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an organization role that will be assigned to users during just-in-time provisioning.
         * @summary Remove organization JIT default role
         * @param {string} id The unique identifier of the organization.
         * @param {string} organizationRoleId The unique identifier of the organization role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdJitRolesOrganizationRoleIdDelete: async (id: string, organizationRoleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdJitRolesOrganizationRoleIdDelete', 'id', id)
            // verify required parameter 'organizationRoleId' is not null or undefined
            assertParamExists('apiOrganizationsIdJitRolesOrganizationRoleIdDelete', 'organizationRoleId', organizationRoleId)
            const localVarPath = `/api/organizations/{id}/jit/roles/{organizationRoleId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"organizationRoleId"}}`, encodeURIComponent(String(organizationRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add new organization roles that will be assigned to users during just-in-time provisioning.
         * @summary Add organization JIT default roles
         * @param {string} id The unique identifier of the organization.
         * @param {ApiOrganizationsIdJitRolesPostRequest} apiOrganizationsIdJitRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdJitRolesPost: async (id: string, apiOrganizationsIdJitRolesPostRequest: ApiOrganizationsIdJitRolesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdJitRolesPost', 'id', id)
            // verify required parameter 'apiOrganizationsIdJitRolesPostRequest' is not null or undefined
            assertParamExists('apiOrganizationsIdJitRolesPost', 'apiOrganizationsIdJitRolesPostRequest', apiOrganizationsIdJitRolesPostRequest)
            const localVarPath = `/api/organizations/{id}/jit/roles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiOrganizationsIdJitRolesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace all organization roles that will be assigned to users during just-in-time provisioning with the given data.
         * @summary Replace organization JIT default roles
         * @param {string} id The unique identifier of the organization.
         * @param {ApiOrganizationsIdJitRolesPutRequest} apiOrganizationsIdJitRolesPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdJitRolesPut: async (id: string, apiOrganizationsIdJitRolesPutRequest: ApiOrganizationsIdJitRolesPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdJitRolesPut', 'id', id)
            // verify required parameter 'apiOrganizationsIdJitRolesPutRequest' is not null or undefined
            assertParamExists('apiOrganizationsIdJitRolesPut', 'apiOrganizationsIdJitRolesPutRequest', apiOrganizationsIdJitRolesPutRequest)
            const localVarPath = `/api/organizations/{id}/jit/roles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiOrganizationsIdJitRolesPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update organization details by ID with the given data.
         * @summary Update organization
         * @param {string} id The unique identifier of the organization.
         * @param {ApiOrganizationsIdPatchRequest} apiOrganizationsIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdPatch: async (id: string, apiOrganizationsIdPatchRequest: ApiOrganizationsIdPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdPatch', 'id', id)
            // verify required parameter 'apiOrganizationsIdPatchRequest' is not null or undefined
            assertParamExists('apiOrganizationsIdPatch', 'apiOrganizationsIdPatchRequest', apiOrganizationsIdPatchRequest)
            const localVarPath = `/api/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiOrganizationsIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get users that are members of the specified organization for the given query with pagination.
         * @summary Get organization user members
         * @param {string} id The unique identifier of the organization.
         * @param {string} [q] The query to filter users. It will match multiple fields of users, including ID, name, username, email, and phone number.  If not provided, all users will be returned.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdUsersGet: async (id: string, q?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdUsersGet', 'id', id)
            const localVarPath = `/api/organizations/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add users as members to the specified organization with the given user IDs.
         * @summary Add user members to organization
         * @param {string} id The unique identifier of the organization.
         * @param {ApiOrganizationsIdUsersPostRequest} apiOrganizationsIdUsersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdUsersPost: async (id: string, apiOrganizationsIdUsersPostRequest: ApiOrganizationsIdUsersPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdUsersPost', 'id', id)
            // verify required parameter 'apiOrganizationsIdUsersPostRequest' is not null or undefined
            assertParamExists('apiOrganizationsIdUsersPost', 'apiOrganizationsIdUsersPostRequest', apiOrganizationsIdUsersPostRequest)
            const localVarPath = `/api/organizations/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiOrganizationsIdUsersPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace all user members for the specified organization with the given users. This effectively removing all existing user memberships in the organization and adding the new users as members.
         * @summary Replace organization user members
         * @param {string} id The unique identifier of the organization.
         * @param {ApiOrganizationsIdUsersPutRequest} apiOrganizationsIdUsersPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdUsersPut: async (id: string, apiOrganizationsIdUsersPutRequest: ApiOrganizationsIdUsersPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdUsersPut', 'id', id)
            // verify required parameter 'apiOrganizationsIdUsersPutRequest' is not null or undefined
            assertParamExists('apiOrganizationsIdUsersPut', 'apiOrganizationsIdUsersPutRequest', apiOrganizationsIdUsersPutRequest)
            const localVarPath = `/api/organizations/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiOrganizationsIdUsersPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign roles to user members of the specified organization with the given data.
         * @summary Assign roles to organization user members
         * @param {string} id The unique identifier of the organization.
         * @param {ApiOrganizationsIdUsersRolesPostRequest} apiOrganizationsIdUsersRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdUsersRolesPost: async (id: string, apiOrganizationsIdUsersRolesPostRequest: ApiOrganizationsIdUsersRolesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdUsersRolesPost', 'id', id)
            // verify required parameter 'apiOrganizationsIdUsersRolesPostRequest' is not null or undefined
            assertParamExists('apiOrganizationsIdUsersRolesPost', 'apiOrganizationsIdUsersRolesPostRequest', apiOrganizationsIdUsersRolesPostRequest)
            const localVarPath = `/api/organizations/{id}/users/roles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiOrganizationsIdUsersRolesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a user\'s membership from the specified organization.
         * @summary Remove user member from organization
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdUsersUserIdDelete: async (id: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdUsersUserIdDelete', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiOrganizationsIdUsersUserIdDelete', 'userId', userId)
            const localVarPath = `/api/organizations/{id}/users/{userId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get roles assigned to a user in the specified organization with pagination.
         * @summary Get roles for a user in an organization
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdUsersUserIdRolesGet: async (id: string, userId: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdUsersUserIdRolesGet', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiOrganizationsIdUsersUserIdRolesGet', 'userId', userId)
            const localVarPath = `/api/organizations/{id}/users/{userId}/roles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign roles to a user in the specified organization with the provided data.
         * @summary Assign roles to a user in an organization
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {ApiOrganizationsIdUsersUserIdRolesPostRequest} apiOrganizationsIdUsersUserIdRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdUsersUserIdRolesPost: async (id: string, userId: string, apiOrganizationsIdUsersUserIdRolesPostRequest: ApiOrganizationsIdUsersUserIdRolesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdUsersUserIdRolesPost', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiOrganizationsIdUsersUserIdRolesPost', 'userId', userId)
            // verify required parameter 'apiOrganizationsIdUsersUserIdRolesPostRequest' is not null or undefined
            assertParamExists('apiOrganizationsIdUsersUserIdRolesPost', 'apiOrganizationsIdUsersUserIdRolesPostRequest', apiOrganizationsIdUsersUserIdRolesPostRequest)
            const localVarPath = `/api/organizations/{id}/users/{userId}/roles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiOrganizationsIdUsersUserIdRolesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update roles assigned to a user in the specified organization with the provided data.
         * @summary Update roles for a user in an organization
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {ApiOrganizationsIdUsersUserIdRolesPutRequest} apiOrganizationsIdUsersUserIdRolesPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdUsersUserIdRolesPut: async (id: string, userId: string, apiOrganizationsIdUsersUserIdRolesPutRequest: ApiOrganizationsIdUsersUserIdRolesPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdUsersUserIdRolesPut', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiOrganizationsIdUsersUserIdRolesPut', 'userId', userId)
            // verify required parameter 'apiOrganizationsIdUsersUserIdRolesPutRequest' is not null or undefined
            assertParamExists('apiOrganizationsIdUsersUserIdRolesPut', 'apiOrganizationsIdUsersUserIdRolesPutRequest', apiOrganizationsIdUsersUserIdRolesPutRequest)
            const localVarPath = `/api/organizations/{id}/users/{userId}/roles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiOrganizationsIdUsersUserIdRolesPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a role assignment from a user in the specified organization.
         * @summary Remove a role from a user in an organization
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {string} roleId The unique identifier of the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdUsersUserIdRolesRoleIdDelete: async (id: string, userId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdUsersUserIdRolesRoleIdDelete', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiOrganizationsIdUsersUserIdRolesRoleIdDelete', 'userId', userId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('apiOrganizationsIdUsersUserIdRolesRoleIdDelete', 'roleId', roleId)
            const localVarPath = `/api/organizations/{id}/users/{userId}/roles/{roleId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get scopes assigned to a user in the specified organization tailored by the organization roles. The scopes are derived from the organization roles assigned to the user.
         * @summary Get scopes for a user in an organization tailored by the organization roles
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdUsersUserIdScopesGet: async (id: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdUsersUserIdScopesGet', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiOrganizationsIdUsersUserIdScopesGet', 'userId', userId)
            const localVarPath = `/api/organizations/{id}/users/{userId}/scopes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new organization with the given data.
         * @summary Create an organization
         * @param {ApiOrganizationsPostRequest} apiOrganizationsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsPost: async (apiOrganizationsPostRequest: ApiOrganizationsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiOrganizationsPostRequest' is not null or undefined
            assertParamExists('apiOrganizationsPost', 'apiOrganizationsPostRequest', apiOrganizationsPostRequest)
            const localVarPath = `/api/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiOrganizationsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationsApi - functional programming interface
 * @export
 */
export const OrganizationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get organizations that match the given query with pagination.
         * @summary Get organizations
         * @param {string} [q] The query to filter organizations. It can be a partial ID or name.  If not provided, all organizations will be returned.
         * @param {string} [showFeatured] Whether to show featured users in the organization. Featured users are randomly selected from the organization members.  If not provided, &#x60;featuredUsers&#x60; will not be included in the response.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsGet(q?: string, showFeatured?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiOrganizationsGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsGet(q, showFeatured, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.apiOrganizationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete organization by ID.
         * @summary Delete organization
         * @param {string} id The unique identifier of the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.apiOrganizationsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get organization details by ID.
         * @summary Get organization
         * @param {string} id The unique identifier of the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiApplicationsIdUsersUserIdConsentOrganizationsGet200ResponseOrganizationsInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.apiOrganizationsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove an email domain for just-in-time provisioning of users in the organization.
         * @summary Remove organization JIT email domain
         * @param {string} id The unique identifier of the organization.
         * @param {string} emailDomain The email domain to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdJitEmailDomainsEmailDomainDelete(id: string, emailDomain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdJitEmailDomainsEmailDomainDelete(id, emailDomain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.apiOrganizationsIdJitEmailDomainsEmailDomainDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get email domains for just-in-time provisioning of users in the organization.
         * @summary Get organization JIT email domains
         * @param {string} id The unique identifier of the organization.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdJitEmailDomainsGet(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiOrganizationsIdJitEmailDomainsGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdJitEmailDomainsGet(id, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.apiOrganizationsIdJitEmailDomainsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a new email domain for just-in-time provisioning of users in the organization.
         * @summary Add organization JIT email domain
         * @param {string} id The unique identifier of the organization.
         * @param {ApiOrganizationsIdJitEmailDomainsPostRequest} apiOrganizationsIdJitEmailDomainsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdJitEmailDomainsPost(id: string, apiOrganizationsIdJitEmailDomainsPostRequest: ApiOrganizationsIdJitEmailDomainsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdJitEmailDomainsPost(id, apiOrganizationsIdJitEmailDomainsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.apiOrganizationsIdJitEmailDomainsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replace all just-in-time provisioning email domains for the organization with the given data.
         * @summary Replace organization JIT email domains
         * @param {string} id The unique identifier of the organization.
         * @param {ApiOrganizationsIdJitEmailDomainsPutRequest} apiOrganizationsIdJitEmailDomainsPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdJitEmailDomainsPut(id: string, apiOrganizationsIdJitEmailDomainsPutRequest: ApiOrganizationsIdJitEmailDomainsPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdJitEmailDomainsPut(id, apiOrganizationsIdJitEmailDomainsPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.apiOrganizationsIdJitEmailDomainsPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get organization roles that will be assigned to users during just-in-time provisioning.
         * @summary Get organization JIT default roles
         * @param {string} id The unique identifier of the organization.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdJitRolesGet(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiApplicationsApplicationIdUserConsentScopesGet200ResponseOrganizationScopesInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdJitRolesGet(id, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.apiOrganizationsIdJitRolesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove an organization role that will be assigned to users during just-in-time provisioning.
         * @summary Remove organization JIT default role
         * @param {string} id The unique identifier of the organization.
         * @param {string} organizationRoleId The unique identifier of the organization role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdJitRolesOrganizationRoleIdDelete(id: string, organizationRoleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdJitRolesOrganizationRoleIdDelete(id, organizationRoleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.apiOrganizationsIdJitRolesOrganizationRoleIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add new organization roles that will be assigned to users during just-in-time provisioning.
         * @summary Add organization JIT default roles
         * @param {string} id The unique identifier of the organization.
         * @param {ApiOrganizationsIdJitRolesPostRequest} apiOrganizationsIdJitRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdJitRolesPost(id: string, apiOrganizationsIdJitRolesPostRequest: ApiOrganizationsIdJitRolesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdJitRolesPost(id, apiOrganizationsIdJitRolesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.apiOrganizationsIdJitRolesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replace all organization roles that will be assigned to users during just-in-time provisioning with the given data.
         * @summary Replace organization JIT default roles
         * @param {string} id The unique identifier of the organization.
         * @param {ApiOrganizationsIdJitRolesPutRequest} apiOrganizationsIdJitRolesPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdJitRolesPut(id: string, apiOrganizationsIdJitRolesPutRequest: ApiOrganizationsIdJitRolesPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdJitRolesPut(id, apiOrganizationsIdJitRolesPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.apiOrganizationsIdJitRolesPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update organization details by ID with the given data.
         * @summary Update organization
         * @param {string} id The unique identifier of the organization.
         * @param {ApiOrganizationsIdPatchRequest} apiOrganizationsIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdPatch(id: string, apiOrganizationsIdPatchRequest: ApiOrganizationsIdPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiApplicationsIdUsersUserIdConsentOrganizationsGet200ResponseOrganizationsInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdPatch(id, apiOrganizationsIdPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.apiOrganizationsIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get users that are members of the specified organization for the given query with pagination.
         * @summary Get organization user members
         * @param {string} id The unique identifier of the organization.
         * @param {string} [q] The query to filter users. It will match multiple fields of users, including ID, name, username, email, and phone number.  If not provided, all users will be returned.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdUsersGet(id: string, q?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiOrganizationsIdUsersGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdUsersGet(id, q, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.apiOrganizationsIdUsersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add users as members to the specified organization with the given user IDs.
         * @summary Add user members to organization
         * @param {string} id The unique identifier of the organization.
         * @param {ApiOrganizationsIdUsersPostRequest} apiOrganizationsIdUsersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdUsersPost(id: string, apiOrganizationsIdUsersPostRequest: ApiOrganizationsIdUsersPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdUsersPost(id, apiOrganizationsIdUsersPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.apiOrganizationsIdUsersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replace all user members for the specified organization with the given users. This effectively removing all existing user memberships in the organization and adding the new users as members.
         * @summary Replace organization user members
         * @param {string} id The unique identifier of the organization.
         * @param {ApiOrganizationsIdUsersPutRequest} apiOrganizationsIdUsersPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdUsersPut(id: string, apiOrganizationsIdUsersPutRequest: ApiOrganizationsIdUsersPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdUsersPut(id, apiOrganizationsIdUsersPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.apiOrganizationsIdUsersPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Assign roles to user members of the specified organization with the given data.
         * @summary Assign roles to organization user members
         * @param {string} id The unique identifier of the organization.
         * @param {ApiOrganizationsIdUsersRolesPostRequest} apiOrganizationsIdUsersRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdUsersRolesPost(id: string, apiOrganizationsIdUsersRolesPostRequest: ApiOrganizationsIdUsersRolesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdUsersRolesPost(id, apiOrganizationsIdUsersRolesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.apiOrganizationsIdUsersRolesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a user\'s membership from the specified organization.
         * @summary Remove user member from organization
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdUsersUserIdDelete(id: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdUsersUserIdDelete(id, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.apiOrganizationsIdUsersUserIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get roles assigned to a user in the specified organization with pagination.
         * @summary Get roles for a user in an organization
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdUsersUserIdRolesGet(id: string, userId: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiApplicationsApplicationIdUserConsentScopesGet200ResponseOrganizationScopesInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdUsersUserIdRolesGet(id, userId, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.apiOrganizationsIdUsersUserIdRolesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Assign roles to a user in the specified organization with the provided data.
         * @summary Assign roles to a user in an organization
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {ApiOrganizationsIdUsersUserIdRolesPostRequest} apiOrganizationsIdUsersUserIdRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdUsersUserIdRolesPost(id: string, userId: string, apiOrganizationsIdUsersUserIdRolesPostRequest: ApiOrganizationsIdUsersUserIdRolesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdUsersUserIdRolesPost(id, userId, apiOrganizationsIdUsersUserIdRolesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.apiOrganizationsIdUsersUserIdRolesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update roles assigned to a user in the specified organization with the provided data.
         * @summary Update roles for a user in an organization
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {ApiOrganizationsIdUsersUserIdRolesPutRequest} apiOrganizationsIdUsersUserIdRolesPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdUsersUserIdRolesPut(id: string, userId: string, apiOrganizationsIdUsersUserIdRolesPutRequest: ApiOrganizationsIdUsersUserIdRolesPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdUsersUserIdRolesPut(id, userId, apiOrganizationsIdUsersUserIdRolesPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.apiOrganizationsIdUsersUserIdRolesPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a role assignment from a user in the specified organization.
         * @summary Remove a role from a user in an organization
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {string} roleId The unique identifier of the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdUsersUserIdRolesRoleIdDelete(id: string, userId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdUsersUserIdRolesRoleIdDelete(id, userId, roleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.apiOrganizationsIdUsersUserIdRolesRoleIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get scopes assigned to a user in the specified organization tailored by the organization roles. The scopes are derived from the organization roles assigned to the user.
         * @summary Get scopes for a user in an organization tailored by the organization roles
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdUsersUserIdScopesGet(id: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiApplicationsApplicationIdUserConsentScopesGet200ResponseOrganizationScopesInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdUsersUserIdScopesGet(id, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.apiOrganizationsIdUsersUserIdScopesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new organization with the given data.
         * @summary Create an organization
         * @param {ApiOrganizationsPostRequest} apiOrganizationsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsPost(apiOrganizationsPostRequest: ApiOrganizationsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsPost(apiOrganizationsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.apiOrganizationsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationsApi - factory interface
 * @export
 */
export const OrganizationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationsApiFp(configuration)
    return {
        /**
         * Get organizations that match the given query with pagination.
         * @summary Get organizations
         * @param {string} [q] The query to filter organizations. It can be a partial ID or name.  If not provided, all organizations will be returned.
         * @param {string} [showFeatured] Whether to show featured users in the organization. Featured users are randomly selected from the organization members.  If not provided, &#x60;featuredUsers&#x60; will not be included in the response.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsGet(q?: string, showFeatured?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ApiOrganizationsGet200ResponseInner>> {
            return localVarFp.apiOrganizationsGet(q, showFeatured, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete organization by ID.
         * @summary Delete organization
         * @param {string} id The unique identifier of the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organization details by ID.
         * @summary Get organization
         * @param {string} id The unique identifier of the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdGet(id: string, options?: any): AxiosPromise<ApiApplicationsIdUsersUserIdConsentOrganizationsGet200ResponseOrganizationsInner> {
            return localVarFp.apiOrganizationsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove an email domain for just-in-time provisioning of users in the organization.
         * @summary Remove organization JIT email domain
         * @param {string} id The unique identifier of the organization.
         * @param {string} emailDomain The email domain to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdJitEmailDomainsEmailDomainDelete(id: string, emailDomain: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationsIdJitEmailDomainsEmailDomainDelete(id, emailDomain, options).then((request) => request(axios, basePath));
        },
        /**
         * Get email domains for just-in-time provisioning of users in the organization.
         * @summary Get organization JIT email domains
         * @param {string} id The unique identifier of the organization.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdJitEmailDomainsGet(id: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ApiOrganizationsIdJitEmailDomainsGet200ResponseInner>> {
            return localVarFp.apiOrganizationsIdJitEmailDomainsGet(id, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new email domain for just-in-time provisioning of users in the organization.
         * @summary Add organization JIT email domain
         * @param {string} id The unique identifier of the organization.
         * @param {ApiOrganizationsIdJitEmailDomainsPostRequest} apiOrganizationsIdJitEmailDomainsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdJitEmailDomainsPost(id: string, apiOrganizationsIdJitEmailDomainsPostRequest: ApiOrganizationsIdJitEmailDomainsPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationsIdJitEmailDomainsPost(id, apiOrganizationsIdJitEmailDomainsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace all just-in-time provisioning email domains for the organization with the given data.
         * @summary Replace organization JIT email domains
         * @param {string} id The unique identifier of the organization.
         * @param {ApiOrganizationsIdJitEmailDomainsPutRequest} apiOrganizationsIdJitEmailDomainsPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdJitEmailDomainsPut(id: string, apiOrganizationsIdJitEmailDomainsPutRequest: ApiOrganizationsIdJitEmailDomainsPutRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationsIdJitEmailDomainsPut(id, apiOrganizationsIdJitEmailDomainsPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organization roles that will be assigned to users during just-in-time provisioning.
         * @summary Get organization JIT default roles
         * @param {string} id The unique identifier of the organization.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdJitRolesGet(id: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ApiApplicationsApplicationIdUserConsentScopesGet200ResponseOrganizationScopesInner>> {
            return localVarFp.apiOrganizationsIdJitRolesGet(id, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove an organization role that will be assigned to users during just-in-time provisioning.
         * @summary Remove organization JIT default role
         * @param {string} id The unique identifier of the organization.
         * @param {string} organizationRoleId The unique identifier of the organization role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdJitRolesOrganizationRoleIdDelete(id: string, organizationRoleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationsIdJitRolesOrganizationRoleIdDelete(id, organizationRoleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Add new organization roles that will be assigned to users during just-in-time provisioning.
         * @summary Add organization JIT default roles
         * @param {string} id The unique identifier of the organization.
         * @param {ApiOrganizationsIdJitRolesPostRequest} apiOrganizationsIdJitRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdJitRolesPost(id: string, apiOrganizationsIdJitRolesPostRequest: ApiOrganizationsIdJitRolesPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationsIdJitRolesPost(id, apiOrganizationsIdJitRolesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace all organization roles that will be assigned to users during just-in-time provisioning with the given data.
         * @summary Replace organization JIT default roles
         * @param {string} id The unique identifier of the organization.
         * @param {ApiOrganizationsIdJitRolesPutRequest} apiOrganizationsIdJitRolesPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdJitRolesPut(id: string, apiOrganizationsIdJitRolesPutRequest: ApiOrganizationsIdJitRolesPutRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationsIdJitRolesPut(id, apiOrganizationsIdJitRolesPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update organization details by ID with the given data.
         * @summary Update organization
         * @param {string} id The unique identifier of the organization.
         * @param {ApiOrganizationsIdPatchRequest} apiOrganizationsIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdPatch(id: string, apiOrganizationsIdPatchRequest: ApiOrganizationsIdPatchRequest, options?: any): AxiosPromise<ApiApplicationsIdUsersUserIdConsentOrganizationsGet200ResponseOrganizationsInner> {
            return localVarFp.apiOrganizationsIdPatch(id, apiOrganizationsIdPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get users that are members of the specified organization for the given query with pagination.
         * @summary Get organization user members
         * @param {string} id The unique identifier of the organization.
         * @param {string} [q] The query to filter users. It will match multiple fields of users, including ID, name, username, email, and phone number.  If not provided, all users will be returned.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdUsersGet(id: string, q?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ApiOrganizationsIdUsersGet200ResponseInner>> {
            return localVarFp.apiOrganizationsIdUsersGet(id, q, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Add users as members to the specified organization with the given user IDs.
         * @summary Add user members to organization
         * @param {string} id The unique identifier of the organization.
         * @param {ApiOrganizationsIdUsersPostRequest} apiOrganizationsIdUsersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdUsersPost(id: string, apiOrganizationsIdUsersPostRequest: ApiOrganizationsIdUsersPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationsIdUsersPost(id, apiOrganizationsIdUsersPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace all user members for the specified organization with the given users. This effectively removing all existing user memberships in the organization and adding the new users as members.
         * @summary Replace organization user members
         * @param {string} id The unique identifier of the organization.
         * @param {ApiOrganizationsIdUsersPutRequest} apiOrganizationsIdUsersPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdUsersPut(id: string, apiOrganizationsIdUsersPutRequest: ApiOrganizationsIdUsersPutRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationsIdUsersPut(id, apiOrganizationsIdUsersPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign roles to user members of the specified organization with the given data.
         * @summary Assign roles to organization user members
         * @param {string} id The unique identifier of the organization.
         * @param {ApiOrganizationsIdUsersRolesPostRequest} apiOrganizationsIdUsersRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdUsersRolesPost(id: string, apiOrganizationsIdUsersRolesPostRequest: ApiOrganizationsIdUsersRolesPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationsIdUsersRolesPost(id, apiOrganizationsIdUsersRolesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a user\'s membership from the specified organization.
         * @summary Remove user member from organization
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdUsersUserIdDelete(id: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationsIdUsersUserIdDelete(id, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get roles assigned to a user in the specified organization with pagination.
         * @summary Get roles for a user in an organization
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdUsersUserIdRolesGet(id: string, userId: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ApiApplicationsApplicationIdUserConsentScopesGet200ResponseOrganizationScopesInner>> {
            return localVarFp.apiOrganizationsIdUsersUserIdRolesGet(id, userId, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign roles to a user in the specified organization with the provided data.
         * @summary Assign roles to a user in an organization
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {ApiOrganizationsIdUsersUserIdRolesPostRequest} apiOrganizationsIdUsersUserIdRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdUsersUserIdRolesPost(id: string, userId: string, apiOrganizationsIdUsersUserIdRolesPostRequest: ApiOrganizationsIdUsersUserIdRolesPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationsIdUsersUserIdRolesPost(id, userId, apiOrganizationsIdUsersUserIdRolesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update roles assigned to a user in the specified organization with the provided data.
         * @summary Update roles for a user in an organization
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {ApiOrganizationsIdUsersUserIdRolesPutRequest} apiOrganizationsIdUsersUserIdRolesPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdUsersUserIdRolesPut(id: string, userId: string, apiOrganizationsIdUsersUserIdRolesPutRequest: ApiOrganizationsIdUsersUserIdRolesPutRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationsIdUsersUserIdRolesPut(id, userId, apiOrganizationsIdUsersUserIdRolesPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a role assignment from a user in the specified organization.
         * @summary Remove a role from a user in an organization
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {string} roleId The unique identifier of the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdUsersUserIdRolesRoleIdDelete(id: string, userId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationsIdUsersUserIdRolesRoleIdDelete(id, userId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get scopes assigned to a user in the specified organization tailored by the organization roles. The scopes are derived from the organization roles assigned to the user.
         * @summary Get scopes for a user in an organization tailored by the organization roles
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdUsersUserIdScopesGet(id: string, userId: string, options?: any): AxiosPromise<Array<ApiApplicationsApplicationIdUserConsentScopesGet200ResponseOrganizationScopesInner>> {
            return localVarFp.apiOrganizationsIdUsersUserIdScopesGet(id, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new organization with the given data.
         * @summary Create an organization
         * @param {ApiOrganizationsPostRequest} apiOrganizationsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsPost(apiOrganizationsPostRequest: ApiOrganizationsPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationsPost(apiOrganizationsPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
export class OrganizationsApi extends BaseAPI {
    /**
     * Get organizations that match the given query with pagination.
     * @summary Get organizations
     * @param {string} [q] The query to filter organizations. It can be a partial ID or name.  If not provided, all organizations will be returned.
     * @param {string} [showFeatured] Whether to show featured users in the organization. Featured users are randomly selected from the organization members.  If not provided, &#x60;featuredUsers&#x60; will not be included in the response.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public apiOrganizationsGet(q?: string, showFeatured?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).apiOrganizationsGet(q, showFeatured, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete organization by ID.
     * @summary Delete organization
     * @param {string} id The unique identifier of the organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public apiOrganizationsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).apiOrganizationsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get organization details by ID.
     * @summary Get organization
     * @param {string} id The unique identifier of the organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public apiOrganizationsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).apiOrganizationsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove an email domain for just-in-time provisioning of users in the organization.
     * @summary Remove organization JIT email domain
     * @param {string} id The unique identifier of the organization.
     * @param {string} emailDomain The email domain to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public apiOrganizationsIdJitEmailDomainsEmailDomainDelete(id: string, emailDomain: string, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).apiOrganizationsIdJitEmailDomainsEmailDomainDelete(id, emailDomain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get email domains for just-in-time provisioning of users in the organization.
     * @summary Get organization JIT email domains
     * @param {string} id The unique identifier of the organization.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public apiOrganizationsIdJitEmailDomainsGet(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).apiOrganizationsIdJitEmailDomainsGet(id, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new email domain for just-in-time provisioning of users in the organization.
     * @summary Add organization JIT email domain
     * @param {string} id The unique identifier of the organization.
     * @param {ApiOrganizationsIdJitEmailDomainsPostRequest} apiOrganizationsIdJitEmailDomainsPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public apiOrganizationsIdJitEmailDomainsPost(id: string, apiOrganizationsIdJitEmailDomainsPostRequest: ApiOrganizationsIdJitEmailDomainsPostRequest, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).apiOrganizationsIdJitEmailDomainsPost(id, apiOrganizationsIdJitEmailDomainsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace all just-in-time provisioning email domains for the organization with the given data.
     * @summary Replace organization JIT email domains
     * @param {string} id The unique identifier of the organization.
     * @param {ApiOrganizationsIdJitEmailDomainsPutRequest} apiOrganizationsIdJitEmailDomainsPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public apiOrganizationsIdJitEmailDomainsPut(id: string, apiOrganizationsIdJitEmailDomainsPutRequest: ApiOrganizationsIdJitEmailDomainsPutRequest, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).apiOrganizationsIdJitEmailDomainsPut(id, apiOrganizationsIdJitEmailDomainsPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get organization roles that will be assigned to users during just-in-time provisioning.
     * @summary Get organization JIT default roles
     * @param {string} id The unique identifier of the organization.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public apiOrganizationsIdJitRolesGet(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).apiOrganizationsIdJitRolesGet(id, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove an organization role that will be assigned to users during just-in-time provisioning.
     * @summary Remove organization JIT default role
     * @param {string} id The unique identifier of the organization.
     * @param {string} organizationRoleId The unique identifier of the organization role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public apiOrganizationsIdJitRolesOrganizationRoleIdDelete(id: string, organizationRoleId: string, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).apiOrganizationsIdJitRolesOrganizationRoleIdDelete(id, organizationRoleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add new organization roles that will be assigned to users during just-in-time provisioning.
     * @summary Add organization JIT default roles
     * @param {string} id The unique identifier of the organization.
     * @param {ApiOrganizationsIdJitRolesPostRequest} apiOrganizationsIdJitRolesPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public apiOrganizationsIdJitRolesPost(id: string, apiOrganizationsIdJitRolesPostRequest: ApiOrganizationsIdJitRolesPostRequest, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).apiOrganizationsIdJitRolesPost(id, apiOrganizationsIdJitRolesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace all organization roles that will be assigned to users during just-in-time provisioning with the given data.
     * @summary Replace organization JIT default roles
     * @param {string} id The unique identifier of the organization.
     * @param {ApiOrganizationsIdJitRolesPutRequest} apiOrganizationsIdJitRolesPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public apiOrganizationsIdJitRolesPut(id: string, apiOrganizationsIdJitRolesPutRequest: ApiOrganizationsIdJitRolesPutRequest, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).apiOrganizationsIdJitRolesPut(id, apiOrganizationsIdJitRolesPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update organization details by ID with the given data.
     * @summary Update organization
     * @param {string} id The unique identifier of the organization.
     * @param {ApiOrganizationsIdPatchRequest} apiOrganizationsIdPatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public apiOrganizationsIdPatch(id: string, apiOrganizationsIdPatchRequest: ApiOrganizationsIdPatchRequest, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).apiOrganizationsIdPatch(id, apiOrganizationsIdPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get users that are members of the specified organization for the given query with pagination.
     * @summary Get organization user members
     * @param {string} id The unique identifier of the organization.
     * @param {string} [q] The query to filter users. It will match multiple fields of users, including ID, name, username, email, and phone number.  If not provided, all users will be returned.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public apiOrganizationsIdUsersGet(id: string, q?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).apiOrganizationsIdUsersGet(id, q, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add users as members to the specified organization with the given user IDs.
     * @summary Add user members to organization
     * @param {string} id The unique identifier of the organization.
     * @param {ApiOrganizationsIdUsersPostRequest} apiOrganizationsIdUsersPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public apiOrganizationsIdUsersPost(id: string, apiOrganizationsIdUsersPostRequest: ApiOrganizationsIdUsersPostRequest, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).apiOrganizationsIdUsersPost(id, apiOrganizationsIdUsersPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace all user members for the specified organization with the given users. This effectively removing all existing user memberships in the organization and adding the new users as members.
     * @summary Replace organization user members
     * @param {string} id The unique identifier of the organization.
     * @param {ApiOrganizationsIdUsersPutRequest} apiOrganizationsIdUsersPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public apiOrganizationsIdUsersPut(id: string, apiOrganizationsIdUsersPutRequest: ApiOrganizationsIdUsersPutRequest, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).apiOrganizationsIdUsersPut(id, apiOrganizationsIdUsersPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assign roles to user members of the specified organization with the given data.
     * @summary Assign roles to organization user members
     * @param {string} id The unique identifier of the organization.
     * @param {ApiOrganizationsIdUsersRolesPostRequest} apiOrganizationsIdUsersRolesPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public apiOrganizationsIdUsersRolesPost(id: string, apiOrganizationsIdUsersRolesPostRequest: ApiOrganizationsIdUsersRolesPostRequest, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).apiOrganizationsIdUsersRolesPost(id, apiOrganizationsIdUsersRolesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a user\'s membership from the specified organization.
     * @summary Remove user member from organization
     * @param {string} id The unique identifier of the organization.
     * @param {string} userId The unique identifier of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public apiOrganizationsIdUsersUserIdDelete(id: string, userId: string, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).apiOrganizationsIdUsersUserIdDelete(id, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get roles assigned to a user in the specified organization with pagination.
     * @summary Get roles for a user in an organization
     * @param {string} id The unique identifier of the organization.
     * @param {string} userId The unique identifier of the user.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public apiOrganizationsIdUsersUserIdRolesGet(id: string, userId: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).apiOrganizationsIdUsersUserIdRolesGet(id, userId, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assign roles to a user in the specified organization with the provided data.
     * @summary Assign roles to a user in an organization
     * @param {string} id The unique identifier of the organization.
     * @param {string} userId The unique identifier of the user.
     * @param {ApiOrganizationsIdUsersUserIdRolesPostRequest} apiOrganizationsIdUsersUserIdRolesPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public apiOrganizationsIdUsersUserIdRolesPost(id: string, userId: string, apiOrganizationsIdUsersUserIdRolesPostRequest: ApiOrganizationsIdUsersUserIdRolesPostRequest, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).apiOrganizationsIdUsersUserIdRolesPost(id, userId, apiOrganizationsIdUsersUserIdRolesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update roles assigned to a user in the specified organization with the provided data.
     * @summary Update roles for a user in an organization
     * @param {string} id The unique identifier of the organization.
     * @param {string} userId The unique identifier of the user.
     * @param {ApiOrganizationsIdUsersUserIdRolesPutRequest} apiOrganizationsIdUsersUserIdRolesPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public apiOrganizationsIdUsersUserIdRolesPut(id: string, userId: string, apiOrganizationsIdUsersUserIdRolesPutRequest: ApiOrganizationsIdUsersUserIdRolesPutRequest, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).apiOrganizationsIdUsersUserIdRolesPut(id, userId, apiOrganizationsIdUsersUserIdRolesPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a role assignment from a user in the specified organization.
     * @summary Remove a role from a user in an organization
     * @param {string} id The unique identifier of the organization.
     * @param {string} userId The unique identifier of the user.
     * @param {string} roleId The unique identifier of the role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public apiOrganizationsIdUsersUserIdRolesRoleIdDelete(id: string, userId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).apiOrganizationsIdUsersUserIdRolesRoleIdDelete(id, userId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get scopes assigned to a user in the specified organization tailored by the organization roles. The scopes are derived from the organization roles assigned to the user.
     * @summary Get scopes for a user in an organization tailored by the organization roles
     * @param {string} id The unique identifier of the organization.
     * @param {string} userId The unique identifier of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public apiOrganizationsIdUsersUserIdScopesGet(id: string, userId: string, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).apiOrganizationsIdUsersUserIdScopesGet(id, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new organization with the given data.
     * @summary Create an organization
     * @param {ApiOrganizationsPostRequest} apiOrganizationsPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public apiOrganizationsPost(apiOrganizationsPostRequest: ApiOrganizationsPostRequest, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).apiOrganizationsPost(apiOrganizationsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResourcesApi - axios parameter creator
 * @export
 */
export const ResourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get API resources in the current tenant with pagination.
         * @summary Get API resources
         * @param {string} [includeScopes] If it\&#39;s provided with a truthy value (&#x60;true&#x60;, &#x60;1&#x60;, &#x60;yes&#x60;), the scopes of each resource will be included in the response.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiResourcesGet: async (includeScopes?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/resources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeScopes !== undefined) {
                localVarQueryParameter['includeScopes'] = includeScopes;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an API resource by ID.
         * @summary Delete API resource
         * @param {string} id The unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiResourcesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiResourcesIdDelete', 'id', id)
            const localVarPath = `/api/resources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an API resource details by ID.
         * @summary Get API resource
         * @param {string} id The unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiResourcesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiResourcesIdGet', 'id', id)
            const localVarPath = `/api/resources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set an API resource as the default resource for the current tenant.  Each tenant can have only one default API resource. If an API resource is set as default, the previously set default API resource will be set as non-default. See [this section](https://docs.logto.io/docs/references/resources/#default-api) for more information.
         * @summary Set API resource as default
         * @param {string} id The unique identifier of the resource.
         * @param {ApiResourcesIdIsDefaultPatchRequest} apiResourcesIdIsDefaultPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiResourcesIdIsDefaultPatch: async (id: string, apiResourcesIdIsDefaultPatchRequest: ApiResourcesIdIsDefaultPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiResourcesIdIsDefaultPatch', 'id', id)
            // verify required parameter 'apiResourcesIdIsDefaultPatchRequest' is not null or undefined
            assertParamExists('apiResourcesIdIsDefaultPatch', 'apiResourcesIdIsDefaultPatchRequest', apiResourcesIdIsDefaultPatchRequest)
            const localVarPath = `/api/resources/{id}/is-default`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiResourcesIdIsDefaultPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an API resource details by ID with the given data. This method performs a partial update.
         * @summary Update API resource
         * @param {string} id The unique identifier of the resource.
         * @param {ApiResourcesIdPatchRequest} apiResourcesIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiResourcesIdPatch: async (id: string, apiResourcesIdPatchRequest: ApiResourcesIdPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiResourcesIdPatch', 'id', id)
            // verify required parameter 'apiResourcesIdPatchRequest' is not null or undefined
            assertParamExists('apiResourcesIdPatch', 'apiResourcesIdPatchRequest', apiResourcesIdPatchRequest)
            const localVarPath = `/api/resources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiResourcesIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an API resource in the current tenant.
         * @summary Create an API resource
         * @param {ApiResourcesPostRequest} apiResourcesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiResourcesPost: async (apiResourcesPostRequest: ApiResourcesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiResourcesPostRequest' is not null or undefined
            assertParamExists('apiResourcesPost', 'apiResourcesPostRequest', apiResourcesPostRequest)
            const localVarPath = `/api/resources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiResourcesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get scopes (permissions) defined for an API resource.
         * @summary Get API resource scopes
         * @param {string} resourceId The unique identifier of the resource.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiResourcesResourceIdScopesGet: async (resourceId: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('apiResourcesResourceIdScopesGet', 'resourceId', resourceId)
            const localVarPath = `/api/resources/{resourceId}/scopes`
                .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new scope (permission) for an API resource.
         * @summary Create API resource scope
         * @param {string} resourceId The unique identifier of the resource.
         * @param {ApiResourcesResourceIdScopesPostRequest} apiResourcesResourceIdScopesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiResourcesResourceIdScopesPost: async (resourceId: string, apiResourcesResourceIdScopesPostRequest: ApiResourcesResourceIdScopesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('apiResourcesResourceIdScopesPost', 'resourceId', resourceId)
            // verify required parameter 'apiResourcesResourceIdScopesPostRequest' is not null or undefined
            assertParamExists('apiResourcesResourceIdScopesPost', 'apiResourcesResourceIdScopesPostRequest', apiResourcesResourceIdScopesPostRequest)
            const localVarPath = `/api/resources/{resourceId}/scopes`
                .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiResourcesResourceIdScopesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an API resource scope (permission) from the given resource.
         * @summary Delete API resource scope
         * @param {string} resourceId The unique identifier of the resource.
         * @param {string} scopeId The unique identifier of the scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiResourcesResourceIdScopesScopeIdDelete: async (resourceId: string, scopeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('apiResourcesResourceIdScopesScopeIdDelete', 'resourceId', resourceId)
            // verify required parameter 'scopeId' is not null or undefined
            assertParamExists('apiResourcesResourceIdScopesScopeIdDelete', 'scopeId', scopeId)
            const localVarPath = `/api/resources/{resourceId}/scopes/{scopeId}`
                .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)))
                .replace(`{${"scopeId"}}`, encodeURIComponent(String(scopeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an API resource scope (permission) for the given resource. This method performs a partial update.
         * @summary Update API resource scope
         * @param {string} resourceId The unique identifier of the resource.
         * @param {string} scopeId The unique identifier of the scope.
         * @param {ApiResourcesResourceIdScopesScopeIdPatchRequest} apiResourcesResourceIdScopesScopeIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiResourcesResourceIdScopesScopeIdPatch: async (resourceId: string, scopeId: string, apiResourcesResourceIdScopesScopeIdPatchRequest: ApiResourcesResourceIdScopesScopeIdPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('apiResourcesResourceIdScopesScopeIdPatch', 'resourceId', resourceId)
            // verify required parameter 'scopeId' is not null or undefined
            assertParamExists('apiResourcesResourceIdScopesScopeIdPatch', 'scopeId', scopeId)
            // verify required parameter 'apiResourcesResourceIdScopesScopeIdPatchRequest' is not null or undefined
            assertParamExists('apiResourcesResourceIdScopesScopeIdPatch', 'apiResourcesResourceIdScopesScopeIdPatchRequest', apiResourcesResourceIdScopesScopeIdPatchRequest)
            const localVarPath = `/api/resources/{resourceId}/scopes/{scopeId}`
                .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)))
                .replace(`{${"scopeId"}}`, encodeURIComponent(String(scopeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiResourcesResourceIdScopesScopeIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourcesApi - functional programming interface
 * @export
 */
export const ResourcesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get API resources in the current tenant with pagination.
         * @summary Get API resources
         * @param {string} [includeScopes] If it\&#39;s provided with a truthy value (&#x60;true&#x60;, &#x60;1&#x60;, &#x60;yes&#x60;), the scopes of each resource will be included in the response.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiResourcesGet(includeScopes?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiResourcesGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiResourcesGet(includeScopes, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.apiResourcesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an API resource by ID.
         * @summary Delete API resource
         * @param {string} id The unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiResourcesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiResourcesIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.apiResourcesIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an API resource details by ID.
         * @summary Get API resource
         * @param {string} id The unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiResourcesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiResourcesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.apiResourcesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set an API resource as the default resource for the current tenant.  Each tenant can have only one default API resource. If an API resource is set as default, the previously set default API resource will be set as non-default. See [this section](https://docs.logto.io/docs/references/resources/#default-api) for more information.
         * @summary Set API resource as default
         * @param {string} id The unique identifier of the resource.
         * @param {ApiResourcesIdIsDefaultPatchRequest} apiResourcesIdIsDefaultPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiResourcesIdIsDefaultPatch(id: string, apiResourcesIdIsDefaultPatchRequest: ApiResourcesIdIsDefaultPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiResourcesIdIsDefaultPatch(id, apiResourcesIdIsDefaultPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.apiResourcesIdIsDefaultPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an API resource details by ID with the given data. This method performs a partial update.
         * @summary Update API resource
         * @param {string} id The unique identifier of the resource.
         * @param {ApiResourcesIdPatchRequest} apiResourcesIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiResourcesIdPatch(id: string, apiResourcesIdPatchRequest: ApiResourcesIdPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiResourcesIdPatch(id, apiResourcesIdPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.apiResourcesIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an API resource in the current tenant.
         * @summary Create an API resource
         * @param {ApiResourcesPostRequest} apiResourcesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiResourcesPost(apiResourcesPostRequest: ApiResourcesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiResourcesPost(apiResourcesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.apiResourcesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get scopes (permissions) defined for an API resource.
         * @summary Get API resource scopes
         * @param {string} resourceId The unique identifier of the resource.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiResourcesResourceIdScopesGet(resourceId: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiResourcesGet200ResponseInnerScopesInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiResourcesResourceIdScopesGet(resourceId, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.apiResourcesResourceIdScopesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new scope (permission) for an API resource.
         * @summary Create API resource scope
         * @param {string} resourceId The unique identifier of the resource.
         * @param {ApiResourcesResourceIdScopesPostRequest} apiResourcesResourceIdScopesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiResourcesResourceIdScopesPost(resourceId: string, apiResourcesResourceIdScopesPostRequest: ApiResourcesResourceIdScopesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiResourcesResourceIdScopesPost(resourceId, apiResourcesResourceIdScopesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.apiResourcesResourceIdScopesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an API resource scope (permission) from the given resource.
         * @summary Delete API resource scope
         * @param {string} resourceId The unique identifier of the resource.
         * @param {string} scopeId The unique identifier of the scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiResourcesResourceIdScopesScopeIdDelete(resourceId: string, scopeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiResourcesResourceIdScopesScopeIdDelete(resourceId, scopeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.apiResourcesResourceIdScopesScopeIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an API resource scope (permission) for the given resource. This method performs a partial update.
         * @summary Update API resource scope
         * @param {string} resourceId The unique identifier of the resource.
         * @param {string} scopeId The unique identifier of the scope.
         * @param {ApiResourcesResourceIdScopesScopeIdPatchRequest} apiResourcesResourceIdScopesScopeIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiResourcesResourceIdScopesScopeIdPatch(resourceId: string, scopeId: string, apiResourcesResourceIdScopesScopeIdPatchRequest: ApiResourcesResourceIdScopesScopeIdPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResourcesGet200ResponseInnerScopesInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiResourcesResourceIdScopesScopeIdPatch(resourceId, scopeId, apiResourcesResourceIdScopesScopeIdPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.apiResourcesResourceIdScopesScopeIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResourcesApi - factory interface
 * @export
 */
export const ResourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourcesApiFp(configuration)
    return {
        /**
         * Get API resources in the current tenant with pagination.
         * @summary Get API resources
         * @param {string} [includeScopes] If it\&#39;s provided with a truthy value (&#x60;true&#x60;, &#x60;1&#x60;, &#x60;yes&#x60;), the scopes of each resource will be included in the response.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiResourcesGet(includeScopes?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ApiResourcesGet200ResponseInner>> {
            return localVarFp.apiResourcesGet(includeScopes, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an API resource by ID.
         * @summary Delete API resource
         * @param {string} id The unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiResourcesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiResourcesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an API resource details by ID.
         * @summary Get API resource
         * @param {string} id The unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiResourcesIdGet(id: string, options?: any): AxiosPromise<ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource> {
            return localVarFp.apiResourcesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Set an API resource as the default resource for the current tenant.  Each tenant can have only one default API resource. If an API resource is set as default, the previously set default API resource will be set as non-default. See [this section](https://docs.logto.io/docs/references/resources/#default-api) for more information.
         * @summary Set API resource as default
         * @param {string} id The unique identifier of the resource.
         * @param {ApiResourcesIdIsDefaultPatchRequest} apiResourcesIdIsDefaultPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiResourcesIdIsDefaultPatch(id: string, apiResourcesIdIsDefaultPatchRequest: ApiResourcesIdIsDefaultPatchRequest, options?: any): AxiosPromise<ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource> {
            return localVarFp.apiResourcesIdIsDefaultPatch(id, apiResourcesIdIsDefaultPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an API resource details by ID with the given data. This method performs a partial update.
         * @summary Update API resource
         * @param {string} id The unique identifier of the resource.
         * @param {ApiResourcesIdPatchRequest} apiResourcesIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiResourcesIdPatch(id: string, apiResourcesIdPatchRequest: ApiResourcesIdPatchRequest, options?: any): AxiosPromise<ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource> {
            return localVarFp.apiResourcesIdPatch(id, apiResourcesIdPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an API resource in the current tenant.
         * @summary Create an API resource
         * @param {ApiResourcesPostRequest} apiResourcesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiResourcesPost(apiResourcesPostRequest: ApiResourcesPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiResourcesPost(apiResourcesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get scopes (permissions) defined for an API resource.
         * @summary Get API resource scopes
         * @param {string} resourceId The unique identifier of the resource.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiResourcesResourceIdScopesGet(resourceId: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ApiResourcesGet200ResponseInnerScopesInner>> {
            return localVarFp.apiResourcesResourceIdScopesGet(resourceId, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new scope (permission) for an API resource.
         * @summary Create API resource scope
         * @param {string} resourceId The unique identifier of the resource.
         * @param {ApiResourcesResourceIdScopesPostRequest} apiResourcesResourceIdScopesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiResourcesResourceIdScopesPost(resourceId: string, apiResourcesResourceIdScopesPostRequest: ApiResourcesResourceIdScopesPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiResourcesResourceIdScopesPost(resourceId, apiResourcesResourceIdScopesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an API resource scope (permission) from the given resource.
         * @summary Delete API resource scope
         * @param {string} resourceId The unique identifier of the resource.
         * @param {string} scopeId The unique identifier of the scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiResourcesResourceIdScopesScopeIdDelete(resourceId: string, scopeId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiResourcesResourceIdScopesScopeIdDelete(resourceId, scopeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an API resource scope (permission) for the given resource. This method performs a partial update.
         * @summary Update API resource scope
         * @param {string} resourceId The unique identifier of the resource.
         * @param {string} scopeId The unique identifier of the scope.
         * @param {ApiResourcesResourceIdScopesScopeIdPatchRequest} apiResourcesResourceIdScopesScopeIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiResourcesResourceIdScopesScopeIdPatch(resourceId: string, scopeId: string, apiResourcesResourceIdScopesScopeIdPatchRequest: ApiResourcesResourceIdScopesScopeIdPatchRequest, options?: any): AxiosPromise<ApiResourcesGet200ResponseInnerScopesInner> {
            return localVarFp.apiResourcesResourceIdScopesScopeIdPatch(resourceId, scopeId, apiResourcesResourceIdScopesScopeIdPatchRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResourcesApi - object-oriented interface
 * @export
 * @class ResourcesApi
 * @extends {BaseAPI}
 */
export class ResourcesApi extends BaseAPI {
    /**
     * Get API resources in the current tenant with pagination.
     * @summary Get API resources
     * @param {string} [includeScopes] If it\&#39;s provided with a truthy value (&#x60;true&#x60;, &#x60;1&#x60;, &#x60;yes&#x60;), the scopes of each resource will be included in the response.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public apiResourcesGet(includeScopes?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).apiResourcesGet(includeScopes, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an API resource by ID.
     * @summary Delete API resource
     * @param {string} id The unique identifier of the resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public apiResourcesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).apiResourcesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an API resource details by ID.
     * @summary Get API resource
     * @param {string} id The unique identifier of the resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public apiResourcesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).apiResourcesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set an API resource as the default resource for the current tenant.  Each tenant can have only one default API resource. If an API resource is set as default, the previously set default API resource will be set as non-default. See [this section](https://docs.logto.io/docs/references/resources/#default-api) for more information.
     * @summary Set API resource as default
     * @param {string} id The unique identifier of the resource.
     * @param {ApiResourcesIdIsDefaultPatchRequest} apiResourcesIdIsDefaultPatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public apiResourcesIdIsDefaultPatch(id: string, apiResourcesIdIsDefaultPatchRequest: ApiResourcesIdIsDefaultPatchRequest, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).apiResourcesIdIsDefaultPatch(id, apiResourcesIdIsDefaultPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an API resource details by ID with the given data. This method performs a partial update.
     * @summary Update API resource
     * @param {string} id The unique identifier of the resource.
     * @param {ApiResourcesIdPatchRequest} apiResourcesIdPatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public apiResourcesIdPatch(id: string, apiResourcesIdPatchRequest: ApiResourcesIdPatchRequest, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).apiResourcesIdPatch(id, apiResourcesIdPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an API resource in the current tenant.
     * @summary Create an API resource
     * @param {ApiResourcesPostRequest} apiResourcesPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public apiResourcesPost(apiResourcesPostRequest: ApiResourcesPostRequest, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).apiResourcesPost(apiResourcesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get scopes (permissions) defined for an API resource.
     * @summary Get API resource scopes
     * @param {string} resourceId The unique identifier of the resource.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public apiResourcesResourceIdScopesGet(resourceId: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).apiResourcesResourceIdScopesGet(resourceId, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new scope (permission) for an API resource.
     * @summary Create API resource scope
     * @param {string} resourceId The unique identifier of the resource.
     * @param {ApiResourcesResourceIdScopesPostRequest} apiResourcesResourceIdScopesPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public apiResourcesResourceIdScopesPost(resourceId: string, apiResourcesResourceIdScopesPostRequest: ApiResourcesResourceIdScopesPostRequest, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).apiResourcesResourceIdScopesPost(resourceId, apiResourcesResourceIdScopesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an API resource scope (permission) from the given resource.
     * @summary Delete API resource scope
     * @param {string} resourceId The unique identifier of the resource.
     * @param {string} scopeId The unique identifier of the scope.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public apiResourcesResourceIdScopesScopeIdDelete(resourceId: string, scopeId: string, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).apiResourcesResourceIdScopesScopeIdDelete(resourceId, scopeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an API resource scope (permission) for the given resource. This method performs a partial update.
     * @summary Update API resource scope
     * @param {string} resourceId The unique identifier of the resource.
     * @param {string} scopeId The unique identifier of the scope.
     * @param {ApiResourcesResourceIdScopesScopeIdPatchRequest} apiResourcesResourceIdScopesScopeIdPatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public apiResourcesResourceIdScopesScopeIdPatch(resourceId: string, scopeId: string, apiResourcesResourceIdScopesScopeIdPatchRequest: ApiResourcesResourceIdScopesScopeIdPatchRequest, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).apiResourcesResourceIdScopesScopeIdPatch(resourceId, scopeId, apiResourcesResourceIdScopesScopeIdPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RolesApi - axios parameter creator
 * @export
 */
export const RolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get roles with filters and pagination.
         * @summary Get roles
         * @param {string} [excludeUserId] Exclude roles assigned to a user.
         * @param {string} [excludeApplicationId] Exclude roles assigned to an application.
         * @param {ApiRolesGetTypeEnum} [type] Filter by role type.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRolesGet: async (excludeUserId?: string, excludeApplicationId?: string, type?: ApiRolesGetTypeEnum, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (excludeUserId !== undefined) {
                localVarQueryParameter['excludeUserId'] = excludeUserId;
            }

            if (excludeApplicationId !== undefined) {
                localVarQueryParameter['excludeApplicationId'] = excludeApplicationId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove the role from an application with the given ID.
         * @summary Remove role from application
         * @param {string} id The unique identifier of the role.
         * @param {string} applicationId The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRolesIdApplicationsApplicationIdDelete: async (id: string, applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRolesIdApplicationsApplicationIdDelete', 'id', id)
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('apiRolesIdApplicationsApplicationIdDelete', 'applicationId', applicationId)
            const localVarPath = `/api/roles/{id}/applications/{applicationId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get applications that have the role assigned with pagination.
         * @summary Get role applications
         * @param {string} id The unique identifier of the role.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRolesIdApplicationsGet: async (id: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRolesIdApplicationsGet', 'id', id)
            const localVarPath = `/api/roles/{id}/applications`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign a role to a list of applications. The role must have the type `Application`.
         * @summary Assign role to applications
         * @param {string} id The unique identifier of the role.
         * @param {ApiRolesIdApplicationsPostRequest} apiRolesIdApplicationsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRolesIdApplicationsPost: async (id: string, apiRolesIdApplicationsPostRequest: ApiRolesIdApplicationsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRolesIdApplicationsPost', 'id', id)
            // verify required parameter 'apiRolesIdApplicationsPostRequest' is not null or undefined
            assertParamExists('apiRolesIdApplicationsPost', 'apiRolesIdApplicationsPostRequest', apiRolesIdApplicationsPostRequest)
            const localVarPath = `/api/roles/{id}/applications`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiRolesIdApplicationsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a role with the given ID.
         * @summary Delete role
         * @param {string} id The unique identifier of the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRolesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRolesIdDelete', 'id', id)
            const localVarPath = `/api/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get role details by ID.
         * @summary Get role
         * @param {string} id The unique identifier of the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRolesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRolesIdGet', 'id', id)
            const localVarPath = `/api/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update role details. This method performs a partial update.
         * @summary Update role
         * @param {string} id The unique identifier of the role.
         * @param {ApiRolesIdPatchRequest} apiRolesIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRolesIdPatch: async (id: string, apiRolesIdPatchRequest: ApiRolesIdPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRolesIdPatch', 'id', id)
            // verify required parameter 'apiRolesIdPatchRequest' is not null or undefined
            assertParamExists('apiRolesIdPatch', 'apiRolesIdPatchRequest', apiRolesIdPatchRequest)
            const localVarPath = `/api/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiRolesIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get API resource scopes (permissions) linked with a role.
         * @summary Get role scopes
         * @param {string} id The unique identifier of the role.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRolesIdScopesGet: async (id: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRolesIdScopesGet', 'id', id)
            const localVarPath = `/api/roles/{id}/scopes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Link a list of API resource scopes (permissions) to a role. The original linked scopes will be kept.
         * @summary Link scopes to role
         * @param {string} id The unique identifier of the role.
         * @param {ApiRolesIdScopesPostRequest} apiRolesIdScopesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRolesIdScopesPost: async (id: string, apiRolesIdScopesPostRequest: ApiRolesIdScopesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRolesIdScopesPost', 'id', id)
            // verify required parameter 'apiRolesIdScopesPostRequest' is not null or undefined
            assertParamExists('apiRolesIdScopesPost', 'apiRolesIdScopesPostRequest', apiRolesIdScopesPostRequest)
            const localVarPath = `/api/roles/{id}/scopes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiRolesIdScopesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unlink an API resource scope (permission) from a role with the given ID.
         * @summary Unlink scope from role
         * @param {string} id The unique identifier of the role.
         * @param {string} scopeId The unique identifier of the scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRolesIdScopesScopeIdDelete: async (id: string, scopeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRolesIdScopesScopeIdDelete', 'id', id)
            // verify required parameter 'scopeId' is not null or undefined
            assertParamExists('apiRolesIdScopesScopeIdDelete', 'scopeId', scopeId)
            const localVarPath = `/api/roles/{id}/scopes/{scopeId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"scopeId"}}`, encodeURIComponent(String(scopeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get users who have the role assigned with pagination.
         * @summary Get role users
         * @param {string} id The unique identifier of the role.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRolesIdUsersGet: async (id: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRolesIdUsersGet', 'id', id)
            const localVarPath = `/api/roles/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign a role to a list of users. The role must have the type `User`.
         * @summary Assign role to users
         * @param {string} id The unique identifier of the role.
         * @param {ApiRolesIdUsersPostRequest} apiRolesIdUsersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRolesIdUsersPost: async (id: string, apiRolesIdUsersPostRequest: ApiRolesIdUsersPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRolesIdUsersPost', 'id', id)
            // verify required parameter 'apiRolesIdUsersPostRequest' is not null or undefined
            assertParamExists('apiRolesIdUsersPost', 'apiRolesIdUsersPostRequest', apiRolesIdUsersPostRequest)
            const localVarPath = `/api/roles/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiRolesIdUsersPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a role from a user with the given ID.
         * @summary Remove role from user
         * @param {string} id The unique identifier of the role.
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRolesIdUsersUserIdDelete: async (id: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRolesIdUsersUserIdDelete', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiRolesIdUsersUserIdDelete', 'userId', userId)
            const localVarPath = `/api/roles/{id}/users/{userId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new role with the given data.
         * @summary Create a role
         * @param {ApiRolesPostRequest} apiRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRolesPost: async (apiRolesPostRequest: ApiRolesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiRolesPostRequest' is not null or undefined
            assertParamExists('apiRolesPost', 'apiRolesPostRequest', apiRolesPostRequest)
            const localVarPath = `/api/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiRolesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesApi - functional programming interface
 * @export
 */
export const RolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RolesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get roles with filters and pagination.
         * @summary Get roles
         * @param {string} [excludeUserId] Exclude roles assigned to a user.
         * @param {string} [excludeApplicationId] Exclude roles assigned to an application.
         * @param {ApiRolesGetTypeEnum} [type] Filter by role type.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRolesGet(excludeUserId?: string, excludeApplicationId?: string, type?: ApiRolesGetTypeEnum, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiRolesGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRolesGet(excludeUserId, excludeApplicationId, type, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.apiRolesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove the role from an application with the given ID.
         * @summary Remove role from application
         * @param {string} id The unique identifier of the role.
         * @param {string} applicationId The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRolesIdApplicationsApplicationIdDelete(id: string, applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRolesIdApplicationsApplicationIdDelete(id, applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.apiRolesIdApplicationsApplicationIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get applications that have the role assigned with pagination.
         * @summary Get role applications
         * @param {string} id The unique identifier of the role.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRolesIdApplicationsGet(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiApplicationsGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRolesIdApplicationsGet(id, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.apiRolesIdApplicationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Assign a role to a list of applications. The role must have the type `Application`.
         * @summary Assign role to applications
         * @param {string} id The unique identifier of the role.
         * @param {ApiRolesIdApplicationsPostRequest} apiRolesIdApplicationsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRolesIdApplicationsPost(id: string, apiRolesIdApplicationsPostRequest: ApiRolesIdApplicationsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRolesIdApplicationsPost(id, apiRolesIdApplicationsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.apiRolesIdApplicationsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a role with the given ID.
         * @summary Delete role
         * @param {string} id The unique identifier of the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRolesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRolesIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.apiRolesIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get role details by ID.
         * @summary Get role
         * @param {string} id The unique identifier of the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRolesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiApplicationsApplicationIdRolesGet200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRolesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.apiRolesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update role details. This method performs a partial update.
         * @summary Update role
         * @param {string} id The unique identifier of the role.
         * @param {ApiRolesIdPatchRequest} apiRolesIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRolesIdPatch(id: string, apiRolesIdPatchRequest: ApiRolesIdPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiApplicationsApplicationIdRolesGet200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRolesIdPatch(id, apiRolesIdPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.apiRolesIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get API resource scopes (permissions) linked with a role.
         * @summary Get role scopes
         * @param {string} id The unique identifier of the role.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRolesIdScopesGet(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiRolesIdScopesGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRolesIdScopesGet(id, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.apiRolesIdScopesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Link a list of API resource scopes (permissions) to a role. The original linked scopes will be kept.
         * @summary Link scopes to role
         * @param {string} id The unique identifier of the role.
         * @param {ApiRolesIdScopesPostRequest} apiRolesIdScopesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRolesIdScopesPost(id: string, apiRolesIdScopesPostRequest: ApiRolesIdScopesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRolesIdScopesPost(id, apiRolesIdScopesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.apiRolesIdScopesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unlink an API resource scope (permission) from a role with the given ID.
         * @summary Unlink scope from role
         * @param {string} id The unique identifier of the role.
         * @param {string} scopeId The unique identifier of the scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRolesIdScopesScopeIdDelete(id: string, scopeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRolesIdScopesScopeIdDelete(id, scopeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.apiRolesIdScopesScopeIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get users who have the role assigned with pagination.
         * @summary Get role users
         * @param {string} id The unique identifier of the role.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRolesIdUsersGet(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiUsersUserIdPatch200Response>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRolesIdUsersGet(id, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.apiRolesIdUsersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Assign a role to a list of users. The role must have the type `User`.
         * @summary Assign role to users
         * @param {string} id The unique identifier of the role.
         * @param {ApiRolesIdUsersPostRequest} apiRolesIdUsersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRolesIdUsersPost(id: string, apiRolesIdUsersPostRequest: ApiRolesIdUsersPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRolesIdUsersPost(id, apiRolesIdUsersPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.apiRolesIdUsersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a role from a user with the given ID.
         * @summary Remove role from user
         * @param {string} id The unique identifier of the role.
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRolesIdUsersUserIdDelete(id: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRolesIdUsersUserIdDelete(id, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.apiRolesIdUsersUserIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new role with the given data.
         * @summary Create a role
         * @param {ApiRolesPostRequest} apiRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRolesPost(apiRolesPostRequest: ApiRolesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiApplicationsApplicationIdRolesGet200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRolesPost(apiRolesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.apiRolesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RolesApi - factory interface
 * @export
 */
export const RolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RolesApiFp(configuration)
    return {
        /**
         * Get roles with filters and pagination.
         * @summary Get roles
         * @param {string} [excludeUserId] Exclude roles assigned to a user.
         * @param {string} [excludeApplicationId] Exclude roles assigned to an application.
         * @param {ApiRolesGetTypeEnum} [type] Filter by role type.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRolesGet(excludeUserId?: string, excludeApplicationId?: string, type?: ApiRolesGetTypeEnum, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ApiRolesGet200ResponseInner>> {
            return localVarFp.apiRolesGet(excludeUserId, excludeApplicationId, type, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove the role from an application with the given ID.
         * @summary Remove role from application
         * @param {string} id The unique identifier of the role.
         * @param {string} applicationId The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRolesIdApplicationsApplicationIdDelete(id: string, applicationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiRolesIdApplicationsApplicationIdDelete(id, applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get applications that have the role assigned with pagination.
         * @summary Get role applications
         * @param {string} id The unique identifier of the role.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRolesIdApplicationsGet(id: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ApiApplicationsGet200ResponseInner>> {
            return localVarFp.apiRolesIdApplicationsGet(id, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign a role to a list of applications. The role must have the type `Application`.
         * @summary Assign role to applications
         * @param {string} id The unique identifier of the role.
         * @param {ApiRolesIdApplicationsPostRequest} apiRolesIdApplicationsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRolesIdApplicationsPost(id: string, apiRolesIdApplicationsPostRequest: ApiRolesIdApplicationsPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiRolesIdApplicationsPost(id, apiRolesIdApplicationsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a role with the given ID.
         * @summary Delete role
         * @param {string} id The unique identifier of the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRolesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiRolesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get role details by ID.
         * @summary Get role
         * @param {string} id The unique identifier of the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRolesIdGet(id: string, options?: any): AxiosPromise<ApiApplicationsApplicationIdRolesGet200ResponseInner> {
            return localVarFp.apiRolesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update role details. This method performs a partial update.
         * @summary Update role
         * @param {string} id The unique identifier of the role.
         * @param {ApiRolesIdPatchRequest} apiRolesIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRolesIdPatch(id: string, apiRolesIdPatchRequest: ApiRolesIdPatchRequest, options?: any): AxiosPromise<ApiApplicationsApplicationIdRolesGet200ResponseInner> {
            return localVarFp.apiRolesIdPatch(id, apiRolesIdPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get API resource scopes (permissions) linked with a role.
         * @summary Get role scopes
         * @param {string} id The unique identifier of the role.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRolesIdScopesGet(id: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ApiRolesIdScopesGet200ResponseInner>> {
            return localVarFp.apiRolesIdScopesGet(id, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Link a list of API resource scopes (permissions) to a role. The original linked scopes will be kept.
         * @summary Link scopes to role
         * @param {string} id The unique identifier of the role.
         * @param {ApiRolesIdScopesPostRequest} apiRolesIdScopesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRolesIdScopesPost(id: string, apiRolesIdScopesPostRequest: ApiRolesIdScopesPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiRolesIdScopesPost(id, apiRolesIdScopesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Unlink an API resource scope (permission) from a role with the given ID.
         * @summary Unlink scope from role
         * @param {string} id The unique identifier of the role.
         * @param {string} scopeId The unique identifier of the scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRolesIdScopesScopeIdDelete(id: string, scopeId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiRolesIdScopesScopeIdDelete(id, scopeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get users who have the role assigned with pagination.
         * @summary Get role users
         * @param {string} id The unique identifier of the role.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRolesIdUsersGet(id: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ApiUsersUserIdPatch200Response>> {
            return localVarFp.apiRolesIdUsersGet(id, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign a role to a list of users. The role must have the type `User`.
         * @summary Assign role to users
         * @param {string} id The unique identifier of the role.
         * @param {ApiRolesIdUsersPostRequest} apiRolesIdUsersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRolesIdUsersPost(id: string, apiRolesIdUsersPostRequest: ApiRolesIdUsersPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiRolesIdUsersPost(id, apiRolesIdUsersPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a role from a user with the given ID.
         * @summary Remove role from user
         * @param {string} id The unique identifier of the role.
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRolesIdUsersUserIdDelete(id: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiRolesIdUsersUserIdDelete(id, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new role with the given data.
         * @summary Create a role
         * @param {ApiRolesPostRequest} apiRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRolesPost(apiRolesPostRequest: ApiRolesPostRequest, options?: any): AxiosPromise<ApiApplicationsApplicationIdRolesGet200ResponseInner> {
            return localVarFp.apiRolesPost(apiRolesPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export class RolesApi extends BaseAPI {
    /**
     * Get roles with filters and pagination.
     * @summary Get roles
     * @param {string} [excludeUserId] Exclude roles assigned to a user.
     * @param {string} [excludeApplicationId] Exclude roles assigned to an application.
     * @param {ApiRolesGetTypeEnum} [type] Filter by role type.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public apiRolesGet(excludeUserId?: string, excludeApplicationId?: string, type?: ApiRolesGetTypeEnum, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).apiRolesGet(excludeUserId, excludeApplicationId, type, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove the role from an application with the given ID.
     * @summary Remove role from application
     * @param {string} id The unique identifier of the role.
     * @param {string} applicationId The unique identifier of the application.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public apiRolesIdApplicationsApplicationIdDelete(id: string, applicationId: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).apiRolesIdApplicationsApplicationIdDelete(id, applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get applications that have the role assigned with pagination.
     * @summary Get role applications
     * @param {string} id The unique identifier of the role.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public apiRolesIdApplicationsGet(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).apiRolesIdApplicationsGet(id, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assign a role to a list of applications. The role must have the type `Application`.
     * @summary Assign role to applications
     * @param {string} id The unique identifier of the role.
     * @param {ApiRolesIdApplicationsPostRequest} apiRolesIdApplicationsPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public apiRolesIdApplicationsPost(id: string, apiRolesIdApplicationsPostRequest: ApiRolesIdApplicationsPostRequest, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).apiRolesIdApplicationsPost(id, apiRolesIdApplicationsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a role with the given ID.
     * @summary Delete role
     * @param {string} id The unique identifier of the role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public apiRolesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).apiRolesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get role details by ID.
     * @summary Get role
     * @param {string} id The unique identifier of the role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public apiRolesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).apiRolesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update role details. This method performs a partial update.
     * @summary Update role
     * @param {string} id The unique identifier of the role.
     * @param {ApiRolesIdPatchRequest} apiRolesIdPatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public apiRolesIdPatch(id: string, apiRolesIdPatchRequest: ApiRolesIdPatchRequest, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).apiRolesIdPatch(id, apiRolesIdPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get API resource scopes (permissions) linked with a role.
     * @summary Get role scopes
     * @param {string} id The unique identifier of the role.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public apiRolesIdScopesGet(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).apiRolesIdScopesGet(id, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Link a list of API resource scopes (permissions) to a role. The original linked scopes will be kept.
     * @summary Link scopes to role
     * @param {string} id The unique identifier of the role.
     * @param {ApiRolesIdScopesPostRequest} apiRolesIdScopesPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public apiRolesIdScopesPost(id: string, apiRolesIdScopesPostRequest: ApiRolesIdScopesPostRequest, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).apiRolesIdScopesPost(id, apiRolesIdScopesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unlink an API resource scope (permission) from a role with the given ID.
     * @summary Unlink scope from role
     * @param {string} id The unique identifier of the role.
     * @param {string} scopeId The unique identifier of the scope.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public apiRolesIdScopesScopeIdDelete(id: string, scopeId: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).apiRolesIdScopesScopeIdDelete(id, scopeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get users who have the role assigned with pagination.
     * @summary Get role users
     * @param {string} id The unique identifier of the role.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public apiRolesIdUsersGet(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).apiRolesIdUsersGet(id, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assign a role to a list of users. The role must have the type `User`.
     * @summary Assign role to users
     * @param {string} id The unique identifier of the role.
     * @param {ApiRolesIdUsersPostRequest} apiRolesIdUsersPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public apiRolesIdUsersPost(id: string, apiRolesIdUsersPostRequest: ApiRolesIdUsersPostRequest, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).apiRolesIdUsersPost(id, apiRolesIdUsersPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a role from a user with the given ID.
     * @summary Remove role from user
     * @param {string} id The unique identifier of the role.
     * @param {string} userId The unique identifier of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public apiRolesIdUsersUserIdDelete(id: string, userId: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).apiRolesIdUsersUserIdDelete(id, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new role with the given data.
     * @summary Create a role
     * @param {ApiRolesPostRequest} apiRolesPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public apiRolesPost(apiRolesPostRequest: ApiRolesPostRequest, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).apiRolesPost(apiRolesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ApiRolesGetTypeEnum = {
    User: 'User',
    MachineToMachine: 'MachineToMachine'
} as const;
export type ApiRolesGetTypeEnum = typeof ApiRolesGetTypeEnum[keyof typeof ApiRolesGetTypeEnum];


/**
 * SSOConnectorProvidersApi - axios parameter creator
 * @export
 */
export const SSOConnectorProvidersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a complete list of supported SSO connector providers.
         * @summary List all the supported SSO connector provider details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSsoConnectorProvidersGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso-connector-providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SSOConnectorProvidersApi - functional programming interface
 * @export
 */
export const SSOConnectorProvidersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SSOConnectorProvidersApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a complete list of supported SSO connector providers.
         * @summary List all the supported SSO connector provider details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSsoConnectorProvidersGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiSsoConnectorProvidersGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSsoConnectorProvidersGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SSOConnectorProvidersApi.apiSsoConnectorProvidersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SSOConnectorProvidersApi - factory interface
 * @export
 */
export const SSOConnectorProvidersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SSOConnectorProvidersApiFp(configuration)
    return {
        /**
         * Get a complete list of supported SSO connector providers.
         * @summary List all the supported SSO connector provider details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSsoConnectorProvidersGet(options?: any): AxiosPromise<Array<ApiSsoConnectorProvidersGet200ResponseInner>> {
            return localVarFp.apiSsoConnectorProvidersGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SSOConnectorProvidersApi - object-oriented interface
 * @export
 * @class SSOConnectorProvidersApi
 * @extends {BaseAPI}
 */
export class SSOConnectorProvidersApi extends BaseAPI {
    /**
     * Get a complete list of supported SSO connector providers.
     * @summary List all the supported SSO connector provider details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SSOConnectorProvidersApi
     */
    public apiSsoConnectorProvidersGet(options?: RawAxiosRequestConfig) {
        return SSOConnectorProvidersApiFp(this.configuration).apiSsoConnectorProvidersGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SSOConnectorsApi - axios parameter creator
 * @export
 */
export const SSOConnectorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get SSO connectors with pagination. In addition to the raw SSO connector data, a copy of fetched or parsed IdP configs and a copy of connector provider\'s data will be attached.
         * @summary List SSO connectors
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSsoConnectorsGet: async (page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso-connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an SSO connector by ID.
         * @summary Delete SSO connector
         * @param {string} id The unique identifier of the sso connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSsoConnectorsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSsoConnectorsIdDelete', 'id', id)
            const localVarPath = `/api/sso-connectors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SSO connector data by ID. In addition to the raw SSO connector data, a copy of fetched or parsed IdP configs and a copy of connector provider\'s data will be attached.
         * @summary Get SSO connector
         * @param {string} id The unique identifier of the sso connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSsoConnectorsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSsoConnectorsIdGet', 'id', id)
            const localVarPath = `/api/sso-connectors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an SSO connector by ID. This method performs a partial update.
         * @summary Update SSO connector
         * @param {string} id The unique identifier of the sso connector.
         * @param {ApiSsoConnectorsIdPatchRequest} apiSsoConnectorsIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSsoConnectorsIdPatch: async (id: string, apiSsoConnectorsIdPatchRequest: ApiSsoConnectorsIdPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSsoConnectorsIdPatch', 'id', id)
            // verify required parameter 'apiSsoConnectorsIdPatchRequest' is not null or undefined
            assertParamExists('apiSsoConnectorsIdPatch', 'apiSsoConnectorsIdPatchRequest', apiSsoConnectorsIdPatchRequest)
            const localVarPath = `/api/sso-connectors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiSsoConnectorsIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an new SSO connector instance for a given provider.
         * @summary Create SSO connector
         * @param {ApiSsoConnectorsPostRequest} apiSsoConnectorsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSsoConnectorsPost: async (apiSsoConnectorsPostRequest: ApiSsoConnectorsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiSsoConnectorsPostRequest' is not null or undefined
            assertParamExists('apiSsoConnectorsPost', 'apiSsoConnectorsPostRequest', apiSsoConnectorsPostRequest)
            const localVarPath = `/api/sso-connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiSsoConnectorsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SSOConnectorsApi - functional programming interface
 * @export
 */
export const SSOConnectorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SSOConnectorsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get SSO connectors with pagination. In addition to the raw SSO connector data, a copy of fetched or parsed IdP configs and a copy of connector provider\'s data will be attached.
         * @summary List SSO connectors
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSsoConnectorsGet(page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiSsoConnectorsGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSsoConnectorsGet(page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SSOConnectorsApi.apiSsoConnectorsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an SSO connector by ID.
         * @summary Delete SSO connector
         * @param {string} id The unique identifier of the sso connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSsoConnectorsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSsoConnectorsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SSOConnectorsApi.apiSsoConnectorsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SSO connector data by ID. In addition to the raw SSO connector data, a copy of fetched or parsed IdP configs and a copy of connector provider\'s data will be attached.
         * @summary Get SSO connector
         * @param {string} id The unique identifier of the sso connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSsoConnectorsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiSsoConnectorsGet200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSsoConnectorsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SSOConnectorsApi.apiSsoConnectorsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an SSO connector by ID. This method performs a partial update.
         * @summary Update SSO connector
         * @param {string} id The unique identifier of the sso connector.
         * @param {ApiSsoConnectorsIdPatchRequest} apiSsoConnectorsIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSsoConnectorsIdPatch(id: string, apiSsoConnectorsIdPatchRequest: ApiSsoConnectorsIdPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiSsoConnectorsGet200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSsoConnectorsIdPatch(id, apiSsoConnectorsIdPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SSOConnectorsApi.apiSsoConnectorsIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an new SSO connector instance for a given provider.
         * @summary Create SSO connector
         * @param {ApiSsoConnectorsPostRequest} apiSsoConnectorsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSsoConnectorsPost(apiSsoConnectorsPostRequest: ApiSsoConnectorsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiSsoConnectorsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSsoConnectorsPost(apiSsoConnectorsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SSOConnectorsApi.apiSsoConnectorsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SSOConnectorsApi - factory interface
 * @export
 */
export const SSOConnectorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SSOConnectorsApiFp(configuration)
    return {
        /**
         * Get SSO connectors with pagination. In addition to the raw SSO connector data, a copy of fetched or parsed IdP configs and a copy of connector provider\'s data will be attached.
         * @summary List SSO connectors
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSsoConnectorsGet(page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ApiSsoConnectorsGet200ResponseInner>> {
            return localVarFp.apiSsoConnectorsGet(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an SSO connector by ID.
         * @summary Delete SSO connector
         * @param {string} id The unique identifier of the sso connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSsoConnectorsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiSsoConnectorsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SSO connector data by ID. In addition to the raw SSO connector data, a copy of fetched or parsed IdP configs and a copy of connector provider\'s data will be attached.
         * @summary Get SSO connector
         * @param {string} id The unique identifier of the sso connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSsoConnectorsIdGet(id: string, options?: any): AxiosPromise<ApiSsoConnectorsGet200ResponseInner> {
            return localVarFp.apiSsoConnectorsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an SSO connector by ID. This method performs a partial update.
         * @summary Update SSO connector
         * @param {string} id The unique identifier of the sso connector.
         * @param {ApiSsoConnectorsIdPatchRequest} apiSsoConnectorsIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSsoConnectorsIdPatch(id: string, apiSsoConnectorsIdPatchRequest: ApiSsoConnectorsIdPatchRequest, options?: any): AxiosPromise<ApiSsoConnectorsGet200ResponseInner> {
            return localVarFp.apiSsoConnectorsIdPatch(id, apiSsoConnectorsIdPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an new SSO connector instance for a given provider.
         * @summary Create SSO connector
         * @param {ApiSsoConnectorsPostRequest} apiSsoConnectorsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSsoConnectorsPost(apiSsoConnectorsPostRequest: ApiSsoConnectorsPostRequest, options?: any): AxiosPromise<ApiSsoConnectorsPost200Response> {
            return localVarFp.apiSsoConnectorsPost(apiSsoConnectorsPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SSOConnectorsApi - object-oriented interface
 * @export
 * @class SSOConnectorsApi
 * @extends {BaseAPI}
 */
export class SSOConnectorsApi extends BaseAPI {
    /**
     * Get SSO connectors with pagination. In addition to the raw SSO connector data, a copy of fetched or parsed IdP configs and a copy of connector provider\'s data will be attached.
     * @summary List SSO connectors
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SSOConnectorsApi
     */
    public apiSsoConnectorsGet(page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return SSOConnectorsApiFp(this.configuration).apiSsoConnectorsGet(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an SSO connector by ID.
     * @summary Delete SSO connector
     * @param {string} id The unique identifier of the sso connector.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SSOConnectorsApi
     */
    public apiSsoConnectorsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return SSOConnectorsApiFp(this.configuration).apiSsoConnectorsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SSO connector data by ID. In addition to the raw SSO connector data, a copy of fetched or parsed IdP configs and a copy of connector provider\'s data will be attached.
     * @summary Get SSO connector
     * @param {string} id The unique identifier of the sso connector.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SSOConnectorsApi
     */
    public apiSsoConnectorsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return SSOConnectorsApiFp(this.configuration).apiSsoConnectorsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an SSO connector by ID. This method performs a partial update.
     * @summary Update SSO connector
     * @param {string} id The unique identifier of the sso connector.
     * @param {ApiSsoConnectorsIdPatchRequest} apiSsoConnectorsIdPatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SSOConnectorsApi
     */
    public apiSsoConnectorsIdPatch(id: string, apiSsoConnectorsIdPatchRequest: ApiSsoConnectorsIdPatchRequest, options?: RawAxiosRequestConfig) {
        return SSOConnectorsApiFp(this.configuration).apiSsoConnectorsIdPatch(id, apiSsoConnectorsIdPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an new SSO connector instance for a given provider.
     * @summary Create SSO connector
     * @param {ApiSsoConnectorsPostRequest} apiSsoConnectorsPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SSOConnectorsApi
     */
    public apiSsoConnectorsPost(apiSsoConnectorsPostRequest: ApiSsoConnectorsPostRequest, options?: RawAxiosRequestConfig) {
        return SSOConnectorsApiFp(this.configuration).apiSsoConnectorsPost(apiSsoConnectorsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SignInExperienceApi - axios parameter creator
 * @export
 */
export const SignInExperienceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the default sign-in experience settings.
         * @summary Get default sign-in experience settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignInExpGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sign-in-exp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the default sign-in experience settings with the provided data.
         * @summary Update default sign-in experience settings
         * @param {ApiSignInExpPatchRequest} apiSignInExpPatchRequest 
         * @param {string} [removeUnusedDemoSocialConnector] Whether to remove unused demo social connectors. (These demo social connectors are only used during cloud user onboarding)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignInExpPatch: async (apiSignInExpPatchRequest: ApiSignInExpPatchRequest, removeUnusedDemoSocialConnector?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiSignInExpPatchRequest' is not null or undefined
            assertParamExists('apiSignInExpPatch', 'apiSignInExpPatchRequest', apiSignInExpPatchRequest)
            const localVarPath = `/api/sign-in-exp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (removeUnusedDemoSocialConnector !== undefined) {
                localVarQueryParameter['removeUnusedDemoSocialConnector'] = removeUnusedDemoSocialConnector;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiSignInExpPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SignInExperienceApi - functional programming interface
 * @export
 */
export const SignInExperienceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SignInExperienceApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the default sign-in experience settings.
         * @summary Get default sign-in experience settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSignInExpGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiSignInExpGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSignInExpGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SignInExperienceApi.apiSignInExpGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the default sign-in experience settings with the provided data.
         * @summary Update default sign-in experience settings
         * @param {ApiSignInExpPatchRequest} apiSignInExpPatchRequest 
         * @param {string} [removeUnusedDemoSocialConnector] Whether to remove unused demo social connectors. (These demo social connectors are only used during cloud user onboarding)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSignInExpPatch(apiSignInExpPatchRequest: ApiSignInExpPatchRequest, removeUnusedDemoSocialConnector?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiSignInExpPatch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSignInExpPatch(apiSignInExpPatchRequest, removeUnusedDemoSocialConnector, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SignInExperienceApi.apiSignInExpPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SignInExperienceApi - factory interface
 * @export
 */
export const SignInExperienceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SignInExperienceApiFp(configuration)
    return {
        /**
         * Get the default sign-in experience settings.
         * @summary Get default sign-in experience settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignInExpGet(options?: any): AxiosPromise<ApiSignInExpGet200Response> {
            return localVarFp.apiSignInExpGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Update the default sign-in experience settings with the provided data.
         * @summary Update default sign-in experience settings
         * @param {ApiSignInExpPatchRequest} apiSignInExpPatchRequest 
         * @param {string} [removeUnusedDemoSocialConnector] Whether to remove unused demo social connectors. (These demo social connectors are only used during cloud user onboarding)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignInExpPatch(apiSignInExpPatchRequest: ApiSignInExpPatchRequest, removeUnusedDemoSocialConnector?: string, options?: any): AxiosPromise<ApiSignInExpPatch200Response> {
            return localVarFp.apiSignInExpPatch(apiSignInExpPatchRequest, removeUnusedDemoSocialConnector, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SignInExperienceApi - object-oriented interface
 * @export
 * @class SignInExperienceApi
 * @extends {BaseAPI}
 */
export class SignInExperienceApi extends BaseAPI {
    /**
     * Get the default sign-in experience settings.
     * @summary Get default sign-in experience settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignInExperienceApi
     */
    public apiSignInExpGet(options?: RawAxiosRequestConfig) {
        return SignInExperienceApiFp(this.configuration).apiSignInExpGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the default sign-in experience settings with the provided data.
     * @summary Update default sign-in experience settings
     * @param {ApiSignInExpPatchRequest} apiSignInExpPatchRequest 
     * @param {string} [removeUnusedDemoSocialConnector] Whether to remove unused demo social connectors. (These demo social connectors are only used during cloud user onboarding)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignInExperienceApi
     */
    public apiSignInExpPatch(apiSignInExpPatchRequest: ApiSignInExpPatchRequest, removeUnusedDemoSocialConnector?: string, options?: RawAxiosRequestConfig) {
        return SignInExperienceApiFp(this.configuration).apiSignInExpPatch(apiSignInExpPatchRequest, removeUnusedDemoSocialConnector, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The traditional health check API. No authentication needed.  > **Note** > Even if 204 is returned, it does not guarantee all the APIs are working properly since they may depend on additional resources or external services.
         * @summary Health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStatusGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatusApiAxiosParamCreator(configuration)
    return {
        /**
         * The traditional health check API. No authentication needed.  > **Note** > Even if 204 is returned, it does not guarantee all the APIs are working properly since they may depend on additional resources or external services.
         * @summary Health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStatusGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStatusGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusApi.apiStatusGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatusApiFp(configuration)
    return {
        /**
         * The traditional health check API. No authentication needed.  > **Note** > Even if 204 is returned, it does not guarantee all the APIs are working properly since they may depend on additional resources or external services.
         * @summary Health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStatusGet(options?: any): AxiosPromise<void> {
            return localVarFp.apiStatusGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
    /**
     * The traditional health check API. No authentication needed.  > **Note** > Even if 204 is returned, it does not guarantee all the APIs are working properly since they may depend on additional resources or external services.
     * @summary Health check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public apiStatusGet(options?: RawAxiosRequestConfig) {
        return StatusApiFp(this.configuration).apiStatusGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SwaggerJsonApi - axios parameter creator
 * @export
 */
export const SwaggerJsonApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The endpoint for the current JSON document. The JSON conforms to the [OpenAPI v3.0.1](https://spec.openapis.org/oas/v3.0.1) (a.k.a. Swagger) specification.
         * @summary Get Swagger JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSwaggerJsonGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/swagger.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SwaggerJsonApi - functional programming interface
 * @export
 */
export const SwaggerJsonApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SwaggerJsonApiAxiosParamCreator(configuration)
    return {
        /**
         * The endpoint for the current JSON document. The JSON conforms to the [OpenAPI v3.0.1](https://spec.openapis.org/oas/v3.0.1) (a.k.a. Swagger) specification.
         * @summary Get Swagger JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSwaggerJsonGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSwaggerJsonGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SwaggerJsonApi.apiSwaggerJsonGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SwaggerJsonApi - factory interface
 * @export
 */
export const SwaggerJsonApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SwaggerJsonApiFp(configuration)
    return {
        /**
         * The endpoint for the current JSON document. The JSON conforms to the [OpenAPI v3.0.1](https://spec.openapis.org/oas/v3.0.1) (a.k.a. Swagger) specification.
         * @summary Get Swagger JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSwaggerJsonGet(options?: any): AxiosPromise<void> {
            return localVarFp.apiSwaggerJsonGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SwaggerJsonApi - object-oriented interface
 * @export
 * @class SwaggerJsonApi
 * @extends {BaseAPI}
 */
export class SwaggerJsonApi extends BaseAPI {
    /**
     * The endpoint for the current JSON document. The JSON conforms to the [OpenAPI v3.0.1](https://spec.openapis.org/oas/v3.0.1) (a.k.a. Swagger) specification.
     * @summary Get Swagger JSON
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SwaggerJsonApi
     */
    public apiSwaggerJsonGet(options?: RawAxiosRequestConfig) {
        return SwaggerJsonApiFp(this.configuration).apiSwaggerJsonGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SystemsApi - axios parameter creator
 * @export
 */
export const SystemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the application constants.
         * @summary Get the application constants.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSystemsApplicationGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/systems/application`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemsApi - functional programming interface
 * @export
 */
export const SystemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the application constants.
         * @summary Get the application constants.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSystemsApplicationGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiSystemsApplicationGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSystemsApplicationGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemsApi.apiSystemsApplicationGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SystemsApi - factory interface
 * @export
 */
export const SystemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemsApiFp(configuration)
    return {
        /**
         * Get the application constants.
         * @summary Get the application constants.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSystemsApplicationGet(options?: any): AxiosPromise<ApiSystemsApplicationGet200Response> {
            return localVarFp.apiSystemsApplicationGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemsApi - object-oriented interface
 * @export
 * @class SystemsApi
 * @extends {BaseAPI}
 */
export class SystemsApi extends BaseAPI {
    /**
     * Get the application constants.
     * @summary Get the application constants.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public apiSystemsApplicationGet(options?: RawAxiosRequestConfig) {
        return SystemsApiFp(this.configuration).apiSystemsApplicationGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserAssetsApi - axios parameter creator
 * @export
 */
export const UserAssetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Upload a user asset.
         * @summary Upload asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserAssetsPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user-assets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user assets service status.
         * @summary Get service status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserAssetsServiceStatusGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user-assets/service-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserAssetsApi - functional programming interface
 * @export
 */
export const UserAssetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserAssetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Upload a user asset.
         * @summary Upload asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserAssetsPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserAssetsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserAssetsPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserAssetsApi.apiUserAssetsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user assets service status.
         * @summary Get service status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserAssetsServiceStatusGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUserAssetsServiceStatusGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserAssetsServiceStatusGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserAssetsApi.apiUserAssetsServiceStatusGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserAssetsApi - factory interface
 * @export
 */
export const UserAssetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserAssetsApiFp(configuration)
    return {
        /**
         * Upload a user asset.
         * @summary Upload asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserAssetsPost(options?: any): AxiosPromise<ApiUserAssetsPost200Response> {
            return localVarFp.apiUserAssetsPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Get user assets service status.
         * @summary Get service status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserAssetsServiceStatusGet(options?: any): AxiosPromise<ApiUserAssetsServiceStatusGet200Response> {
            return localVarFp.apiUserAssetsServiceStatusGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserAssetsApi - object-oriented interface
 * @export
 * @class UserAssetsApi
 * @extends {BaseAPI}
 */
export class UserAssetsApi extends BaseAPI {
    /**
     * Upload a user asset.
     * @summary Upload asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAssetsApi
     */
    public apiUserAssetsPost(options?: RawAxiosRequestConfig) {
        return UserAssetsApiFp(this.configuration).apiUserAssetsPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user assets service status.
     * @summary Get service status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAssetsApi
     */
    public apiUserAssetsServiceStatusGet(options?: RawAxiosRequestConfig) {
        return UserAssetsApiFp(this.configuration).apiUserAssetsServiceStatusGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get users with filters and pagination.  Logto provides a very flexible way to query users. You can filter users by almost any fields with multiple modes. To learn more about the query syntax, please refer to [Advanced user search](https://docs.logto.io/docs/recipes/manage-users/advanced-user-search/).
         * @summary Get users
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersGet: async (page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user with the given data.
         * @summary Create user
         * @param {ApiUsersPostRequest} apiUsersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersPost: async (apiUsersPostRequest: ApiUsersPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiUsersPostRequest' is not null or undefined
            assertParamExists('apiUsersPost', 'apiUsersPostRequest', apiUsersPostRequest)
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUsersPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get custom data for the given user ID.
         * @summary Get user custom data
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdCustomDataGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiUsersUserIdCustomDataGet', 'userId', userId)
            const localVarPath = `/api/users/{userId}/custom-data`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update custom data for the given user ID. This method performs a partial update of the custom data object.
         * @summary Update user custom data
         * @param {string} userId The unique identifier of the user.
         * @param {ApiUsersUserIdCustomDataPatchRequest} apiUsersUserIdCustomDataPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdCustomDataPatch: async (userId: string, apiUsersUserIdCustomDataPatchRequest: ApiUsersUserIdCustomDataPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiUsersUserIdCustomDataPatch', 'userId', userId)
            // verify required parameter 'apiUsersUserIdCustomDataPatchRequest' is not null or undefined
            assertParamExists('apiUsersUserIdCustomDataPatch', 'apiUsersUserIdCustomDataPatchRequest', apiUsersUserIdCustomDataPatchRequest)
            const localVarPath = `/api/users/{userId}/custom-data`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUsersUserIdCustomDataPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete user with the given ID. Note all associated data will be deleted cascadingly.
         * @summary Delete user
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdDelete: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiUsersUserIdDelete', 'userId', userId)
            const localVarPath = `/api/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user data for the given ID.
         * @summary Get user
         * @param {string} userId The unique identifier of the user.
         * @param {string} [includeSsoIdentities] If it\&#39;s provided with a truthy value (&#x60;true&#x60;, &#x60;1&#x60;, &#x60;yes&#x60;), each user in the response will include a &#x60;ssoIdentities&#x60; property containing a list of SSO identities associated with the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdGet: async (userId: string, includeSsoIdentities?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiUsersUserIdGet', 'userId', userId)
            const localVarPath = `/api/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeSsoIdentities !== undefined) {
                localVarQueryParameter['includeSsoIdentities'] = includeSsoIdentities;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if the user with the given ID has a password set.
         * @summary Check if user has password
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdHasPasswordGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiUsersUserIdHasPasswordGet', 'userId', userId)
            const localVarPath = `/api/users/{userId}/has-password`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Link authenticated user identity from a social platform to a Logto user.  The usage of this API is usually coupled with `POST /connectors/:connectorId/authorization-uri`. With the help of these pair of APIs, you can implement a user profile page with the link social account feature in your application.  Note: Currently due to technical limitations, this API does not support the following connectors that rely on Logto interaction session: `@logto/connector-apple`, `@logto/connector-saml`, `@logto/connector-oidc` and `@logto/connector-oauth`.
         * @summary Link social identity to user
         * @param {string} userId The unique identifier of the user.
         * @param {ApiUsersUserIdIdentitiesPostRequest} apiUsersUserIdIdentitiesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdIdentitiesPost: async (userId: string, apiUsersUserIdIdentitiesPostRequest: ApiUsersUserIdIdentitiesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiUsersUserIdIdentitiesPost', 'userId', userId)
            // verify required parameter 'apiUsersUserIdIdentitiesPostRequest' is not null or undefined
            assertParamExists('apiUsersUserIdIdentitiesPost', 'apiUsersUserIdIdentitiesPostRequest', apiUsersUserIdIdentitiesPostRequest)
            const localVarPath = `/api/users/{userId}/identities`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUsersUserIdIdentitiesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a social identity from the user.
         * @summary Delete social identity from user
         * @param {string} userId The unique identifier of the user.
         * @param {string} target 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdIdentitiesTargetDelete: async (userId: string, target: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiUsersUserIdIdentitiesTargetDelete', 'userId', userId)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('apiUsersUserIdIdentitiesTargetDelete', 'target', target)
            const localVarPath = `/api/users/{userId}/identities/{target}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Directly update a social identity of the user.
         * @summary Update social identity of user
         * @param {string} userId The unique identifier of the user.
         * @param {string} target 
         * @param {ApiUsersUserIdIdentitiesTargetPutRequest} apiUsersUserIdIdentitiesTargetPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdIdentitiesTargetPut: async (userId: string, target: string, apiUsersUserIdIdentitiesTargetPutRequest: ApiUsersUserIdIdentitiesTargetPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiUsersUserIdIdentitiesTargetPut', 'userId', userId)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('apiUsersUserIdIdentitiesTargetPut', 'target', target)
            // verify required parameter 'apiUsersUserIdIdentitiesTargetPutRequest' is not null or undefined
            assertParamExists('apiUsersUserIdIdentitiesTargetPut', 'apiUsersUserIdIdentitiesTargetPutRequest', apiUsersUserIdIdentitiesTargetPutRequest)
            const localVarPath = `/api/users/{userId}/identities/{target}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUsersUserIdIdentitiesTargetPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user suspension status for the given ID.
         * @summary Update user suspension status
         * @param {string} userId The unique identifier of the user.
         * @param {ApiUsersUserIdIsSuspendedPatchRequest} apiUsersUserIdIsSuspendedPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdIsSuspendedPatch: async (userId: string, apiUsersUserIdIsSuspendedPatchRequest: ApiUsersUserIdIsSuspendedPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiUsersUserIdIsSuspendedPatch', 'userId', userId)
            // verify required parameter 'apiUsersUserIdIsSuspendedPatchRequest' is not null or undefined
            assertParamExists('apiUsersUserIdIsSuspendedPatch', 'apiUsersUserIdIsSuspendedPatchRequest', apiUsersUserIdIsSuspendedPatchRequest)
            const localVarPath = `/api/users/{userId}/is-suspended`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUsersUserIdIsSuspendedPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a user\'s existing MFA verifications for a given user ID.
         * @summary Get user\'s MFA verifications
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdMfaVerificationsGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiUsersUserIdMfaVerificationsGet', 'userId', userId)
            const localVarPath = `/api/users/{userId}/mfa-verifications`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new MFA verification for a given user ID.
         * @summary Create an MFA verification for a user
         * @param {string} userId The unique identifier of the user.
         * @param {ApiUsersUserIdMfaVerificationsPostRequest} apiUsersUserIdMfaVerificationsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdMfaVerificationsPost: async (userId: string, apiUsersUserIdMfaVerificationsPostRequest: ApiUsersUserIdMfaVerificationsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiUsersUserIdMfaVerificationsPost', 'userId', userId)
            // verify required parameter 'apiUsersUserIdMfaVerificationsPostRequest' is not null or undefined
            assertParamExists('apiUsersUserIdMfaVerificationsPost', 'apiUsersUserIdMfaVerificationsPostRequest', apiUsersUserIdMfaVerificationsPostRequest)
            const localVarPath = `/api/users/{userId}/mfa-verifications`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUsersUserIdMfaVerificationsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an MFA verification for the user with the given verification ID. The verification ID must be associated with the given user ID.
         * @summary Delete an MFA verification for a user
         * @param {string} userId The unique identifier of the user.
         * @param {string} verificationId The unique identifier of the verification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdMfaVerificationsVerificationIdDelete: async (userId: string, verificationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiUsersUserIdMfaVerificationsVerificationIdDelete', 'userId', userId)
            // verify required parameter 'verificationId' is not null or undefined
            assertParamExists('apiUsersUserIdMfaVerificationsVerificationIdDelete', 'verificationId', verificationId)
            const localVarPath = `/api/users/{userId}/mfa-verifications/{verificationId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"verificationId"}}`, encodeURIComponent(String(verificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all organizations that the user is a member of. In each organization object, the user\'s roles in that organization are included in the `organizationRoles` array.
         * @summary Get organizations for a user
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdOrganizationsGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiUsersUserIdOrganizationsGet', 'userId', userId)
            const localVarPath = `/api/users/{userId}/organizations`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user password for the given ID.
         * @summary Update user password
         * @param {string} userId The unique identifier of the user.
         * @param {ApiUsersUserIdPasswordPatchRequest} apiUsersUserIdPasswordPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdPasswordPatch: async (userId: string, apiUsersUserIdPasswordPatchRequest: ApiUsersUserIdPasswordPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiUsersUserIdPasswordPatch', 'userId', userId)
            // verify required parameter 'apiUsersUserIdPasswordPatchRequest' is not null or undefined
            assertParamExists('apiUsersUserIdPasswordPatch', 'apiUsersUserIdPasswordPatchRequest', apiUsersUserIdPasswordPatchRequest)
            const localVarPath = `/api/users/{userId}/password`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUsersUserIdPasswordPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test if the given password matches the user\'s password.
         * @summary Verify user password
         * @param {string} userId The unique identifier of the user.
         * @param {ApiUsersUserIdPasswordVerifyPostRequest} apiUsersUserIdPasswordVerifyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdPasswordVerifyPost: async (userId: string, apiUsersUserIdPasswordVerifyPostRequest: ApiUsersUserIdPasswordVerifyPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiUsersUserIdPasswordVerifyPost', 'userId', userId)
            // verify required parameter 'apiUsersUserIdPasswordVerifyPostRequest' is not null or undefined
            assertParamExists('apiUsersUserIdPasswordVerifyPost', 'apiUsersUserIdPasswordVerifyPostRequest', apiUsersUserIdPasswordVerifyPostRequest)
            const localVarPath = `/api/users/{userId}/password/verify`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUsersUserIdPasswordVerifyPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user data for the given ID. This method performs a partial update.
         * @summary Update user
         * @param {string} userId The unique identifier of the user.
         * @param {ApiUsersUserIdPatchRequest} apiUsersUserIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdPatch: async (userId: string, apiUsersUserIdPatchRequest: ApiUsersUserIdPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiUsersUserIdPatch', 'userId', userId)
            // verify required parameter 'apiUsersUserIdPatchRequest' is not null or undefined
            assertParamExists('apiUsersUserIdPatch', 'apiUsersUserIdPatchRequest', apiUsersUserIdPatchRequest)
            const localVarPath = `/api/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUsersUserIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update profile for the given user ID. This method performs a partial update of the profile object.
         * @summary Update user profile
         * @param {string} userId The unique identifier of the user.
         * @param {ApiUsersUserIdProfilePatchRequest} apiUsersUserIdProfilePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdProfilePatch: async (userId: string, apiUsersUserIdProfilePatchRequest: ApiUsersUserIdProfilePatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiUsersUserIdProfilePatch', 'userId', userId)
            // verify required parameter 'apiUsersUserIdProfilePatchRequest' is not null or undefined
            assertParamExists('apiUsersUserIdProfilePatch', 'apiUsersUserIdProfilePatchRequest', apiUsersUserIdProfilePatchRequest)
            const localVarPath = `/api/users/{userId}/profile`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiUsersUserIdProfilePatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get API resource roles assigned to the user with pagination.
         * @summary Get roles for user
         * @param {string} userId The unique identifier of the user.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdRolesGet: async (userId: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiUsersUserIdRolesGet', 'userId', userId)
            const localVarPath = `/api/users/{userId}/roles`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign API resource roles to the user. The roles will be added to the existing roles.
         * @summary Assign roles to user
         * @param {string} userId The unique identifier of the user.
         * @param {ApiApplicationsApplicationIdRolesPostRequest} apiApplicationsApplicationIdRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdRolesPost: async (userId: string, apiApplicationsApplicationIdRolesPostRequest: ApiApplicationsApplicationIdRolesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiUsersUserIdRolesPost', 'userId', userId)
            // verify required parameter 'apiApplicationsApplicationIdRolesPostRequest' is not null or undefined
            assertParamExists('apiUsersUserIdRolesPost', 'apiApplicationsApplicationIdRolesPostRequest', apiApplicationsApplicationIdRolesPostRequest)
            const localVarPath = `/api/users/{userId}/roles`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiApplicationsApplicationIdRolesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update API resource roles assigned to the user. This will replace the existing roles.
         * @summary Update roles for user
         * @param {string} userId The unique identifier of the user.
         * @param {ApiApplicationsApplicationIdRolesPostRequest} apiApplicationsApplicationIdRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdRolesPut: async (userId: string, apiApplicationsApplicationIdRolesPostRequest: ApiApplicationsApplicationIdRolesPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiUsersUserIdRolesPut', 'userId', userId)
            // verify required parameter 'apiApplicationsApplicationIdRolesPostRequest' is not null or undefined
            assertParamExists('apiUsersUserIdRolesPut', 'apiApplicationsApplicationIdRolesPostRequest', apiApplicationsApplicationIdRolesPostRequest)
            const localVarPath = `/api/users/{userId}/roles`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiApplicationsApplicationIdRolesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an API resource role from the user.
         * @summary Remove role from user
         * @param {string} userId The unique identifier of the user.
         * @param {string} roleId The unique identifier of the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdRolesRoleIdDelete: async (userId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiUsersUserIdRolesRoleIdDelete', 'userId', userId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('apiUsersUserIdRolesRoleIdDelete', 'roleId', roleId)
            const localVarPath = `/api/users/{userId}/roles/{roleId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Get users with filters and pagination.  Logto provides a very flexible way to query users. You can filter users by almost any fields with multiple modes. To learn more about the query syntax, please refer to [Advanced user search](https://docs.logto.io/docs/recipes/manage-users/advanced-user-search/).
         * @summary Get users
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersGet(page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiUsersUserIdPatch200Response>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersGet(page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiUsersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new user with the given data.
         * @summary Create user
         * @param {ApiUsersPostRequest} apiUsersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersPost(apiUsersPostRequest: ApiUsersPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUsersUserIdPatch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersPost(apiUsersPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiUsersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get custom data for the given user ID.
         * @summary Get user custom data
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersUserIdCustomDataGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersUserIdCustomDataGet(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiUsersUserIdCustomDataGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update custom data for the given user ID. This method performs a partial update of the custom data object.
         * @summary Update user custom data
         * @param {string} userId The unique identifier of the user.
         * @param {ApiUsersUserIdCustomDataPatchRequest} apiUsersUserIdCustomDataPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersUserIdCustomDataPatch(userId: string, apiUsersUserIdCustomDataPatchRequest: ApiUsersUserIdCustomDataPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersUserIdCustomDataPatch(userId, apiUsersUserIdCustomDataPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiUsersUserIdCustomDataPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete user with the given ID. Note all associated data will be deleted cascadingly.
         * @summary Delete user
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersUserIdDelete(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersUserIdDelete(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiUsersUserIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user data for the given ID.
         * @summary Get user
         * @param {string} userId The unique identifier of the user.
         * @param {string} [includeSsoIdentities] If it\&#39;s provided with a truthy value (&#x60;true&#x60;, &#x60;1&#x60;, &#x60;yes&#x60;), each user in the response will include a &#x60;ssoIdentities&#x60; property containing a list of SSO identities associated with the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersUserIdGet(userId: string, includeSsoIdentities?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUsersUserIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersUserIdGet(userId, includeSsoIdentities, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiUsersUserIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check if the user with the given ID has a password set.
         * @summary Check if user has password
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersUserIdHasPasswordGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUsersUserIdHasPasswordGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersUserIdHasPasswordGet(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiUsersUserIdHasPasswordGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Link authenticated user identity from a social platform to a Logto user.  The usage of this API is usually coupled with `POST /connectors/:connectorId/authorization-uri`. With the help of these pair of APIs, you can implement a user profile page with the link social account feature in your application.  Note: Currently due to technical limitations, this API does not support the following connectors that rely on Logto interaction session: `@logto/connector-apple`, `@logto/connector-saml`, `@logto/connector-oidc` and `@logto/connector-oauth`.
         * @summary Link social identity to user
         * @param {string} userId The unique identifier of the user.
         * @param {ApiUsersUserIdIdentitiesPostRequest} apiUsersUserIdIdentitiesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersUserIdIdentitiesPost(userId: string, apiUsersUserIdIdentitiesPostRequest: ApiUsersUserIdIdentitiesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserIdentitiesValue; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersUserIdIdentitiesPost(userId, apiUsersUserIdIdentitiesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiUsersUserIdIdentitiesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a social identity from the user.
         * @summary Delete social identity from user
         * @param {string} userId The unique identifier of the user.
         * @param {string} target 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersUserIdIdentitiesTargetDelete(userId: string, target: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUsersUserIdPatch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersUserIdIdentitiesTargetDelete(userId, target, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiUsersUserIdIdentitiesTargetDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Directly update a social identity of the user.
         * @summary Update social identity of user
         * @param {string} userId The unique identifier of the user.
         * @param {string} target 
         * @param {ApiUsersUserIdIdentitiesTargetPutRequest} apiUsersUserIdIdentitiesTargetPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersUserIdIdentitiesTargetPut(userId: string, target: string, apiUsersUserIdIdentitiesTargetPutRequest: ApiUsersUserIdIdentitiesTargetPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserIdentitiesValue; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersUserIdIdentitiesTargetPut(userId, target, apiUsersUserIdIdentitiesTargetPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiUsersUserIdIdentitiesTargetPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update user suspension status for the given ID.
         * @summary Update user suspension status
         * @param {string} userId The unique identifier of the user.
         * @param {ApiUsersUserIdIsSuspendedPatchRequest} apiUsersUserIdIsSuspendedPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersUserIdIsSuspendedPatch(userId: string, apiUsersUserIdIsSuspendedPatchRequest: ApiUsersUserIdIsSuspendedPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUsersUserIdPatch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersUserIdIsSuspendedPatch(userId, apiUsersUserIdIsSuspendedPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiUsersUserIdIsSuspendedPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a user\'s existing MFA verifications for a given user ID.
         * @summary Get user\'s MFA verifications
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersUserIdMfaVerificationsGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiUsersUserIdMfaVerificationsGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersUserIdMfaVerificationsGet(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiUsersUserIdMfaVerificationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new MFA verification for a given user ID.
         * @summary Create an MFA verification for a user
         * @param {string} userId The unique identifier of the user.
         * @param {ApiUsersUserIdMfaVerificationsPostRequest} apiUsersUserIdMfaVerificationsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersUserIdMfaVerificationsPost(userId: string, apiUsersUserIdMfaVerificationsPostRequest: ApiUsersUserIdMfaVerificationsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUsersUserIdMfaVerificationsPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersUserIdMfaVerificationsPost(userId, apiUsersUserIdMfaVerificationsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiUsersUserIdMfaVerificationsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an MFA verification for the user with the given verification ID. The verification ID must be associated with the given user ID.
         * @summary Delete an MFA verification for a user
         * @param {string} userId The unique identifier of the user.
         * @param {string} verificationId The unique identifier of the verification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersUserIdMfaVerificationsVerificationIdDelete(userId: string, verificationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersUserIdMfaVerificationsVerificationIdDelete(userId, verificationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiUsersUserIdMfaVerificationsVerificationIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all organizations that the user is a member of. In each organization object, the user\'s roles in that organization are included in the `organizationRoles` array.
         * @summary Get organizations for a user
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersUserIdOrganizationsGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiUsersUserIdOrganizationsGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersUserIdOrganizationsGet(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiUsersUserIdOrganizationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update user password for the given ID.
         * @summary Update user password
         * @param {string} userId The unique identifier of the user.
         * @param {ApiUsersUserIdPasswordPatchRequest} apiUsersUserIdPasswordPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersUserIdPasswordPatch(userId: string, apiUsersUserIdPasswordPatchRequest: ApiUsersUserIdPasswordPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUsersUserIdPatch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersUserIdPasswordPatch(userId, apiUsersUserIdPasswordPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiUsersUserIdPasswordPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test if the given password matches the user\'s password.
         * @summary Verify user password
         * @param {string} userId The unique identifier of the user.
         * @param {ApiUsersUserIdPasswordVerifyPostRequest} apiUsersUserIdPasswordVerifyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersUserIdPasswordVerifyPost(userId: string, apiUsersUserIdPasswordVerifyPostRequest: ApiUsersUserIdPasswordVerifyPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersUserIdPasswordVerifyPost(userId, apiUsersUserIdPasswordVerifyPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiUsersUserIdPasswordVerifyPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update user data for the given ID. This method performs a partial update.
         * @summary Update user
         * @param {string} userId The unique identifier of the user.
         * @param {ApiUsersUserIdPatchRequest} apiUsersUserIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersUserIdPatch(userId: string, apiUsersUserIdPatchRequest: ApiUsersUserIdPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUsersUserIdPatch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersUserIdPatch(userId, apiUsersUserIdPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiUsersUserIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update profile for the given user ID. This method performs a partial update of the profile object.
         * @summary Update user profile
         * @param {string} userId The unique identifier of the user.
         * @param {ApiUsersUserIdProfilePatchRequest} apiUsersUserIdProfilePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersUserIdProfilePatch(userId: string, apiUsersUserIdProfilePatchRequest: ApiUsersUserIdProfilePatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersUserIdProfilePatch(userId, apiUsersUserIdProfilePatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiUsersUserIdProfilePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get API resource roles assigned to the user with pagination.
         * @summary Get roles for user
         * @param {string} userId The unique identifier of the user.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersUserIdRolesGet(userId: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiApplicationsApplicationIdRolesGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersUserIdRolesGet(userId, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiUsersUserIdRolesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Assign API resource roles to the user. The roles will be added to the existing roles.
         * @summary Assign roles to user
         * @param {string} userId The unique identifier of the user.
         * @param {ApiApplicationsApplicationIdRolesPostRequest} apiApplicationsApplicationIdRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersUserIdRolesPost(userId: string, apiApplicationsApplicationIdRolesPostRequest: ApiApplicationsApplicationIdRolesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersUserIdRolesPost(userId, apiApplicationsApplicationIdRolesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiUsersUserIdRolesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update API resource roles assigned to the user. This will replace the existing roles.
         * @summary Update roles for user
         * @param {string} userId The unique identifier of the user.
         * @param {ApiApplicationsApplicationIdRolesPostRequest} apiApplicationsApplicationIdRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersUserIdRolesPut(userId: string, apiApplicationsApplicationIdRolesPostRequest: ApiApplicationsApplicationIdRolesPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersUserIdRolesPut(userId, apiApplicationsApplicationIdRolesPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiUsersUserIdRolesPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove an API resource role from the user.
         * @summary Remove role from user
         * @param {string} userId The unique identifier of the user.
         * @param {string} roleId The unique identifier of the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersUserIdRolesRoleIdDelete(userId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersUserIdRolesRoleIdDelete(userId, roleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiUsersUserIdRolesRoleIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Get users with filters and pagination.  Logto provides a very flexible way to query users. You can filter users by almost any fields with multiple modes. To learn more about the query syntax, please refer to [Advanced user search](https://docs.logto.io/docs/recipes/manage-users/advanced-user-search/).
         * @summary Get users
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersGet(page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ApiUsersUserIdPatch200Response>> {
            return localVarFp.apiUsersGet(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user with the given data.
         * @summary Create user
         * @param {ApiUsersPostRequest} apiUsersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersPost(apiUsersPostRequest: ApiUsersPostRequest, options?: any): AxiosPromise<ApiUsersUserIdPatch200Response> {
            return localVarFp.apiUsersPost(apiUsersPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get custom data for the given user ID.
         * @summary Get user custom data
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdCustomDataGet(userId: string, options?: any): AxiosPromise<object> {
            return localVarFp.apiUsersUserIdCustomDataGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update custom data for the given user ID. This method performs a partial update of the custom data object.
         * @summary Update user custom data
         * @param {string} userId The unique identifier of the user.
         * @param {ApiUsersUserIdCustomDataPatchRequest} apiUsersUserIdCustomDataPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdCustomDataPatch(userId: string, apiUsersUserIdCustomDataPatchRequest: ApiUsersUserIdCustomDataPatchRequest, options?: any): AxiosPromise<object> {
            return localVarFp.apiUsersUserIdCustomDataPatch(userId, apiUsersUserIdCustomDataPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete user with the given ID. Note all associated data will be deleted cascadingly.
         * @summary Delete user
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdDelete(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiUsersUserIdDelete(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user data for the given ID.
         * @summary Get user
         * @param {string} userId The unique identifier of the user.
         * @param {string} [includeSsoIdentities] If it\&#39;s provided with a truthy value (&#x60;true&#x60;, &#x60;1&#x60;, &#x60;yes&#x60;), each user in the response will include a &#x60;ssoIdentities&#x60; property containing a list of SSO identities associated with the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdGet(userId: string, includeSsoIdentities?: string, options?: any): AxiosPromise<ApiUsersUserIdGet200Response> {
            return localVarFp.apiUsersUserIdGet(userId, includeSsoIdentities, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if the user with the given ID has a password set.
         * @summary Check if user has password
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdHasPasswordGet(userId: string, options?: any): AxiosPromise<ApiUsersUserIdHasPasswordGet200Response> {
            return localVarFp.apiUsersUserIdHasPasswordGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Link authenticated user identity from a social platform to a Logto user.  The usage of this API is usually coupled with `POST /connectors/:connectorId/authorization-uri`. With the help of these pair of APIs, you can implement a user profile page with the link social account feature in your application.  Note: Currently due to technical limitations, this API does not support the following connectors that rely on Logto interaction session: `@logto/connector-apple`, `@logto/connector-saml`, `@logto/connector-oidc` and `@logto/connector-oauth`.
         * @summary Link social identity to user
         * @param {string} userId The unique identifier of the user.
         * @param {ApiUsersUserIdIdentitiesPostRequest} apiUsersUserIdIdentitiesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdIdentitiesPost(userId: string, apiUsersUserIdIdentitiesPostRequest: ApiUsersUserIdIdentitiesPostRequest, options?: any): AxiosPromise<{ [key: string]: ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserIdentitiesValue; }> {
            return localVarFp.apiUsersUserIdIdentitiesPost(userId, apiUsersUserIdIdentitiesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a social identity from the user.
         * @summary Delete social identity from user
         * @param {string} userId The unique identifier of the user.
         * @param {string} target 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdIdentitiesTargetDelete(userId: string, target: string, options?: any): AxiosPromise<ApiUsersUserIdPatch200Response> {
            return localVarFp.apiUsersUserIdIdentitiesTargetDelete(userId, target, options).then((request) => request(axios, basePath));
        },
        /**
         * Directly update a social identity of the user.
         * @summary Update social identity of user
         * @param {string} userId The unique identifier of the user.
         * @param {string} target 
         * @param {ApiUsersUserIdIdentitiesTargetPutRequest} apiUsersUserIdIdentitiesTargetPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdIdentitiesTargetPut(userId: string, target: string, apiUsersUserIdIdentitiesTargetPutRequest: ApiUsersUserIdIdentitiesTargetPutRequest, options?: any): AxiosPromise<{ [key: string]: ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserIdentitiesValue; }> {
            return localVarFp.apiUsersUserIdIdentitiesTargetPut(userId, target, apiUsersUserIdIdentitiesTargetPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user suspension status for the given ID.
         * @summary Update user suspension status
         * @param {string} userId The unique identifier of the user.
         * @param {ApiUsersUserIdIsSuspendedPatchRequest} apiUsersUserIdIsSuspendedPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdIsSuspendedPatch(userId: string, apiUsersUserIdIsSuspendedPatchRequest: ApiUsersUserIdIsSuspendedPatchRequest, options?: any): AxiosPromise<ApiUsersUserIdPatch200Response> {
            return localVarFp.apiUsersUserIdIsSuspendedPatch(userId, apiUsersUserIdIsSuspendedPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a user\'s existing MFA verifications for a given user ID.
         * @summary Get user\'s MFA verifications
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdMfaVerificationsGet(userId: string, options?: any): AxiosPromise<Array<ApiUsersUserIdMfaVerificationsGet200ResponseInner>> {
            return localVarFp.apiUsersUserIdMfaVerificationsGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new MFA verification for a given user ID.
         * @summary Create an MFA verification for a user
         * @param {string} userId The unique identifier of the user.
         * @param {ApiUsersUserIdMfaVerificationsPostRequest} apiUsersUserIdMfaVerificationsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdMfaVerificationsPost(userId: string, apiUsersUserIdMfaVerificationsPostRequest: ApiUsersUserIdMfaVerificationsPostRequest, options?: any): AxiosPromise<ApiUsersUserIdMfaVerificationsPost200Response> {
            return localVarFp.apiUsersUserIdMfaVerificationsPost(userId, apiUsersUserIdMfaVerificationsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an MFA verification for the user with the given verification ID. The verification ID must be associated with the given user ID.
         * @summary Delete an MFA verification for a user
         * @param {string} userId The unique identifier of the user.
         * @param {string} verificationId The unique identifier of the verification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdMfaVerificationsVerificationIdDelete(userId: string, verificationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiUsersUserIdMfaVerificationsVerificationIdDelete(userId, verificationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all organizations that the user is a member of. In each organization object, the user\'s roles in that organization are included in the `organizationRoles` array.
         * @summary Get organizations for a user
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdOrganizationsGet(userId: string, options?: any): AxiosPromise<Array<ApiUsersUserIdOrganizationsGet200ResponseInner>> {
            return localVarFp.apiUsersUserIdOrganizationsGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user password for the given ID.
         * @summary Update user password
         * @param {string} userId The unique identifier of the user.
         * @param {ApiUsersUserIdPasswordPatchRequest} apiUsersUserIdPasswordPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdPasswordPatch(userId: string, apiUsersUserIdPasswordPatchRequest: ApiUsersUserIdPasswordPatchRequest, options?: any): AxiosPromise<ApiUsersUserIdPatch200Response> {
            return localVarFp.apiUsersUserIdPasswordPatch(userId, apiUsersUserIdPasswordPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Test if the given password matches the user\'s password.
         * @summary Verify user password
         * @param {string} userId The unique identifier of the user.
         * @param {ApiUsersUserIdPasswordVerifyPostRequest} apiUsersUserIdPasswordVerifyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdPasswordVerifyPost(userId: string, apiUsersUserIdPasswordVerifyPostRequest: ApiUsersUserIdPasswordVerifyPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiUsersUserIdPasswordVerifyPost(userId, apiUsersUserIdPasswordVerifyPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user data for the given ID. This method performs a partial update.
         * @summary Update user
         * @param {string} userId The unique identifier of the user.
         * @param {ApiUsersUserIdPatchRequest} apiUsersUserIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdPatch(userId: string, apiUsersUserIdPatchRequest: ApiUsersUserIdPatchRequest, options?: any): AxiosPromise<ApiUsersUserIdPatch200Response> {
            return localVarFp.apiUsersUserIdPatch(userId, apiUsersUserIdPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update profile for the given user ID. This method performs a partial update of the profile object.
         * @summary Update user profile
         * @param {string} userId The unique identifier of the user.
         * @param {ApiUsersUserIdProfilePatchRequest} apiUsersUserIdProfilePatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdProfilePatch(userId: string, apiUsersUserIdProfilePatchRequest: ApiUsersUserIdProfilePatchRequest, options?: any): AxiosPromise<ApiConfigsJwtCustomizerTokenTypePathGet200ResponseOneOfContextSampleUserProfile> {
            return localVarFp.apiUsersUserIdProfilePatch(userId, apiUsersUserIdProfilePatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get API resource roles assigned to the user with pagination.
         * @summary Get roles for user
         * @param {string} userId The unique identifier of the user.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdRolesGet(userId: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ApiApplicationsApplicationIdRolesGet200ResponseInner>> {
            return localVarFp.apiUsersUserIdRolesGet(userId, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign API resource roles to the user. The roles will be added to the existing roles.
         * @summary Assign roles to user
         * @param {string} userId The unique identifier of the user.
         * @param {ApiApplicationsApplicationIdRolesPostRequest} apiApplicationsApplicationIdRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdRolesPost(userId: string, apiApplicationsApplicationIdRolesPostRequest: ApiApplicationsApplicationIdRolesPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiUsersUserIdRolesPost(userId, apiApplicationsApplicationIdRolesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update API resource roles assigned to the user. This will replace the existing roles.
         * @summary Update roles for user
         * @param {string} userId The unique identifier of the user.
         * @param {ApiApplicationsApplicationIdRolesPostRequest} apiApplicationsApplicationIdRolesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdRolesPut(userId: string, apiApplicationsApplicationIdRolesPostRequest: ApiApplicationsApplicationIdRolesPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiUsersUserIdRolesPut(userId, apiApplicationsApplicationIdRolesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove an API resource role from the user.
         * @summary Remove role from user
         * @param {string} userId The unique identifier of the user.
         * @param {string} roleId The unique identifier of the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdRolesRoleIdDelete(userId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiUsersUserIdRolesRoleIdDelete(userId, roleId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Get users with filters and pagination.  Logto provides a very flexible way to query users. You can filter users by almost any fields with multiple modes. To learn more about the query syntax, please refer to [Advanced user search](https://docs.logto.io/docs/recipes/manage-users/advanced-user-search/).
     * @summary Get users
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersGet(page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersGet(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user with the given data.
     * @summary Create user
     * @param {ApiUsersPostRequest} apiUsersPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersPost(apiUsersPostRequest: ApiUsersPostRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersPost(apiUsersPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get custom data for the given user ID.
     * @summary Get user custom data
     * @param {string} userId The unique identifier of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersUserIdCustomDataGet(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersUserIdCustomDataGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update custom data for the given user ID. This method performs a partial update of the custom data object.
     * @summary Update user custom data
     * @param {string} userId The unique identifier of the user.
     * @param {ApiUsersUserIdCustomDataPatchRequest} apiUsersUserIdCustomDataPatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersUserIdCustomDataPatch(userId: string, apiUsersUserIdCustomDataPatchRequest: ApiUsersUserIdCustomDataPatchRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersUserIdCustomDataPatch(userId, apiUsersUserIdCustomDataPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete user with the given ID. Note all associated data will be deleted cascadingly.
     * @summary Delete user
     * @param {string} userId The unique identifier of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersUserIdDelete(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersUserIdDelete(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user data for the given ID.
     * @summary Get user
     * @param {string} userId The unique identifier of the user.
     * @param {string} [includeSsoIdentities] If it\&#39;s provided with a truthy value (&#x60;true&#x60;, &#x60;1&#x60;, &#x60;yes&#x60;), each user in the response will include a &#x60;ssoIdentities&#x60; property containing a list of SSO identities associated with the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersUserIdGet(userId: string, includeSsoIdentities?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersUserIdGet(userId, includeSsoIdentities, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if the user with the given ID has a password set.
     * @summary Check if user has password
     * @param {string} userId The unique identifier of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersUserIdHasPasswordGet(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersUserIdHasPasswordGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Link authenticated user identity from a social platform to a Logto user.  The usage of this API is usually coupled with `POST /connectors/:connectorId/authorization-uri`. With the help of these pair of APIs, you can implement a user profile page with the link social account feature in your application.  Note: Currently due to technical limitations, this API does not support the following connectors that rely on Logto interaction session: `@logto/connector-apple`, `@logto/connector-saml`, `@logto/connector-oidc` and `@logto/connector-oauth`.
     * @summary Link social identity to user
     * @param {string} userId The unique identifier of the user.
     * @param {ApiUsersUserIdIdentitiesPostRequest} apiUsersUserIdIdentitiesPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersUserIdIdentitiesPost(userId: string, apiUsersUserIdIdentitiesPostRequest: ApiUsersUserIdIdentitiesPostRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersUserIdIdentitiesPost(userId, apiUsersUserIdIdentitiesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a social identity from the user.
     * @summary Delete social identity from user
     * @param {string} userId The unique identifier of the user.
     * @param {string} target 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersUserIdIdentitiesTargetDelete(userId: string, target: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersUserIdIdentitiesTargetDelete(userId, target, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Directly update a social identity of the user.
     * @summary Update social identity of user
     * @param {string} userId The unique identifier of the user.
     * @param {string} target 
     * @param {ApiUsersUserIdIdentitiesTargetPutRequest} apiUsersUserIdIdentitiesTargetPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersUserIdIdentitiesTargetPut(userId: string, target: string, apiUsersUserIdIdentitiesTargetPutRequest: ApiUsersUserIdIdentitiesTargetPutRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersUserIdIdentitiesTargetPut(userId, target, apiUsersUserIdIdentitiesTargetPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user suspension status for the given ID.
     * @summary Update user suspension status
     * @param {string} userId The unique identifier of the user.
     * @param {ApiUsersUserIdIsSuspendedPatchRequest} apiUsersUserIdIsSuspendedPatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersUserIdIsSuspendedPatch(userId: string, apiUsersUserIdIsSuspendedPatchRequest: ApiUsersUserIdIsSuspendedPatchRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersUserIdIsSuspendedPatch(userId, apiUsersUserIdIsSuspendedPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a user\'s existing MFA verifications for a given user ID.
     * @summary Get user\'s MFA verifications
     * @param {string} userId The unique identifier of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersUserIdMfaVerificationsGet(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersUserIdMfaVerificationsGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new MFA verification for a given user ID.
     * @summary Create an MFA verification for a user
     * @param {string} userId The unique identifier of the user.
     * @param {ApiUsersUserIdMfaVerificationsPostRequest} apiUsersUserIdMfaVerificationsPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersUserIdMfaVerificationsPost(userId: string, apiUsersUserIdMfaVerificationsPostRequest: ApiUsersUserIdMfaVerificationsPostRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersUserIdMfaVerificationsPost(userId, apiUsersUserIdMfaVerificationsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an MFA verification for the user with the given verification ID. The verification ID must be associated with the given user ID.
     * @summary Delete an MFA verification for a user
     * @param {string} userId The unique identifier of the user.
     * @param {string} verificationId The unique identifier of the verification.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersUserIdMfaVerificationsVerificationIdDelete(userId: string, verificationId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersUserIdMfaVerificationsVerificationIdDelete(userId, verificationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all organizations that the user is a member of. In each organization object, the user\'s roles in that organization are included in the `organizationRoles` array.
     * @summary Get organizations for a user
     * @param {string} userId The unique identifier of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersUserIdOrganizationsGet(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersUserIdOrganizationsGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user password for the given ID.
     * @summary Update user password
     * @param {string} userId The unique identifier of the user.
     * @param {ApiUsersUserIdPasswordPatchRequest} apiUsersUserIdPasswordPatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersUserIdPasswordPatch(userId: string, apiUsersUserIdPasswordPatchRequest: ApiUsersUserIdPasswordPatchRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersUserIdPasswordPatch(userId, apiUsersUserIdPasswordPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test if the given password matches the user\'s password.
     * @summary Verify user password
     * @param {string} userId The unique identifier of the user.
     * @param {ApiUsersUserIdPasswordVerifyPostRequest} apiUsersUserIdPasswordVerifyPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersUserIdPasswordVerifyPost(userId: string, apiUsersUserIdPasswordVerifyPostRequest: ApiUsersUserIdPasswordVerifyPostRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersUserIdPasswordVerifyPost(userId, apiUsersUserIdPasswordVerifyPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user data for the given ID. This method performs a partial update.
     * @summary Update user
     * @param {string} userId The unique identifier of the user.
     * @param {ApiUsersUserIdPatchRequest} apiUsersUserIdPatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersUserIdPatch(userId: string, apiUsersUserIdPatchRequest: ApiUsersUserIdPatchRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersUserIdPatch(userId, apiUsersUserIdPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update profile for the given user ID. This method performs a partial update of the profile object.
     * @summary Update user profile
     * @param {string} userId The unique identifier of the user.
     * @param {ApiUsersUserIdProfilePatchRequest} apiUsersUserIdProfilePatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersUserIdProfilePatch(userId: string, apiUsersUserIdProfilePatchRequest: ApiUsersUserIdProfilePatchRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersUserIdProfilePatch(userId, apiUsersUserIdProfilePatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get API resource roles assigned to the user with pagination.
     * @summary Get roles for user
     * @param {string} userId The unique identifier of the user.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersUserIdRolesGet(userId: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersUserIdRolesGet(userId, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assign API resource roles to the user. The roles will be added to the existing roles.
     * @summary Assign roles to user
     * @param {string} userId The unique identifier of the user.
     * @param {ApiApplicationsApplicationIdRolesPostRequest} apiApplicationsApplicationIdRolesPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersUserIdRolesPost(userId: string, apiApplicationsApplicationIdRolesPostRequest: ApiApplicationsApplicationIdRolesPostRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersUserIdRolesPost(userId, apiApplicationsApplicationIdRolesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update API resource roles assigned to the user. This will replace the existing roles.
     * @summary Update roles for user
     * @param {string} userId The unique identifier of the user.
     * @param {ApiApplicationsApplicationIdRolesPostRequest} apiApplicationsApplicationIdRolesPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersUserIdRolesPut(userId: string, apiApplicationsApplicationIdRolesPostRequest: ApiApplicationsApplicationIdRolesPostRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersUserIdRolesPut(userId, apiApplicationsApplicationIdRolesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove an API resource role from the user.
     * @summary Remove role from user
     * @param {string} userId The unique identifier of the user.
     * @param {string} roleId The unique identifier of the role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersUserIdRolesRoleIdDelete(userId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiUsersUserIdRolesRoleIdDelete(userId, roleId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VerificationCodesApi - axios parameter creator
 * @export
 */
export const VerificationCodesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Request a verification code for the provided identifier (email/phone). if you\'re using email as the identifier, you need to setup your email connector first. if you\'re using phone as the identifier, you need to setup your SMS connector first.
         * @summary Request and send a verification code
         * @param {ApiInteractionVerificationVerificationCodePostRequest} apiInteractionVerificationVerificationCodePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiVerificationCodesPost: async (apiInteractionVerificationVerificationCodePostRequest: ApiInteractionVerificationVerificationCodePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiInteractionVerificationVerificationCodePostRequest' is not null or undefined
            assertParamExists('apiVerificationCodesPost', 'apiInteractionVerificationVerificationCodePostRequest', apiInteractionVerificationVerificationCodePostRequest)
            const localVarPath = `/api/verification-codes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiInteractionVerificationVerificationCodePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify a verification code for a specified identifier. if you\'re using email as the identifier, you need to setup your email connector first. if you\'re using phone as the identifier, you need to setup your SMS connector first.
         * @summary Verify a verification code
         * @param {ApiVerificationCodesVerifyPostRequest} apiVerificationCodesVerifyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiVerificationCodesVerifyPost: async (apiVerificationCodesVerifyPostRequest: ApiVerificationCodesVerifyPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiVerificationCodesVerifyPostRequest' is not null or undefined
            assertParamExists('apiVerificationCodesVerifyPost', 'apiVerificationCodesVerifyPostRequest', apiVerificationCodesVerifyPostRequest)
            const localVarPath = `/api/verification-codes/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiVerificationCodesVerifyPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VerificationCodesApi - functional programming interface
 * @export
 */
export const VerificationCodesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VerificationCodesApiAxiosParamCreator(configuration)
    return {
        /**
         * Request a verification code for the provided identifier (email/phone). if you\'re using email as the identifier, you need to setup your email connector first. if you\'re using phone as the identifier, you need to setup your SMS connector first.
         * @summary Request and send a verification code
         * @param {ApiInteractionVerificationVerificationCodePostRequest} apiInteractionVerificationVerificationCodePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiVerificationCodesPost(apiInteractionVerificationVerificationCodePostRequest: ApiInteractionVerificationVerificationCodePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiVerificationCodesPost(apiInteractionVerificationVerificationCodePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VerificationCodesApi.apiVerificationCodesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verify a verification code for a specified identifier. if you\'re using email as the identifier, you need to setup your email connector first. if you\'re using phone as the identifier, you need to setup your SMS connector first.
         * @summary Verify a verification code
         * @param {ApiVerificationCodesVerifyPostRequest} apiVerificationCodesVerifyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiVerificationCodesVerifyPost(apiVerificationCodesVerifyPostRequest: ApiVerificationCodesVerifyPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiVerificationCodesVerifyPost(apiVerificationCodesVerifyPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VerificationCodesApi.apiVerificationCodesVerifyPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VerificationCodesApi - factory interface
 * @export
 */
export const VerificationCodesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VerificationCodesApiFp(configuration)
    return {
        /**
         * Request a verification code for the provided identifier (email/phone). if you\'re using email as the identifier, you need to setup your email connector first. if you\'re using phone as the identifier, you need to setup your SMS connector first.
         * @summary Request and send a verification code
         * @param {ApiInteractionVerificationVerificationCodePostRequest} apiInteractionVerificationVerificationCodePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiVerificationCodesPost(apiInteractionVerificationVerificationCodePostRequest: ApiInteractionVerificationVerificationCodePostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiVerificationCodesPost(apiInteractionVerificationVerificationCodePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify a verification code for a specified identifier. if you\'re using email as the identifier, you need to setup your email connector first. if you\'re using phone as the identifier, you need to setup your SMS connector first.
         * @summary Verify a verification code
         * @param {ApiVerificationCodesVerifyPostRequest} apiVerificationCodesVerifyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiVerificationCodesVerifyPost(apiVerificationCodesVerifyPostRequest: ApiVerificationCodesVerifyPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiVerificationCodesVerifyPost(apiVerificationCodesVerifyPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VerificationCodesApi - object-oriented interface
 * @export
 * @class VerificationCodesApi
 * @extends {BaseAPI}
 */
export class VerificationCodesApi extends BaseAPI {
    /**
     * Request a verification code for the provided identifier (email/phone). if you\'re using email as the identifier, you need to setup your email connector first. if you\'re using phone as the identifier, you need to setup your SMS connector first.
     * @summary Request and send a verification code
     * @param {ApiInteractionVerificationVerificationCodePostRequest} apiInteractionVerificationVerificationCodePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationCodesApi
     */
    public apiVerificationCodesPost(apiInteractionVerificationVerificationCodePostRequest: ApiInteractionVerificationVerificationCodePostRequest, options?: RawAxiosRequestConfig) {
        return VerificationCodesApiFp(this.configuration).apiVerificationCodesPost(apiInteractionVerificationVerificationCodePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify a verification code for a specified identifier. if you\'re using email as the identifier, you need to setup your email connector first. if you\'re using phone as the identifier, you need to setup your SMS connector first.
     * @summary Verify a verification code
     * @param {ApiVerificationCodesVerifyPostRequest} apiVerificationCodesVerifyPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationCodesApi
     */
    public apiVerificationCodesVerifyPost(apiVerificationCodesVerifyPostRequest: ApiVerificationCodesVerifyPostRequest, options?: RawAxiosRequestConfig) {
        return VerificationCodesApiFp(this.configuration).apiVerificationCodesVerifyPost(apiVerificationCodesVerifyPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WellKnownApi - axios parameter creator
 * @export
 */
export const WellKnownApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get localized phrases based on the specified language.
         * @summary Get localized phrases
         * @param {string} [lng] The language tag for localization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWellKnownPhrasesGet: async (lng?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/.well-known/phrases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (lng !== undefined) {
                localVarQueryParameter['lng'] = lng;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the full sign-in experience configuration.
         * @summary Get full sign-in experience
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWellKnownSignInExpGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/.well-known/sign-in-exp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WellKnownApi - functional programming interface
 * @export
 */
export const WellKnownApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WellKnownApiAxiosParamCreator(configuration)
    return {
        /**
         * Get localized phrases based on the specified language.
         * @summary Get localized phrases
         * @param {string} [lng] The language tag for localization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWellKnownPhrasesGet(lng?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: ApiWellKnownPhrasesGet200ResponseValue; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWellKnownPhrasesGet(lng, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WellKnownApi.apiWellKnownPhrasesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the full sign-in experience configuration.
         * @summary Get full sign-in experience
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWellKnownSignInExpGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiWellKnownSignInExpGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWellKnownSignInExpGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WellKnownApi.apiWellKnownSignInExpGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WellKnownApi - factory interface
 * @export
 */
export const WellKnownApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WellKnownApiFp(configuration)
    return {
        /**
         * Get localized phrases based on the specified language.
         * @summary Get localized phrases
         * @param {string} [lng] The language tag for localization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWellKnownPhrasesGet(lng?: string, options?: any): AxiosPromise<{ [key: string]: ApiWellKnownPhrasesGet200ResponseValue; }> {
            return localVarFp.apiWellKnownPhrasesGet(lng, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the full sign-in experience configuration.
         * @summary Get full sign-in experience
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWellKnownSignInExpGet(options?: any): AxiosPromise<ApiWellKnownSignInExpGet200Response> {
            return localVarFp.apiWellKnownSignInExpGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WellKnownApi - object-oriented interface
 * @export
 * @class WellKnownApi
 * @extends {BaseAPI}
 */
export class WellKnownApi extends BaseAPI {
    /**
     * Get localized phrases based on the specified language.
     * @summary Get localized phrases
     * @param {string} [lng] The language tag for localization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WellKnownApi
     */
    public apiWellKnownPhrasesGet(lng?: string, options?: RawAxiosRequestConfig) {
        return WellKnownApiFp(this.configuration).apiWellKnownPhrasesGet(lng, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the full sign-in experience configuration.
     * @summary Get full sign-in experience
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WellKnownApi
     */
    public apiWellKnownSignInExpGet(options?: RawAxiosRequestConfig) {
        return WellKnownApiFp(this.configuration).apiWellKnownSignInExpGet(options).then((request) => request(this.axios, this.basePath));
    }
}



