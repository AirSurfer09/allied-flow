/* tslint:disable */
/* eslint-disable */
/**
 * Logto API references
 * API references for Logto services.  Note: The documentation is for Logto Cloud. If you are using Logto OSS, please refer to the response of `/api/swagger.json` endpoint on your Logto instance.
 *
 * The version of the OpenAPI document: Cloud
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration.js';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common.js';
import type { RequestArgs } from './base.js';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base.js';

/**
 * 
 * @export
 * @interface AddOrganizationApplicationsRequest
 */
export interface AddOrganizationApplicationsRequest {
    /**
     * The application IDs to add.
     * @type {Array<string>}
     * @memberof AddOrganizationApplicationsRequest
     */
    'applicationIds': Array<string>;
}
/**
 * 
 * @export
 * @interface AddOrganizationUsersRequest
 */
export interface AddOrganizationUsersRequest {
    /**
     * An array of user IDs to be added to the organization. Organization existed users assignment will be ignored.
     * @type {Array<string>}
     * @memberof AddOrganizationUsersRequest
     */
    'userIds': Array<string>;
}
/**
 * @type ApiInteractionBindMfaPostRequest
 * @export
 */
export type ApiInteractionBindMfaPostRequest = ApiInteractionBindMfaPostRequestOneOf | ApiInteractionBindMfaPostRequestOneOf1 | ApiInteractionBindMfaPostRequestOneOf2;

/**
 * 
 * @export
 * @interface ApiInteractionBindMfaPostRequestOneOf
 */
export interface ApiInteractionBindMfaPostRequestOneOf {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionBindMfaPostRequestOneOf
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionBindMfaPostRequestOneOf
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface ApiInteractionBindMfaPostRequestOneOf1
 */
export interface ApiInteractionBindMfaPostRequestOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1
     */
    'rawId': string;
    /**
     * 
     * @type {ApiInteractionBindMfaPostRequestOneOf1Response}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1
     */
    'response': ApiInteractionBindMfaPostRequestOneOf1Response;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1
     */
    'authenticatorAttachment'?: ApiInteractionBindMfaPostRequestOneOf1AuthenticatorAttachmentEnum;
    /**
     * 
     * @type {ApiInteractionBindMfaPostRequestOneOf1ClientExtensionResults}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1
     */
    'clientExtensionResults': ApiInteractionBindMfaPostRequestOneOf1ClientExtensionResults;
}

export const ApiInteractionBindMfaPostRequestOneOf1AuthenticatorAttachmentEnum = {
    CrossPlatform: 'cross-platform',
    Platform: 'platform'
} as const;

export type ApiInteractionBindMfaPostRequestOneOf1AuthenticatorAttachmentEnum = typeof ApiInteractionBindMfaPostRequestOneOf1AuthenticatorAttachmentEnum[keyof typeof ApiInteractionBindMfaPostRequestOneOf1AuthenticatorAttachmentEnum];

/**
 * 
 * @export
 * @interface ApiInteractionBindMfaPostRequestOneOf1ClientExtensionResults
 */
export interface ApiInteractionBindMfaPostRequestOneOf1ClientExtensionResults {
    /**
     * 
     * @type {boolean}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1ClientExtensionResults
     */
    'appid'?: boolean;
    /**
     * 
     * @type {ApiInteractionBindMfaPostRequestOneOf1ClientExtensionResultsCrepProps}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1ClientExtensionResults
     */
    'crepProps'?: ApiInteractionBindMfaPostRequestOneOf1ClientExtensionResultsCrepProps;
    /**
     * 
     * @type {boolean}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1ClientExtensionResults
     */
    'hmacCreateSecret'?: boolean;
}
/**
 * 
 * @export
 * @interface ApiInteractionBindMfaPostRequestOneOf1ClientExtensionResultsCrepProps
 */
export interface ApiInteractionBindMfaPostRequestOneOf1ClientExtensionResultsCrepProps {
    /**
     * 
     * @type {boolean}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1ClientExtensionResultsCrepProps
     */
    'rk'?: boolean;
}
/**
 * 
 * @export
 * @interface ApiInteractionBindMfaPostRequestOneOf1Response
 */
export interface ApiInteractionBindMfaPostRequestOneOf1Response {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1Response
     */
    'clientDataJSON': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1Response
     */
    'attestationObject': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1Response
     */
    'authenticatorData'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1Response
     */
    'transports'?: Array<ApiInteractionBindMfaPostRequestOneOf1ResponseTransportsEnum>;
    /**
     * 
     * @type {number}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1Response
     */
    'publicKeyAlgorithm'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionBindMfaPostRequestOneOf1Response
     */
    'publicKey'?: string;
}

export const ApiInteractionBindMfaPostRequestOneOf1ResponseTransportsEnum = {
    Usb: 'usb',
    Nfc: 'nfc',
    Ble: 'ble',
    Internal: 'internal',
    Cable: 'cable',
    Hybrid: 'hybrid',
    SmartCard: 'smart-card'
} as const;

export type ApiInteractionBindMfaPostRequestOneOf1ResponseTransportsEnum = typeof ApiInteractionBindMfaPostRequestOneOf1ResponseTransportsEnum[keyof typeof ApiInteractionBindMfaPostRequestOneOf1ResponseTransportsEnum];

/**
 * 
 * @export
 * @interface ApiInteractionBindMfaPostRequestOneOf2
 */
export interface ApiInteractionBindMfaPostRequestOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionBindMfaPostRequestOneOf2
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ApiInteractionConsentGet200Response
 */
export interface ApiInteractionConsentGet200Response {
    /**
     * 
     * @type {ApiInteractionConsentGet200ResponseApplication}
     * @memberof ApiInteractionConsentGet200Response
     */
    'application': ApiInteractionConsentGet200ResponseApplication;
    /**
     * 
     * @type {ApiInteractionConsentGet200ResponseUser}
     * @memberof ApiInteractionConsentGet200Response
     */
    'user': ApiInteractionConsentGet200ResponseUser;
    /**
     * 
     * @type {Array<ApiInteractionConsentGet200ResponseOrganizationsInner>}
     * @memberof ApiInteractionConsentGet200Response
     */
    'organizations'?: Array<ApiInteractionConsentGet200ResponseOrganizationsInner>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiInteractionConsentGet200Response
     */
    'missingOIDCScope'?: Array<string>;
    /**
     * 
     * @type {Array<ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInner>}
     * @memberof ApiInteractionConsentGet200Response
     */
    'missingResourceScopes'?: Array<ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInner>;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200Response
     */
    'redirectUri': string;
}
/**
 * 
 * @export
 * @interface ApiInteractionConsentGet200ResponseApplication
 */
export interface ApiInteractionConsentGet200ResponseApplication {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseApplication
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseApplication
     */
    'name': string;
    /**
     * 
     * @type {ApiInteractionConsentGet200ResponseApplicationBranding}
     * @memberof ApiInteractionConsentGet200ResponseApplication
     */
    'branding'?: ApiInteractionConsentGet200ResponseApplicationBranding;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseApplication
     */
    'displayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseApplication
     */
    'privacyPolicyUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseApplication
     */
    'termsOfUseUrl'?: string | null;
}
/**
 * 
 * @export
 * @interface ApiInteractionConsentGet200ResponseApplicationBranding
 */
export interface ApiInteractionConsentGet200ResponseApplicationBranding {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseApplicationBranding
     */
    'logoUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseApplicationBranding
     */
    'darkLogoUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseApplicationBranding
     */
    'favicon'?: string;
}
/**
 * 
 * @export
 * @interface ApiInteractionConsentGet200ResponseOrganizationsInner
 */
export interface ApiInteractionConsentGet200ResponseOrganizationsInner {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseOrganizationsInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseOrganizationsInner
     */
    'name': string;
    /**
     * 
     * @type {Array<ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInner>}
     * @memberof ApiInteractionConsentGet200ResponseOrganizationsInner
     */
    'missingResourceScopes'?: Array<ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInner>;
}
/**
 * 
 * @export
 * @interface ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInner
 */
export interface ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInner {
    /**
     * 
     * @type {ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerResource}
     * @memberof ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInner
     */
    'resource': ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerResource;
    /**
     * 
     * @type {Array<ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerScopesInner>}
     * @memberof ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInner
     */
    'scopes': Array<ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerScopesInner>;
}
/**
 * 
 * @export
 * @interface ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerResource
 */
export interface ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerResource {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerResource
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerResource
     */
    'indicator': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerResource
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerScopesInner
 */
export interface ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerScopesInner {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerScopesInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerScopesInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerScopesInner
     */
    'description': string | null;
}
/**
 * 
 * @export
 * @interface ApiInteractionConsentGet200ResponseUser
 */
export interface ApiInteractionConsentGet200ResponseUser {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseUser
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseUser
     */
    'name': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseUser
     */
    'avatar': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseUser
     */
    'username': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseUser
     */
    'primaryEmail': string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionConsentGet200ResponseUser
     */
    'primaryPhone': string | null;
}
/**
 * 
 * @export
 * @interface ApiInteractionConsentPostRequest
 */
export interface ApiInteractionConsentPostRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiInteractionConsentPostRequest
     */
    'organizationIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ApiInteractionEventPutRequest
 */
export interface ApiInteractionEventPutRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionEventPutRequest
     */
    'event': ApiInteractionEventPutRequestEventEnum;
}

export const ApiInteractionEventPutRequestEventEnum = {
    SignIn: 'SignIn',
    Register: 'Register',
    ForgotPassword: 'ForgotPassword'
} as const;

export type ApiInteractionEventPutRequestEventEnum = typeof ApiInteractionEventPutRequestEventEnum[keyof typeof ApiInteractionEventPutRequestEventEnum];

/**
 * @type ApiInteractionMfaPutRequest
 * @export
 */
export type ApiInteractionMfaPutRequest = ApiInteractionBindMfaPostRequestOneOf | ApiInteractionMfaPutRequestOneOf | ApiInteractionMfaPutRequestOneOf1;

/**
 * 
 * @export
 * @interface ApiInteractionMfaPutRequestOneOf
 */
export interface ApiInteractionMfaPutRequestOneOf {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionMfaPutRequestOneOf
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionMfaPutRequestOneOf
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionMfaPutRequestOneOf
     */
    'rawId': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionMfaPutRequestOneOf
     */
    'authenticatorAttachment'?: ApiInteractionMfaPutRequestOneOfAuthenticatorAttachmentEnum;
    /**
     * 
     * @type {ApiInteractionBindMfaPostRequestOneOf1ClientExtensionResults}
     * @memberof ApiInteractionMfaPutRequestOneOf
     */
    'clientExtensionResults': ApiInteractionBindMfaPostRequestOneOf1ClientExtensionResults;
    /**
     * 
     * @type {ApiInteractionMfaPutRequestOneOfResponse}
     * @memberof ApiInteractionMfaPutRequestOneOf
     */
    'response': ApiInteractionMfaPutRequestOneOfResponse;
}

export const ApiInteractionMfaPutRequestOneOfAuthenticatorAttachmentEnum = {
    CrossPlatform: 'cross-platform',
    Platform: 'platform'
} as const;

export type ApiInteractionMfaPutRequestOneOfAuthenticatorAttachmentEnum = typeof ApiInteractionMfaPutRequestOneOfAuthenticatorAttachmentEnum[keyof typeof ApiInteractionMfaPutRequestOneOfAuthenticatorAttachmentEnum];

/**
 * 
 * @export
 * @interface ApiInteractionMfaPutRequestOneOf1
 */
export interface ApiInteractionMfaPutRequestOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionMfaPutRequestOneOf1
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionMfaPutRequestOneOf1
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface ApiInteractionMfaPutRequestOneOfResponse
 */
export interface ApiInteractionMfaPutRequestOneOfResponse {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionMfaPutRequestOneOfResponse
     */
    'clientDataJSON': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionMfaPutRequestOneOfResponse
     */
    'authenticatorData': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionMfaPutRequestOneOfResponse
     */
    'signature': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionMfaPutRequestOneOfResponse
     */
    'userHandle'?: string;
}
/**
 * 
 * @export
 * @interface ApiInteractionMfaSkippedPutRequest
 */
export interface ApiInteractionMfaSkippedPutRequest {
    /**
     * 
     * @type {boolean}
     * @memberof ApiInteractionMfaSkippedPutRequest
     */
    'mfaSkipped': boolean;
}
/**
 * 
 * @export
 * @interface ApiInteractionPutRequest
 */
export interface ApiInteractionPutRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequest
     */
    'event': ApiInteractionPutRequestEventEnum;
    /**
     * 
     * @type {ApiInteractionPutRequestIdentifier}
     * @memberof ApiInteractionPutRequest
     */
    'identifier'?: ApiInteractionPutRequestIdentifier;
    /**
     * 
     * @type {ApiInteractionPutRequestProfile}
     * @memberof ApiInteractionPutRequest
     */
    'profile'?: ApiInteractionPutRequestProfile;
}

export const ApiInteractionPutRequestEventEnum = {
    SignIn: 'SignIn',
    Register: 'Register',
    ForgotPassword: 'ForgotPassword'
} as const;

export type ApiInteractionPutRequestEventEnum = typeof ApiInteractionPutRequestEventEnum[keyof typeof ApiInteractionPutRequestEventEnum];

/**
 * @type ApiInteractionPutRequestIdentifier
 * @export
 */
export type ApiInteractionPutRequestIdentifier = ApiInteractionPutRequestIdentifierOneOf | ApiInteractionPutRequestIdentifierOneOf1 | ApiInteractionPutRequestIdentifierOneOf2 | ApiInteractionPutRequestIdentifierOneOf3 | ApiInteractionPutRequestIdentifierOneOf4 | ApiInteractionPutRequestIdentifierOneOf5 | ApiInteractionPutRequestIdentifierOneOf6 | ApiInteractionPutRequestIdentifierOneOf7;

/**
 * 
 * @export
 * @interface ApiInteractionPutRequestIdentifierOneOf
 */
export interface ApiInteractionPutRequestIdentifierOneOf {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestIdentifierOneOf
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestIdentifierOneOf
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface ApiInteractionPutRequestIdentifierOneOf1
 */
export interface ApiInteractionPutRequestIdentifierOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestIdentifierOneOf1
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestIdentifierOneOf1
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface ApiInteractionPutRequestIdentifierOneOf2
 */
export interface ApiInteractionPutRequestIdentifierOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestIdentifierOneOf2
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestIdentifierOneOf2
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface ApiInteractionPutRequestIdentifierOneOf3
 */
export interface ApiInteractionPutRequestIdentifierOneOf3 {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestIdentifierOneOf3
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestIdentifierOneOf3
     */
    'verificationCode': string;
}
/**
 * 
 * @export
 * @interface ApiInteractionPutRequestIdentifierOneOf4
 */
export interface ApiInteractionPutRequestIdentifierOneOf4 {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestIdentifierOneOf4
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestIdentifierOneOf4
     */
    'verificationCode': string;
}
/**
 * 
 * @export
 * @interface ApiInteractionPutRequestIdentifierOneOf5
 */
export interface ApiInteractionPutRequestIdentifierOneOf5 {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestIdentifierOneOf5
     */
    'connectorId': string;
    /**
     * arbitrary
     * @type {object}
     * @memberof ApiInteractionPutRequestIdentifierOneOf5
     */
    'connectorData': object;
}
/**
 * 
 * @export
 * @interface ApiInteractionPutRequestIdentifierOneOf6
 */
export interface ApiInteractionPutRequestIdentifierOneOf6 {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestIdentifierOneOf6
     */
    'connectorId': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestIdentifierOneOf6
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface ApiInteractionPutRequestIdentifierOneOf7
 */
export interface ApiInteractionPutRequestIdentifierOneOf7 {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestIdentifierOneOf7
     */
    'connectorId': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestIdentifierOneOf7
     */
    'phone': string;
}
/**
 * 
 * @export
 * @interface ApiInteractionPutRequestProfile
 */
export interface ApiInteractionPutRequestProfile {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestProfile
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestProfile
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestProfile
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestProfile
     */
    'connectorId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionPutRequestProfile
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest
 */
export interface ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest
     */
    'state': string;
    /**
     * Validator function
     * @type {object}
     * @memberof ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest
     */
    'redirectUri': object;
}
/**
 * 
 * @export
 * @interface ApiInteractionSubmitPost200Response
 */
export interface ApiInteractionSubmitPost200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionSubmitPost200Response
     */
    'redirectTo': string;
}
/**
 * 
 * @export
 * @interface ApiInteractionVerificationSocialAuthorizationUriPostRequest
 */
export interface ApiInteractionVerificationSocialAuthorizationUriPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationSocialAuthorizationUriPostRequest
     */
    'connectorId': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationSocialAuthorizationUriPostRequest
     */
    'state': string;
    /**
     * Validator function
     * @type {object}
     * @memberof ApiInteractionVerificationSocialAuthorizationUriPostRequest
     */
    'redirectUri': object;
}
/**
 * 
 * @export
 * @interface ApiInteractionVerificationTotpPost200Response
 */
export interface ApiInteractionVerificationTotpPost200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationTotpPost200Response
     */
    'secret': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationTotpPost200Response
     */
    'secretQrCode': string;
}
/**
 * @type ApiInteractionVerificationVerificationCodePostRequest
 * @export
 */
export type ApiInteractionVerificationVerificationCodePostRequest = ApiInteractionVerificationVerificationCodePostRequestOneOf | ApiInteractionVerificationVerificationCodePostRequestOneOf1;

/**
 * 
 * @export
 * @interface ApiInteractionVerificationVerificationCodePostRequestOneOf
 */
export interface ApiInteractionVerificationVerificationCodePostRequestOneOf {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationVerificationCodePostRequestOneOf
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface ApiInteractionVerificationVerificationCodePostRequestOneOf1
 */
export interface ApiInteractionVerificationVerificationCodePostRequestOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationVerificationCodePostRequestOneOf1
     */
    'phone': string;
}
/**
 * 
 * @export
 * @interface ApiInteractionVerificationWebauthnAuthenticationPost200Response
 */
export interface ApiInteractionVerificationWebauthnAuthenticationPost200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnAuthenticationPost200Response
     */
    'challenge': string;
    /**
     * 
     * @type {number}
     * @memberof ApiInteractionVerificationWebauthnAuthenticationPost200Response
     */
    'timeout'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnAuthenticationPost200Response
     */
    'rpId'?: string;
    /**
     * 
     * @type {Array<ApiInteractionVerificationWebauthnRegistrationPost200ResponseExcludeCredentialsInner>}
     * @memberof ApiInteractionVerificationWebauthnAuthenticationPost200Response
     */
    'allowCredentials'?: Array<ApiInteractionVerificationWebauthnRegistrationPost200ResponseExcludeCredentialsInner>;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnAuthenticationPost200Response
     */
    'userVerification'?: ApiInteractionVerificationWebauthnAuthenticationPost200ResponseUserVerificationEnum;
    /**
     * 
     * @type {ApiInteractionVerificationWebauthnRegistrationPost200ResponseExtensions}
     * @memberof ApiInteractionVerificationWebauthnAuthenticationPost200Response
     */
    'extensions'?: ApiInteractionVerificationWebauthnRegistrationPost200ResponseExtensions;
}

export const ApiInteractionVerificationWebauthnAuthenticationPost200ResponseUserVerificationEnum = {
    Required: 'required',
    Preferred: 'preferred',
    Discouraged: 'discouraged'
} as const;

export type ApiInteractionVerificationWebauthnAuthenticationPost200ResponseUserVerificationEnum = typeof ApiInteractionVerificationWebauthnAuthenticationPost200ResponseUserVerificationEnum[keyof typeof ApiInteractionVerificationWebauthnAuthenticationPost200ResponseUserVerificationEnum];

/**
 * 
 * @export
 * @interface ApiInteractionVerificationWebauthnRegistrationPost200Response
 */
export interface ApiInteractionVerificationWebauthnRegistrationPost200Response {
    /**
     * 
     * @type {ApiInteractionVerificationWebauthnRegistrationPost200ResponseRp}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200Response
     */
    'rp': ApiInteractionVerificationWebauthnRegistrationPost200ResponseRp;
    /**
     * 
     * @type {ApiInteractionVerificationWebauthnRegistrationPost200ResponseUser}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200Response
     */
    'user': ApiInteractionVerificationWebauthnRegistrationPost200ResponseUser;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200Response
     */
    'challenge': string;
    /**
     * 
     * @type {Array<ApiInteractionVerificationWebauthnRegistrationPost200ResponsePubKeyCredParamsInner>}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200Response
     */
    'pubKeyCredParams': Array<ApiInteractionVerificationWebauthnRegistrationPost200ResponsePubKeyCredParamsInner>;
    /**
     * 
     * @type {number}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200Response
     */
    'timeout'?: number;
    /**
     * 
     * @type {Array<ApiInteractionVerificationWebauthnRegistrationPost200ResponseExcludeCredentialsInner>}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200Response
     */
    'excludeCredentials'?: Array<ApiInteractionVerificationWebauthnRegistrationPost200ResponseExcludeCredentialsInner>;
    /**
     * 
     * @type {ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelection}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200Response
     */
    'authenticatorSelection'?: ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelection;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200Response
     */
    'attestation'?: ApiInteractionVerificationWebauthnRegistrationPost200ResponseAttestationEnum;
    /**
     * 
     * @type {ApiInteractionVerificationWebauthnRegistrationPost200ResponseExtensions}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200Response
     */
    'extensions'?: ApiInteractionVerificationWebauthnRegistrationPost200ResponseExtensions;
}

export const ApiInteractionVerificationWebauthnRegistrationPost200ResponseAttestationEnum = {
    None: 'none',
    Indirect: 'indirect',
    Direct: 'direct',
    Enterprise: 'enterprise'
} as const;

export type ApiInteractionVerificationWebauthnRegistrationPost200ResponseAttestationEnum = typeof ApiInteractionVerificationWebauthnRegistrationPost200ResponseAttestationEnum[keyof typeof ApiInteractionVerificationWebauthnRegistrationPost200ResponseAttestationEnum];

/**
 * 
 * @export
 * @interface ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelection
 */
export interface ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelection {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelection
     */
    'authenticatorAttachment'?: ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelectionAuthenticatorAttachmentEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelection
     */
    'requireResidentKey'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelection
     */
    'residentKey'?: ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelectionResidentKeyEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelection
     */
    'userVerification'?: ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelectionUserVerificationEnum;
}

export const ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelectionAuthenticatorAttachmentEnum = {
    Platform: 'platform',
    CrossPlatform: 'cross-platform'
} as const;

export type ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelectionAuthenticatorAttachmentEnum = typeof ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelectionAuthenticatorAttachmentEnum[keyof typeof ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelectionAuthenticatorAttachmentEnum];
export const ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelectionResidentKeyEnum = {
    Discouraged: 'discouraged',
    Preferred: 'preferred',
    Required: 'required'
} as const;

export type ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelectionResidentKeyEnum = typeof ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelectionResidentKeyEnum[keyof typeof ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelectionResidentKeyEnum];
export const ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelectionUserVerificationEnum = {
    Required: 'required',
    Preferred: 'preferred',
    Discouraged: 'discouraged'
} as const;

export type ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelectionUserVerificationEnum = typeof ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelectionUserVerificationEnum[keyof typeof ApiInteractionVerificationWebauthnRegistrationPost200ResponseAuthenticatorSelectionUserVerificationEnum];

/**
 * 
 * @export
 * @interface ApiInteractionVerificationWebauthnRegistrationPost200ResponseExcludeCredentialsInner
 */
export interface ApiInteractionVerificationWebauthnRegistrationPost200ResponseExcludeCredentialsInner {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponseExcludeCredentialsInner
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponseExcludeCredentialsInner
     */
    'id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponseExcludeCredentialsInner
     */
    'transports'?: Array<ApiInteractionVerificationWebauthnRegistrationPost200ResponseExcludeCredentialsInnerTransportsEnum>;
}

export const ApiInteractionVerificationWebauthnRegistrationPost200ResponseExcludeCredentialsInnerTransportsEnum = {
    Usb: 'usb',
    Nfc: 'nfc',
    Ble: 'ble',
    Internal: 'internal',
    Cable: 'cable',
    Hybrid: 'hybrid',
    SmartCard: 'smart-card'
} as const;

export type ApiInteractionVerificationWebauthnRegistrationPost200ResponseExcludeCredentialsInnerTransportsEnum = typeof ApiInteractionVerificationWebauthnRegistrationPost200ResponseExcludeCredentialsInnerTransportsEnum[keyof typeof ApiInteractionVerificationWebauthnRegistrationPost200ResponseExcludeCredentialsInnerTransportsEnum];

/**
 * 
 * @export
 * @interface ApiInteractionVerificationWebauthnRegistrationPost200ResponseExtensions
 */
export interface ApiInteractionVerificationWebauthnRegistrationPost200ResponseExtensions {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponseExtensions
     */
    'appid'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponseExtensions
     */
    'credProps'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponseExtensions
     */
    'hmacCreateSecret'?: boolean;
}
/**
 * 
 * @export
 * @interface ApiInteractionVerificationWebauthnRegistrationPost200ResponsePubKeyCredParamsInner
 */
export interface ApiInteractionVerificationWebauthnRegistrationPost200ResponsePubKeyCredParamsInner {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponsePubKeyCredParamsInner
     */
    'type': string;
    /**
     * 
     * @type {number}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponsePubKeyCredParamsInner
     */
    'alg': number;
}
/**
 * 
 * @export
 * @interface ApiInteractionVerificationWebauthnRegistrationPost200ResponseRp
 */
export interface ApiInteractionVerificationWebauthnRegistrationPost200ResponseRp {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponseRp
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponseRp
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface ApiInteractionVerificationWebauthnRegistrationPost200ResponseUser
 */
export interface ApiInteractionVerificationWebauthnRegistrationPost200ResponseUser {
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponseUser
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponseUser
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ApiInteractionVerificationWebauthnRegistrationPost200ResponseUser
     */
    'displayName': string;
}
/**
 * 
 * @export
 * @interface AssertSingleSignOnSamlRequest
 */
export interface AssertSingleSignOnSamlRequest {
    /**
     * SAML standard parameter that will be transmitted between the identity provider and the service provider. It will be used as the session ID (jti) of the user\'s Logto authentication session. This API will use this session ID to retrieve the SSO connector authentication session from the database.
     * @type {string}
     * @memberof AssertSingleSignOnSamlRequest
     */
    'RelayState': string;
    /**
     * The SAML assertion response from the identity provider (IdP).
     * @type {string}
     * @memberof AssertSingleSignOnSamlRequest
     */
    'SAMLResponse': string;
}
/**
 * 
 * @export
 * @interface AssignApplicationRolesRequest
 */
export interface AssignApplicationRolesRequest {
    /**
     * An array of API resource role IDs to assign.
     * @type {Array<string>}
     * @memberof AssignApplicationRolesRequest
     */
    'roleIds': Array<string>;
}
/**
 * 
 * @export
 * @interface AssignOrganizationRolesToApplicationRequest
 */
export interface AssignOrganizationRolesToApplicationRequest {
    /**
     * The role ID to add.
     * @type {Array<string>}
     * @memberof AssignOrganizationRolesToApplicationRequest
     */
    'organizationRoleIds': Array<string>;
}
/**
 * 
 * @export
 * @interface AssignOrganizationRolesToApplicationsRequest
 */
export interface AssignOrganizationRolesToApplicationsRequest {
    /**
     * An array of application IDs to assign roles to.
     * @type {Array<string>}
     * @memberof AssignOrganizationRolesToApplicationsRequest
     */
    'applicationIds': Array<string>;
    /**
     * An array of organization role IDs to assign to the applications.
     * @type {Array<string>}
     * @memberof AssignOrganizationRolesToApplicationsRequest
     */
    'organizationRoleIds': Array<string>;
}
/**
 * 
 * @export
 * @interface AssignOrganizationRolesToUserRequest
 */
export interface AssignOrganizationRolesToUserRequest {
    /**
     * An array of organization role IDs to assign to the user. User existed roles assignment will be ignored.
     * @type {Array<string>}
     * @memberof AssignOrganizationRolesToUserRequest
     */
    'organizationRoleIds': Array<string>;
}
/**
 * 
 * @export
 * @interface AssignOrganizationRolesToUsersRequest
 */
export interface AssignOrganizationRolesToUsersRequest {
    /**
     * An array of user IDs to assign roles.
     * @type {Array<string>}
     * @memberof AssignOrganizationRolesToUsersRequest
     */
    'userIds': Array<string>;
    /**
     * An array of organization role IDs to assign. User existed roles assignment will be ignored.
     * @type {Array<string>}
     * @memberof AssignOrganizationRolesToUsersRequest
     */
    'organizationRoleIds': Array<string>;
}
/**
 * 
 * @export
 * @interface CreateApplicationProtectedAppMetadataCustomDomainRequest
 */
export interface CreateApplicationProtectedAppMetadataCustomDomainRequest {
    /**
     * The domain to be added to the application.
     * @type {string}
     * @memberof CreateApplicationProtectedAppMetadataCustomDomainRequest
     */
    'domain': string;
}
/**
 * 
 * @export
 * @interface CreateApplicationRequest
 */
export interface CreateApplicationRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationRequest
     */
    'type': CreateApplicationRequestTypeEnum;
    /**
     * 
     * @type {ListApplications200ResponseInnerOidcClientMetadata}
     * @memberof CreateApplicationRequest
     */
    'oidcClientMetadata'?: ListApplications200ResponseInnerOidcClientMetadata;
    /**
     * 
     * @type {ListApplications200ResponseInnerCustomClientMetadata}
     * @memberof CreateApplicationRequest
     */
    'customClientMetadata'?: ListApplications200ResponseInnerCustomClientMetadata;
    /**
     * 
     * @type {boolean}
     * @memberof CreateApplicationRequest
     */
    'isThirdParty'?: boolean;
    /**
     * 
     * @type {CreateApplicationRequestProtectedAppMetadata}
     * @memberof CreateApplicationRequest
     */
    'protectedAppMetadata'?: CreateApplicationRequestProtectedAppMetadata;
}

export const CreateApplicationRequestTypeEnum = {
    Native: 'Native',
    Spa: 'SPA',
    Traditional: 'Traditional',
    MachineToMachine: 'MachineToMachine',
    Protected: 'Protected'
} as const;

export type CreateApplicationRequestTypeEnum = typeof CreateApplicationRequestTypeEnum[keyof typeof CreateApplicationRequestTypeEnum];

/**
 * The data for protected app, this feature is not available for open source version.
 * @export
 * @interface CreateApplicationRequestProtectedAppMetadata
 */
export interface CreateApplicationRequestProtectedAppMetadata {
    /**
     * The subdomain prefix, e.g., my-site.
     * @type {string}
     * @memberof CreateApplicationRequestProtectedAppMetadata
     */
    'subDomain': string;
    /**
     * The origin of target website, e.g., https://example.com.
     * @type {string}
     * @memberof CreateApplicationRequestProtectedAppMetadata
     */
    'origin': string;
}
/**
 * 
 * @export
 * @interface CreateApplicationUserConsentOrganizationRequest
 */
export interface CreateApplicationUserConsentOrganizationRequest {
    /**
     * A list of organization ids to be granted.
     * @type {Array<string>}
     * @memberof CreateApplicationUserConsentOrganizationRequest
     */
    'organizationIds': Array<string>;
}
/**
 * 
 * @export
 * @interface CreateApplicationUserConsentScopeRequest
 */
export interface CreateApplicationUserConsentScopeRequest {
    /**
     * A list of organization scope id to assign to the application. Throws error if any given organization scope is not found.
     * @type {Array<string>}
     * @memberof CreateApplicationUserConsentScopeRequest
     */
    'organizationScopes'?: Array<string>;
    /**
     * A list of resource scope id to assign to the application. Throws error if any given resource scope is not found.
     * @type {Array<string>}
     * @memberof CreateApplicationUserConsentScopeRequest
     */
    'resourceScopes'?: Array<string>;
    /**
     * A list of organization resource scope id to assign to the application. Throws error if any given resource scope is not found.
     * @type {Array<string>}
     * @memberof CreateApplicationUserConsentScopeRequest
     */
    'organizationResourceScopes'?: Array<string>;
    /**
     * A list of user scope enum value to assign to the application.
     * @type {Array<string>}
     * @memberof CreateApplicationUserConsentScopeRequest
     */
    'userScopes'?: Array<CreateApplicationUserConsentScopeRequestUserScopesEnum>;
}

export const CreateApplicationUserConsentScopeRequestUserScopesEnum = {
    Profile: 'profile',
    Email: 'email',
    Phone: 'phone',
    Address: 'address',
    CustomData: 'custom_data',
    Identities: 'identities',
    Roles: 'roles',
    Urnlogtoscopeorganizations: 'urn:logto:scope:organizations',
    UrnlogtoscopeorganizationRoles: 'urn:logto:scope:organization_roles'
} as const;

export type CreateApplicationUserConsentScopeRequestUserScopesEnum = typeof CreateApplicationUserConsentScopeRequestUserScopesEnum[keyof typeof CreateApplicationUserConsentScopeRequestUserScopesEnum];

/**
 * 
 * @export
 * @interface CreateConnectorAuthorizationUri200Response
 */
export interface CreateConnectorAuthorizationUri200Response {
    /**
     * 
     * @type {string}
     * @memberof CreateConnectorAuthorizationUri200Response
     */
    'redirectTo': string;
    /**
     * The URI to navigate for authentication and authorization in the connected social identity provider.
     * @type {any}
     * @memberof CreateConnectorAuthorizationUri200Response
     */
    'redirectUri'?: any;
}
/**
 * 
 * @export
 * @interface CreateConnectorAuthorizationUriRequest
 */
export interface CreateConnectorAuthorizationUriRequest {
    /**
     * A random string generated on the client side to prevent CSRF (Cross-Site Request Forgery) attacks.
     * @type {string}
     * @memberof CreateConnectorAuthorizationUriRequest
     */
    'state': string;
    /**
     * The URI to navigate back to after the user is authenticated by the connected social identity provider and has granted access to the connector.
     * @type {string}
     * @memberof CreateConnectorAuthorizationUriRequest
     */
    'redirectUri': string;
}
/**
 * 
 * @export
 * @interface CreateConnectorRequest
 */
export interface CreateConnectorRequest {
    /**
     * The connector config object that will be passed to the connector. The config object should be compatible with the connector factory.
     * @type {object}
     * @memberof CreateConnectorRequest
     */
    'config'?: object;
    /**
     * The connector factory ID for creating the connector.
     * @type {string}
     * @memberof CreateConnectorRequest
     */
    'connectorId': string;
    /**
     * 
     * @type {CreateConnectorRequestMetadata}
     * @memberof CreateConnectorRequest
     */
    'metadata'?: CreateConnectorRequestMetadata;
    /**
     * Whether to sync user profile from the identity provider to Logto at each sign-in. If `false`, the user profile will only be synced when the user is created.
     * @type {boolean}
     * @memberof CreateConnectorRequest
     */
    'syncProfile'?: boolean;
    /**
     * The unique ID for the connector. If not provided, a random ID will be generated.
     * @type {string}
     * @memberof CreateConnectorRequest
     */
    'id'?: string;
}
/**
 * Custom connector metadata, will be used to overwrite the default connector factory metadata.
 * @export
 * @interface CreateConnectorRequestMetadata
 */
export interface CreateConnectorRequestMetadata {
    /**
     * 
     * @type {string}
     * @memberof CreateConnectorRequestMetadata
     */
    'target'?: string;
    /**
     * Validator function
     * @type {object}
     * @memberof CreateConnectorRequestMetadata
     */
    'name'?: object;
    /**
     * 
     * @type {string}
     * @memberof CreateConnectorRequestMetadata
     */
    'logo'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateConnectorRequestMetadata
     */
    'logoDark'?: string | null;
}
/**
 * 
 * @export
 * @interface CreateConnectorTestRequest
 */
export interface CreateConnectorTestRequest {
    /**
     * Phone number to send test message to. If this is set, email will be ignored.
     * @type {string}
     * @memberof CreateConnectorTestRequest
     */
    'phone'?: string;
    /**
     * Email address to send test message to. If phone is set, this will be ignored.
     * @type {string}
     * @memberof CreateConnectorTestRequest
     */
    'email'?: string;
    /**
     * Connector configuration object for testing.
     * @type {object}
     * @memberof CreateConnectorTestRequest
     */
    'config': object;
}
/**
 * 
 * @export
 * @interface CreateDomainRequest
 */
export interface CreateDomainRequest {
    /**
     * The domain name, e.g. `example.com`.
     * @type {string}
     * @memberof CreateDomainRequest
     */
    'domain': string;
}
/**
 * 
 * @export
 * @interface CreateHookRequest
 */
export interface CreateHookRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateHookRequest
     */
    'tenantId'?: string;
    /**
     * The name of the hook.
     * @type {string}
     * @memberof CreateHookRequest
     */
    'name'?: string;
    /**
     * Use `events` instead.
     * @type {string}
     * @memberof CreateHookRequest
     * @deprecated
     */
    'event'?: CreateHookRequestEventEnum;
    /**
     * An array of hook events.
     * @type {Array<string>}
     * @memberof CreateHookRequest
     */
    'events'?: Array<CreateHookRequestEventsEnum>;
    /**
     * 
     * @type {CreateHookRequestConfig}
     * @memberof CreateHookRequest
     */
    'config': CreateHookRequestConfig;
    /**
     * 
     * @type {boolean}
     * @memberof CreateHookRequest
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CreateHookRequest
     */
    'createdAt'?: number;
}

export const CreateHookRequestEventEnum = {
    PostRegister: 'PostRegister',
    PostSignIn: 'PostSignIn',
    PostResetPassword: 'PostResetPassword',
    UserCreated: 'User.Created',
    UserDeleted: 'User.Deleted',
    UserDataUpdated: 'User.Data.Updated',
    UserSuspensionStatusUpdated: 'User.SuspensionStatus.Updated',
    RoleCreated: 'Role.Created',
    RoleDeleted: 'Role.Deleted',
    RoleDataUpdated: 'Role.Data.Updated',
    RoleScopesUpdated: 'Role.Scopes.Updated',
    ScopeCreated: 'Scope.Created',
    ScopeDeleted: 'Scope.Deleted',
    ScopeDataUpdated: 'Scope.Data.Updated',
    OrganizationCreated: 'Organization.Created',
    OrganizationDeleted: 'Organization.Deleted',
    OrganizationDataUpdated: 'Organization.Data.Updated',
    OrganizationMembershipUpdated: 'Organization.Membership.Updated',
    OrganizationRoleCreated: 'OrganizationRole.Created',
    OrganizationRoleDeleted: 'OrganizationRole.Deleted',
    OrganizationRoleDataUpdated: 'OrganizationRole.Data.Updated',
    OrganizationRoleScopesUpdated: 'OrganizationRole.Scopes.Updated',
    OrganizationScopeCreated: 'OrganizationScope.Created',
    OrganizationScopeDeleted: 'OrganizationScope.Deleted',
    OrganizationScopeDataUpdated: 'OrganizationScope.Data.Updated'
} as const;

export type CreateHookRequestEventEnum = typeof CreateHookRequestEventEnum[keyof typeof CreateHookRequestEventEnum];
export const CreateHookRequestEventsEnum = {
    PostRegister: 'PostRegister',
    PostSignIn: 'PostSignIn',
    PostResetPassword: 'PostResetPassword',
    UserCreated: 'User.Created',
    UserDeleted: 'User.Deleted',
    UserDataUpdated: 'User.Data.Updated',
    UserSuspensionStatusUpdated: 'User.SuspensionStatus.Updated',
    RoleCreated: 'Role.Created',
    RoleDeleted: 'Role.Deleted',
    RoleDataUpdated: 'Role.Data.Updated',
    RoleScopesUpdated: 'Role.Scopes.Updated',
    ScopeCreated: 'Scope.Created',
    ScopeDeleted: 'Scope.Deleted',
    ScopeDataUpdated: 'Scope.Data.Updated',
    OrganizationCreated: 'Organization.Created',
    OrganizationDeleted: 'Organization.Deleted',
    OrganizationDataUpdated: 'Organization.Data.Updated',
    OrganizationMembershipUpdated: 'Organization.Membership.Updated',
    OrganizationRoleCreated: 'OrganizationRole.Created',
    OrganizationRoleDeleted: 'OrganizationRole.Deleted',
    OrganizationRoleDataUpdated: 'OrganizationRole.Data.Updated',
    OrganizationRoleScopesUpdated: 'OrganizationRole.Scopes.Updated',
    OrganizationScopeCreated: 'OrganizationScope.Created',
    OrganizationScopeDeleted: 'OrganizationScope.Deleted',
    OrganizationScopeDataUpdated: 'OrganizationScope.Data.Updated'
} as const;

export type CreateHookRequestEventsEnum = typeof CreateHookRequestEventsEnum[keyof typeof CreateHookRequestEventsEnum];

/**
 * 
 * @export
 * @interface CreateHookRequestConfig
 */
export interface CreateHookRequestConfig {
    /**
     * 
     * @type {string}
     * @memberof CreateHookRequestConfig
     */
    'url': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateHookRequestConfig
     */
    'headers'?: { [key: string]: string; };
    /**
     * Now the retry times is fixed to 3. Keep for backward compatibility.
     * @type {number}
     * @memberof CreateHookRequestConfig
     * @deprecated
     */
    'retries'?: number;
}
/**
 * 
 * @export
 * @interface CreateHookTestRequest
 */
export interface CreateHookTestRequest {
    /**
     * An array of hook events for testing.
     * @type {Array<string>}
     * @memberof CreateHookTestRequest
     */
    'events': Array<CreateHookTestRequestEventsEnum>;
    /**
     * 
     * @type {CreateHookTestRequestConfig}
     * @memberof CreateHookTestRequest
     */
    'config': CreateHookTestRequestConfig;
    /**
     * Use `events` instead.
     * @type {any}
     * @memberof CreateHookTestRequest
     * @deprecated
     */
    'event'?: any;
}

export const CreateHookTestRequestEventsEnum = {
    PostRegister: 'PostRegister',
    PostSignIn: 'PostSignIn',
    PostResetPassword: 'PostResetPassword',
    UserCreated: 'User.Created',
    UserDeleted: 'User.Deleted',
    UserDataUpdated: 'User.Data.Updated',
    UserSuspensionStatusUpdated: 'User.SuspensionStatus.Updated',
    RoleCreated: 'Role.Created',
    RoleDeleted: 'Role.Deleted',
    RoleDataUpdated: 'Role.Data.Updated',
    RoleScopesUpdated: 'Role.Scopes.Updated',
    ScopeCreated: 'Scope.Created',
    ScopeDeleted: 'Scope.Deleted',
    ScopeDataUpdated: 'Scope.Data.Updated',
    OrganizationCreated: 'Organization.Created',
    OrganizationDeleted: 'Organization.Deleted',
    OrganizationDataUpdated: 'Organization.Data.Updated',
    OrganizationMembershipUpdated: 'Organization.Membership.Updated',
    OrganizationRoleCreated: 'OrganizationRole.Created',
    OrganizationRoleDeleted: 'OrganizationRole.Deleted',
    OrganizationRoleDataUpdated: 'OrganizationRole.Data.Updated',
    OrganizationRoleScopesUpdated: 'OrganizationRole.Scopes.Updated',
    OrganizationScopeCreated: 'OrganizationScope.Created',
    OrganizationScopeDeleted: 'OrganizationScope.Deleted',
    OrganizationScopeDataUpdated: 'OrganizationScope.Data.Updated'
} as const;

export type CreateHookTestRequestEventsEnum = typeof CreateHookTestRequestEventsEnum[keyof typeof CreateHookTestRequestEventsEnum];

/**
 * The hook configuration for testing.
 * @export
 * @interface CreateHookTestRequestConfig
 */
export interface CreateHookTestRequestConfig {
    /**
     * 
     * @type {string}
     * @memberof CreateHookTestRequestConfig
     */
    'url': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateHookTestRequestConfig
     */
    'headers'?: { [key: string]: string; };
    /**
     * Now the retry times is fixed to 3. Keep for backward compatibility.
     * @type {number}
     * @memberof CreateHookTestRequestConfig
     * @deprecated
     */
    'retries'?: number;
}
/**
 * 
 * @export
 * @interface CreateOrganizationInvitationRequest
 */
export interface CreateOrganizationInvitationRequest {
    /**
     * The ID of the user who is inviting the user to join the organization.
     * @type {string}
     * @memberof CreateOrganizationInvitationRequest
     */
    'inviterId'?: string | null;
    /**
     * The email address of the user to invite to join the organization.
     * @type {string}
     * @memberof CreateOrganizationInvitationRequest
     */
    'invitee': string;
    /**
     * The ID of the organization to invite the user to join.
     * @type {string}
     * @memberof CreateOrganizationInvitationRequest
     */
    'organizationId': string;
    /**
     * The epoch time in milliseconds when the invitation expires.
     * @type {number}
     * @memberof CreateOrganizationInvitationRequest
     */
    'expiresAt': number;
    /**
     * The IDs of the organization roles to assign to the user when they accept the invitation.
     * @type {Array<string>}
     * @memberof CreateOrganizationInvitationRequest
     */
    'organizationRoleIds'?: Array<string>;
    /**
     * 
     * @type {CreateOrganizationInvitationRequestMessagePayload}
     * @memberof CreateOrganizationInvitationRequest
     */
    'messagePayload': CreateOrganizationInvitationRequestMessagePayload;
}
/**
 * @type CreateOrganizationInvitationRequestMessagePayload
 * The message payload for the \"OrganizationInvitation\" template to use when sending the invitation via email. If it is `false`, the invitation will not be sent via email.
 * @export
 */
export type CreateOrganizationInvitationRequestMessagePayload = CreateOrganizationInvitationRequestMessagePayloadOneOf | boolean;

/**
 * 
 * @export
 * @interface CreateOrganizationInvitationRequestMessagePayloadOneOf
 */
export interface CreateOrganizationInvitationRequestMessagePayloadOneOf {
    /**
     * 
     * @type {string}
     * @memberof CreateOrganizationInvitationRequestMessagePayloadOneOf
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrganizationInvitationRequestMessagePayloadOneOf
     */
    'link'?: string;
}
/**
 * 
 * @export
 * @interface CreateOrganizationJitEmailDomainRequest
 */
export interface CreateOrganizationJitEmailDomainRequest {
    /**
     * The email domain to add.
     * @type {string}
     * @memberof CreateOrganizationJitEmailDomainRequest
     */
    'emailDomain': string;
}
/**
 * 
 * @export
 * @interface CreateOrganizationJitRoleRequest
 */
export interface CreateOrganizationJitRoleRequest {
    /**
     * The organization role IDs to add.
     * @type {Array<string>}
     * @memberof CreateOrganizationJitRoleRequest
     */
    'organizationRoleIds': Array<string>;
}
/**
 * 
 * @export
 * @interface CreateOrganizationJitSsoConnectorRequest
 */
export interface CreateOrganizationJitSsoConnectorRequest {
    /**
     * The SSO connector IDs to add.
     * @type {Array<string>}
     * @memberof CreateOrganizationJitSsoConnectorRequest
     */
    'ssoConnectorIds': Array<string>;
}
/**
 * 
 * @export
 * @interface CreateOrganizationRequest
 */
export interface CreateOrganizationRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateOrganizationRequest
     */
    'tenantId'?: string;
    /**
     * The name of the organization.
     * @type {string}
     * @memberof CreateOrganizationRequest
     */
    'name': string;
    /**
     * The description of the organization.
     * @type {string}
     * @memberof CreateOrganizationRequest
     */
    'description'?: string | null;
    /**
     * arbitrary
     * @type {object}
     * @memberof CreateOrganizationRequest
     */
    'customData'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof CreateOrganizationRequest
     */
    'isMfaRequired'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CreateOrganizationRequest
     */
    'createdAt'?: number;
}
/**
 * 
 * @export
 * @interface CreateOrganizationRoleRequest
 */
export interface CreateOrganizationRoleRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateOrganizationRoleRequest
     */
    'tenantId'?: string;
    /**
     * The name of the organization role. It must be unique within the organization template.
     * @type {string}
     * @memberof CreateOrganizationRoleRequest
     */
    'name': string;
    /**
     * The description of the organization role.
     * @type {string}
     * @memberof CreateOrganizationRoleRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateOrganizationRoleRequest
     */
    'type'?: CreateOrganizationRoleRequestTypeEnum;
    /**
     * An array of organization scope IDs to be assigned to the organization role.
     * @type {Array<string>}
     * @memberof CreateOrganizationRoleRequest
     */
    'organizationScopeIds': Array<string>;
    /**
     * An array of resource scope IDs to be assigned to the organization role.
     * @type {Array<string>}
     * @memberof CreateOrganizationRoleRequest
     */
    'resourceScopeIds': Array<string>;
}

export const CreateOrganizationRoleRequestTypeEnum = {
    User: 'User',
    MachineToMachine: 'MachineToMachine'
} as const;

export type CreateOrganizationRoleRequestTypeEnum = typeof CreateOrganizationRoleRequestTypeEnum[keyof typeof CreateOrganizationRoleRequestTypeEnum];

/**
 * 
 * @export
 * @interface CreateOrganizationRoleResourceScopeRequest
 */
export interface CreateOrganizationRoleResourceScopeRequest {
    /**
     * An array of resource scope IDs to be assigned. Existed scope IDs assignments will be ignored.
     * @type {Array<string>}
     * @memberof CreateOrganizationRoleResourceScopeRequest
     */
    'scopeIds': Array<string>;
}
/**
 * 
 * @export
 * @interface CreateOrganizationRoleScopeRequest
 */
export interface CreateOrganizationRoleScopeRequest {
    /**
     * An array of organization scope IDs to be assigned. Existed scope IDs assignments will be ignored.
     * @type {Array<string>}
     * @memberof CreateOrganizationRoleScopeRequest
     */
    'organizationScopeIds': Array<string>;
}
/**
 * 
 * @export
 * @interface CreateOrganizationScopeRequest
 */
export interface CreateOrganizationScopeRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateOrganizationScopeRequest
     */
    'tenantId'?: string;
    /**
     * The name of the organization scope. It must be unique within the organization template.
     * @type {string}
     * @memberof CreateOrganizationScopeRequest
     */
    'name': string;
    /**
     * The description of the organization scope.
     * @type {string}
     * @memberof CreateOrganizationScopeRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface CreateResourceRequest
 */
export interface CreateResourceRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateResourceRequest
     */
    'tenantId'?: string;
    /**
     * The name of the resource.
     * @type {string}
     * @memberof CreateResourceRequest
     */
    'name': string;
    /**
     * The unique resource indicator. Should be a valid URI.
     * @type {string}
     * @memberof CreateResourceRequest
     */
    'indicator': string;
    /**
     * The access token TTL in seconds. It affects the `exp` claim of the access token granted for this resource.
     * @type {number}
     * @memberof CreateResourceRequest
     */
    'accessTokenTtl'?: number;
}
/**
 * 
 * @export
 * @interface CreateResourceScopeRequest
 */
export interface CreateResourceScopeRequest {
    /**
     * The name of the scope. It should be unique for the resource.
     * @type {string}
     * @memberof CreateResourceScopeRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateResourceScopeRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface CreateRoleApplicationRequest
 */
export interface CreateRoleApplicationRequest {
    /**
     * An array of application IDs to be assigned.
     * @type {Array<string>}
     * @memberof CreateRoleApplicationRequest
     */
    'applicationIds': Array<string>;
}
/**
 * 
 * @export
 * @interface CreateRoleRequest
 */
export interface CreateRoleRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateRoleRequest
     */
    'tenantId'?: string;
    /**
     * The name of the role. It should be unique within the tenant.
     * @type {string}
     * @memberof CreateRoleRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoleRequest
     */
    'description': string;
    /**
     * The type of the role. It cannot be changed after creation.
     * @type {string}
     * @memberof CreateRoleRequest
     */
    'type'?: CreateRoleRequestTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRoleRequest
     */
    'isDefault'?: boolean;
    /**
     * The initial API resource scopes assigned to the role.
     * @type {Array<string>}
     * @memberof CreateRoleRequest
     */
    'scopeIds'?: Array<string>;
}

export const CreateRoleRequestTypeEnum = {
    User: 'User',
    MachineToMachine: 'MachineToMachine'
} as const;

export type CreateRoleRequestTypeEnum = typeof CreateRoleRequestTypeEnum[keyof typeof CreateRoleRequestTypeEnum];

/**
 * 
 * @export
 * @interface CreateRoleScopeRequest
 */
export interface CreateRoleScopeRequest {
    /**
     * An array of API resource scope IDs to be linked.
     * @type {Array<string>}
     * @memberof CreateRoleScopeRequest
     */
    'scopeIds': Array<string>;
}
/**
 * 
 * @export
 * @interface CreateRoleUserRequest
 */
export interface CreateRoleUserRequest {
    /**
     * An array of user IDs to be assigned.
     * @type {Array<string>}
     * @memberof CreateRoleUserRequest
     */
    'userIds': Array<string>;
}
/**
 * 
 * @export
 * @interface CreateSsoConnectorRequest
 */
export interface CreateSsoConnectorRequest {
    /**
     * arbitrary
     * @type {object}
     * @memberof CreateSsoConnectorRequest
     */
    'config'?: object;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateSsoConnectorRequest
     */
    'domains'?: Array<string>;
    /**
     * 
     * @type {ListOrganizationJitSsoConnectors200ResponseInnerBranding}
     * @memberof CreateSsoConnectorRequest
     */
    'branding'?: ListOrganizationJitSsoConnectors200ResponseInnerBranding;
    /**
     * 
     * @type {boolean}
     * @memberof CreateSsoConnectorRequest
     */
    'syncProfile'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateSsoConnectorRequest
     */
    'providerName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateSsoConnectorRequest
     */
    'connectorName': string;
}
/**
 * 
 * @export
 * @interface CreateUserAsset200Response
 */
export interface CreateUserAsset200Response {
    /**
     * 
     * @type {string}
     * @memberof CreateUserAsset200Response
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface CreateUserIdentityRequest
 */
export interface CreateUserIdentityRequest {
    /**
     * The Logto connector ID.
     * @type {string}
     * @memberof CreateUserIdentityRequest
     */
    'connectorId': string;
    /**
     * A json object constructed from the url query params returned by the social platform. Typically it contains `code`, `state` and `redirectUri` fields.
     * @type {{ [key: string]: any; }}
     * @memberof CreateUserIdentityRequest
     */
    'connectorData': { [key: string]: any; };
}
/**
 * @type CreateUserMfaVerification200Response
 * @export
 */
export type CreateUserMfaVerification200Response = CreateUserMfaVerification200ResponseOneOf | CreateUserMfaVerification200ResponseOneOf1;

/**
 * 
 * @export
 * @interface CreateUserMfaVerification200ResponseOneOf
 */
export interface CreateUserMfaVerification200ResponseOneOf {
    /**
     * 
     * @type {string}
     * @memberof CreateUserMfaVerification200ResponseOneOf
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserMfaVerification200ResponseOneOf
     */
    'secret': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserMfaVerification200ResponseOneOf
     */
    'secretQrCode': string;
}
/**
 * 
 * @export
 * @interface CreateUserMfaVerification200ResponseOneOf1
 */
export interface CreateUserMfaVerification200ResponseOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof CreateUserMfaVerification200ResponseOneOf1
     */
    'type': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateUserMfaVerification200ResponseOneOf1
     */
    'codes': Array<string>;
}
/**
 * 
 * @export
 * @interface CreateUserMfaVerificationRequest
 */
export interface CreateUserMfaVerificationRequest {
    /**
     * 
     * @type {CreateUserMfaVerificationRequestType}
     * @memberof CreateUserMfaVerificationRequest
     */
    'type': CreateUserMfaVerificationRequestType;
}
/**
 * @type CreateUserMfaVerificationRequestType
 * The type of MFA verification to create.
 * @export
 */
export type CreateUserMfaVerificationRequestType = string;

/**
 * User data to create a new user. All properties are optional.
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     * Primary phone number for the user. It should be unique across all users.
     * @type {string}
     * @memberof CreateUserRequest
     */
    'primaryPhone'?: string;
    /**
     * Primary email address for the user. It should be unique across all users.
     * @type {string}
     * @memberof CreateUserRequest
     */
    'primaryEmail'?: string;
    /**
     * Username for the user. It should be unique across all users.
     * @type {string}
     * @memberof CreateUserRequest
     */
    'username'?: string;
    /**
     * Plain text password for the user.
     * @type {string}
     * @memberof CreateUserRequest
     */
    'password'?: string;
    /**
     * In case you already have the password digests and not the passwords, you can use them for the newly created user via this property. The value should be generated with one of the supported algorithms. The algorithm can be specified using the `passwordAlgorithm` property.
     * @type {string}
     * @memberof CreateUserRequest
     */
    'passwordDigest'?: string;
    /**
     * The hash algorithm used for the password. It should be one of the supported algorithms: argon2, md5, sha1, sha256. Should the encryption algorithm differ from argon2, it will automatically be upgraded to argon2 upon the user\'s next sign-in.
     * @type {string}
     * @memberof CreateUserRequest
     */
    'passwordAlgorithm'?: CreateUserRequestPasswordAlgorithmEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'name'?: string;
    /**
     * 
     * @type {UpdateUserRequestAvatar}
     * @memberof CreateUserRequest
     */
    'avatar'?: UpdateUserRequestAvatar | null;
    /**
     * arbitrary
     * @type {object}
     * @memberof CreateUserRequest
     */
    'customData'?: object;
    /**
     * 
     * @type {GetJwtCustomizer200ResponseOneOfContextSampleUserProfile}
     * @memberof CreateUserRequest
     */
    'profile'?: GetJwtCustomizer200ResponseOneOfContextSampleUserProfile;
}

export const CreateUserRequestPasswordAlgorithmEnum = {
    Argon2i: 'Argon2i',
    Sha1: 'SHA1',
    Sha256: 'SHA256',
    Md5: 'MD5',
    Bcrypt: 'Bcrypt'
} as const;

export type CreateUserRequestPasswordAlgorithmEnum = typeof CreateUserRequestPasswordAlgorithmEnum[keyof typeof CreateUserRequestPasswordAlgorithmEnum];

/**
 * 
 * @export
 * @interface GetActiveUserCounts200Response
 */
export interface GetActiveUserCounts200Response {
    /**
     * 
     * @type {Array<GetActiveUserCounts200ResponseDauCurveInner>}
     * @memberof GetActiveUserCounts200Response
     */
    'dauCurve': Array<GetActiveUserCounts200ResponseDauCurveInner>;
    /**
     * 
     * @type {GetNewUserCounts200ResponseToday}
     * @memberof GetActiveUserCounts200Response
     */
    'dau': GetNewUserCounts200ResponseToday;
    /**
     * 
     * @type {GetNewUserCounts200ResponseToday}
     * @memberof GetActiveUserCounts200Response
     */
    'wau': GetNewUserCounts200ResponseToday;
    /**
     * 
     * @type {GetNewUserCounts200ResponseToday}
     * @memberof GetActiveUserCounts200Response
     */
    'mau': GetNewUserCounts200ResponseToday;
}
/**
 * 
 * @export
 * @interface GetActiveUserCounts200ResponseDauCurveInner
 */
export interface GetActiveUserCounts200ResponseDauCurveInner {
    /**
     * 
     * @type {string}
     * @memberof GetActiveUserCounts200ResponseDauCurveInner
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof GetActiveUserCounts200ResponseDauCurveInner
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface GetAdminConsoleConfig200Response
 */
export interface GetAdminConsoleConfig200Response {
    /**
     * 
     * @type {boolean}
     * @memberof GetAdminConsoleConfig200Response
     */
    'signInExperienceCustomized': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetAdminConsoleConfig200Response
     */
    'organizationCreated': boolean;
    /**
     * 
     * @type {GetAdminConsoleConfig200ResponseDevelopmentTenantMigrationNotification}
     * @memberof GetAdminConsoleConfig200Response
     */
    'developmentTenantMigrationNotification'?: GetAdminConsoleConfig200ResponseDevelopmentTenantMigrationNotification;
    /**
     * 
     * @type {GetAdminConsoleConfig200ResponseCheckedChargeNotification}
     * @memberof GetAdminConsoleConfig200Response
     */
    'checkedChargeNotification'?: GetAdminConsoleConfig200ResponseCheckedChargeNotification;
}
/**
 * 
 * @export
 * @interface GetAdminConsoleConfig200ResponseCheckedChargeNotification
 */
export interface GetAdminConsoleConfig200ResponseCheckedChargeNotification {
    /**
     * 
     * @type {boolean}
     * @memberof GetAdminConsoleConfig200ResponseCheckedChargeNotification
     */
    'token'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetAdminConsoleConfig200ResponseCheckedChargeNotification
     */
    'apiResource'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetAdminConsoleConfig200ResponseCheckedChargeNotification
     */
    'machineToMachineApp'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetAdminConsoleConfig200ResponseCheckedChargeNotification
     */
    'tenantMember'?: boolean;
}
/**
 * 
 * @export
 * @interface GetAdminConsoleConfig200ResponseDevelopmentTenantMigrationNotification
 */
export interface GetAdminConsoleConfig200ResponseDevelopmentTenantMigrationNotification {
    /**
     * 
     * @type {boolean}
     * @memberof GetAdminConsoleConfig200ResponseDevelopmentTenantMigrationNotification
     */
    'isPaidTenant': boolean;
    /**
     * 
     * @type {string}
     * @memberof GetAdminConsoleConfig200ResponseDevelopmentTenantMigrationNotification
     */
    'tag': string;
    /**
     * 
     * @type {number}
     * @memberof GetAdminConsoleConfig200ResponseDevelopmentTenantMigrationNotification
     */
    'readAt'?: number;
}
/**
 * 
 * @export
 * @interface GetApplication200Response
 */
export interface GetApplication200Response {
    /**
     * 
     * @type {string}
     * @memberof GetApplication200Response
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof GetApplication200Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetApplication200Response
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetApplication200Response
     */
    'secret': string;
    /**
     * 
     * @type {string}
     * @memberof GetApplication200Response
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetApplication200Response
     */
    'type': GetApplication200ResponseTypeEnum;
    /**
     * 
     * @type {ListApplications200ResponseInnerOidcClientMetadata}
     * @memberof GetApplication200Response
     */
    'oidcClientMetadata': ListApplications200ResponseInnerOidcClientMetadata;
    /**
     * 
     * @type {ListApplications200ResponseInnerCustomClientMetadata}
     * @memberof GetApplication200Response
     */
    'customClientMetadata': ListApplications200ResponseInnerCustomClientMetadata;
    /**
     * 
     * @type {ListApplications200ResponseInnerProtectedAppMetadata}
     * @memberof GetApplication200Response
     */
    'protectedAppMetadata': ListApplications200ResponseInnerProtectedAppMetadata | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetApplication200Response
     */
    'isThirdParty': boolean;
    /**
     * 
     * @type {number}
     * @memberof GetApplication200Response
     */
    'createdAt': number;
    /**
     * 
     * @type {boolean}
     * @memberof GetApplication200Response
     */
    'isAdmin': boolean;
}

export const GetApplication200ResponseTypeEnum = {
    Native: 'Native',
    Spa: 'SPA',
    Traditional: 'Traditional',
    MachineToMachine: 'MachineToMachine',
    Protected: 'Protected'
} as const;

export type GetApplication200ResponseTypeEnum = typeof GetApplication200ResponseTypeEnum[keyof typeof GetApplication200ResponseTypeEnum];

/**
 * 
 * @export
 * @interface GetApplicationSignInExperience200Response
 */
export interface GetApplicationSignInExperience200Response {
    /**
     * 
     * @type {string}
     * @memberof GetApplicationSignInExperience200Response
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof GetApplicationSignInExperience200Response
     */
    'applicationId': string;
    /**
     * 
     * @type {ApiInteractionConsentGet200ResponseApplicationBranding}
     * @memberof GetApplicationSignInExperience200Response
     */
    'branding': ApiInteractionConsentGet200ResponseApplicationBranding;
    /**
     * 
     * @type {string}
     * @memberof GetApplicationSignInExperience200Response
     */
    'termsOfUseUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetApplicationSignInExperience200Response
     */
    'privacyPolicyUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetApplicationSignInExperience200Response
     */
    'displayName': string | null;
}
/**
 * 
 * @export
 * @interface GetHasuraAuth200Response
 */
export interface GetHasuraAuth200Response {
    /**
     * 
     * @type {string}
     * @memberof GetHasuraAuth200Response
     */
    'X-Hasura-User-Id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetHasuraAuth200Response
     */
    'X-Hasura-Role'?: string;
}
/**
 * @type GetJwtCustomizer200Response
 * @export
 */
export type GetJwtCustomizer200Response = GetJwtCustomizer200ResponseOneOf | GetJwtCustomizer200ResponseOneOf1;

/**
 * 
 * @export
 * @interface GetJwtCustomizer200ResponseOneOf
 */
export interface GetJwtCustomizer200ResponseOneOf {
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOf
     */
    'script': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GetJwtCustomizer200ResponseOneOf
     */
    'environmentVariables'?: { [key: string]: string; };
    /**
     * 
     * @type {GetJwtCustomizer200ResponseOneOfContextSample}
     * @memberof GetJwtCustomizer200ResponseOneOf
     */
    'contextSample'?: GetJwtCustomizer200ResponseOneOfContextSample;
    /**
     * 
     * @type {GetJwtCustomizer200ResponseOneOfTokenSample}
     * @memberof GetJwtCustomizer200ResponseOneOf
     */
    'tokenSample'?: GetJwtCustomizer200ResponseOneOfTokenSample;
}
/**
 * 
 * @export
 * @interface GetJwtCustomizer200ResponseOneOf1
 */
export interface GetJwtCustomizer200ResponseOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOf1
     */
    'script': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GetJwtCustomizer200ResponseOneOf1
     */
    'environmentVariables'?: { [key: string]: string; };
    /**
     * arbitrary
     * @type {object}
     * @memberof GetJwtCustomizer200ResponseOneOf1
     */
    'contextSample'?: object;
    /**
     * 
     * @type {GetJwtCustomizer200ResponseOneOf1TokenSample}
     * @memberof GetJwtCustomizer200ResponseOneOf1
     */
    'tokenSample'?: GetJwtCustomizer200ResponseOneOf1TokenSample;
}
/**
 * 
 * @export
 * @interface GetJwtCustomizer200ResponseOneOf1TokenSample
 */
export interface GetJwtCustomizer200ResponseOneOf1TokenSample {
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOf1TokenSample
     */
    'jti'?: string;
    /**
     * 
     * @type {GetJwtCustomizer200ResponseOneOfTokenSampleAud}
     * @memberof GetJwtCustomizer200ResponseOneOf1TokenSample
     */
    'aud'?: GetJwtCustomizer200ResponseOneOfTokenSampleAud;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOf1TokenSample
     */
    'scope'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOf1TokenSample
     */
    'clientId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOf1TokenSample
     */
    'kind'?: string;
}
/**
 * 
 * @export
 * @interface GetJwtCustomizer200ResponseOneOfContextSample
 */
export interface GetJwtCustomizer200ResponseOneOfContextSample {
    /**
     * 
     * @type {GetJwtCustomizer200ResponseOneOfContextSampleUser}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSample
     */
    'user': GetJwtCustomizer200ResponseOneOfContextSampleUser;
}
/**
 * 
 * @export
 * @interface GetJwtCustomizer200ResponseOneOfContextSampleUser
 */
export interface GetJwtCustomizer200ResponseOneOfContextSampleUser {
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUser
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUser
     */
    'username'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUser
     */
    'primaryEmail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUser
     */
    'primaryPhone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUser
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUser
     */
    'avatar'?: string | null;
    /**
     * arbitrary
     * @type {object}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUser
     */
    'customData'?: object;
    /**
     * 
     * @type {{ [key: string]: GetJwtCustomizer200ResponseOneOfContextSampleUserIdentitiesValue; }}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUser
     */
    'identities'?: { [key: string]: GetJwtCustomizer200ResponseOneOfContextSampleUserIdentitiesValue; };
    /**
     * 
     * @type {number}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUser
     */
    'lastSignInAt'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUser
     */
    'createdAt'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUser
     */
    'updatedAt'?: number;
    /**
     * 
     * @type {GetJwtCustomizer200ResponseOneOfContextSampleUserProfile}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUser
     */
    'profile'?: GetJwtCustomizer200ResponseOneOfContextSampleUserProfile;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUser
     */
    'applicationId'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUser
     */
    'isSuspended'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUser
     */
    'hasPassword'?: boolean;
    /**
     * 
     * @type {Array<GetJwtCustomizer200ResponseOneOfContextSampleUserSsoIdentitiesInner>}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUser
     */
    'ssoIdentities'?: Array<GetJwtCustomizer200ResponseOneOfContextSampleUserSsoIdentitiesInner>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUser
     */
    'mfaVerificationFactors'?: Array<GetJwtCustomizer200ResponseOneOfContextSampleUserMfaVerificationFactorsEnum>;
    /**
     * 
     * @type {Array<GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInner>}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUser
     */
    'roles'?: Array<GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInner>;
    /**
     * 
     * @type {Array<ListApplicationUserConsentScopes200ResponseOrganizationScopesInner>}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUser
     */
    'organizations'?: Array<ListApplicationUserConsentScopes200ResponseOrganizationScopesInner>;
    /**
     * 
     * @type {Array<GetJwtCustomizer200ResponseOneOfContextSampleUserOrganizationRolesInner>}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUser
     */
    'organizationRoles'?: Array<GetJwtCustomizer200ResponseOneOfContextSampleUserOrganizationRolesInner>;
}

export const GetJwtCustomizer200ResponseOneOfContextSampleUserMfaVerificationFactorsEnum = {
    Totp: 'Totp',
    WebAuthn: 'WebAuthn',
    BackupCode: 'BackupCode'
} as const;

export type GetJwtCustomizer200ResponseOneOfContextSampleUserMfaVerificationFactorsEnum = typeof GetJwtCustomizer200ResponseOneOfContextSampleUserMfaVerificationFactorsEnum[keyof typeof GetJwtCustomizer200ResponseOneOfContextSampleUserMfaVerificationFactorsEnum];

/**
 * 
 * @export
 * @interface GetJwtCustomizer200ResponseOneOfContextSampleUserIdentitiesValue
 */
export interface GetJwtCustomizer200ResponseOneOfContextSampleUserIdentitiesValue {
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserIdentitiesValue
     */
    'userId': string;
    /**
     * arbitrary
     * @type {object}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserIdentitiesValue
     */
    'details'?: object;
}
/**
 * 
 * @export
 * @interface GetJwtCustomizer200ResponseOneOfContextSampleUserOrganizationRolesInner
 */
export interface GetJwtCustomizer200ResponseOneOfContextSampleUserOrganizationRolesInner {
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserOrganizationRolesInner
     */
    'organizationId': string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserOrganizationRolesInner
     */
    'roleId': string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserOrganizationRolesInner
     */
    'roleName': string;
}
/**
 * 
 * @export
 * @interface GetJwtCustomizer200ResponseOneOfContextSampleUserProfile
 */
export interface GetJwtCustomizer200ResponseOneOfContextSampleUserProfile {
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserProfile
     */
    'familyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserProfile
     */
    'givenName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserProfile
     */
    'middleName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserProfile
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserProfile
     */
    'preferredUsername'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserProfile
     */
    'profile'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserProfile
     */
    'website'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserProfile
     */
    'gender'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserProfile
     */
    'birthdate'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserProfile
     */
    'zoneinfo'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserProfile
     */
    'locale'?: string;
    /**
     * 
     * @type {GetJwtCustomizer200ResponseOneOfContextSampleUserProfileAddress}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserProfile
     */
    'address'?: GetJwtCustomizer200ResponseOneOfContextSampleUserProfileAddress;
}
/**
 * 
 * @export
 * @interface GetJwtCustomizer200ResponseOneOfContextSampleUserProfileAddress
 */
export interface GetJwtCustomizer200ResponseOneOfContextSampleUserProfileAddress {
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserProfileAddress
     */
    'formatted'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserProfileAddress
     */
    'streetAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserProfileAddress
     */
    'locality'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserProfileAddress
     */
    'region'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserProfileAddress
     */
    'postalCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserProfileAddress
     */
    'country'?: string;
}
/**
 * 
 * @export
 * @interface GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInner
 */
export interface GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInner {
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInner
     */
    'description': string;
    /**
     * 
     * @type {Array<GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInnerScopesInner>}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInner
     */
    'scopes': Array<GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInnerScopesInner>;
}
/**
 * 
 * @export
 * @interface GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInnerScopesInner
 */
export interface GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInnerScopesInner {
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInnerScopesInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInnerScopesInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInnerScopesInner
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInnerScopesInner
     */
    'resourceId': string;
    /**
     * 
     * @type {GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInnerScopesInner
     */
    'resource': GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource;
}
/**
 * 
 * @export
 * @interface GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource
 */
export interface GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource {
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource
     */
    'indicator': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource
     */
    'isDefault': boolean;
    /**
     * 
     * @type {number}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource
     */
    'accessTokenTtl': number;
}
/**
 * 
 * @export
 * @interface GetJwtCustomizer200ResponseOneOfContextSampleUserSsoIdentitiesInner
 */
export interface GetJwtCustomizer200ResponseOneOfContextSampleUserSsoIdentitiesInner {
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserSsoIdentitiesInner
     */
    'issuer': string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserSsoIdentitiesInner
     */
    'identityId': string;
    /**
     * arbitrary
     * @type {object}
     * @memberof GetJwtCustomizer200ResponseOneOfContextSampleUserSsoIdentitiesInner
     */
    'detail': object;
}
/**
 * 
 * @export
 * @interface GetJwtCustomizer200ResponseOneOfTokenSample
 */
export interface GetJwtCustomizer200ResponseOneOfTokenSample {
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfTokenSample
     */
    'jti'?: string;
    /**
     * 
     * @type {GetJwtCustomizer200ResponseOneOfTokenSampleAud}
     * @memberof GetJwtCustomizer200ResponseOneOfTokenSample
     */
    'aud'?: GetJwtCustomizer200ResponseOneOfTokenSampleAud;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfTokenSample
     */
    'scope'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfTokenSample
     */
    'clientId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfTokenSample
     */
    'accountId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetJwtCustomizer200ResponseOneOfTokenSample
     */
    'expiresWithSession'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfTokenSample
     */
    'grantId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfTokenSample
     */
    'gty'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfTokenSample
     */
    'sessionUid'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfTokenSample
     */
    'sid'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetJwtCustomizer200ResponseOneOfTokenSample
     */
    'kind'?: string;
}
/**
 * @type GetJwtCustomizer200ResponseOneOfTokenSampleAud
 * @export
 */
export type GetJwtCustomizer200ResponseOneOfTokenSampleAud = Array<string> | string;

/**
 * 
 * @export
 * @interface GetNewUserCounts200Response
 */
export interface GetNewUserCounts200Response {
    /**
     * 
     * @type {GetNewUserCounts200ResponseToday}
     * @memberof GetNewUserCounts200Response
     */
    'today': GetNewUserCounts200ResponseToday;
    /**
     * 
     * @type {GetNewUserCounts200ResponseToday}
     * @memberof GetNewUserCounts200Response
     */
    'last7Days': GetNewUserCounts200ResponseToday;
}
/**
 * 
 * @export
 * @interface GetNewUserCounts200ResponseToday
 */
export interface GetNewUserCounts200ResponseToday {
    /**
     * 
     * @type {number}
     * @memberof GetNewUserCounts200ResponseToday
     */
    'count': number;
    /**
     * 
     * @type {number}
     * @memberof GetNewUserCounts200ResponseToday
     */
    'delta': number;
}
/**
 * 
 * @export
 * @interface GetOidcKeys200ResponseInner
 */
export interface GetOidcKeys200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof GetOidcKeys200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof GetOidcKeys200ResponseInner
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof GetOidcKeys200ResponseInner
     */
    'signingKeyAlgorithm'?: GetOidcKeys200ResponseInnerSigningKeyAlgorithmEnum;
}

export const GetOidcKeys200ResponseInnerSigningKeyAlgorithmEnum = {
    Rsa: 'RSA',
    Ec: 'EC'
} as const;

export type GetOidcKeys200ResponseInnerSigningKeyAlgorithmEnum = typeof GetOidcKeys200ResponseInnerSigningKeyAlgorithmEnum[keyof typeof GetOidcKeys200ResponseInnerSigningKeyAlgorithmEnum];

/**
 * 
 * @export
 * @interface GetOrganizationInvitation200Response
 */
export interface GetOrganizationInvitation200Response {
    /**
     * 
     * @type {string}
     * @memberof GetOrganizationInvitation200Response
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof GetOrganizationInvitation200Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetOrganizationInvitation200Response
     */
    'inviterId': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetOrganizationInvitation200Response
     */
    'invitee': string;
    /**
     * 
     * @type {string}
     * @memberof GetOrganizationInvitation200Response
     */
    'acceptedUserId': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetOrganizationInvitation200Response
     */
    'organizationId': string;
    /**
     * 
     * @type {string}
     * @memberof GetOrganizationInvitation200Response
     */
    'status': GetOrganizationInvitation200ResponseStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof GetOrganizationInvitation200Response
     */
    'createdAt': number;
    /**
     * 
     * @type {number}
     * @memberof GetOrganizationInvitation200Response
     */
    'updatedAt': number;
    /**
     * 
     * @type {number}
     * @memberof GetOrganizationInvitation200Response
     */
    'expiresAt': number;
    /**
     * 
     * @type {Array<ListApplicationOrganizations200ResponseInnerOrganizationRolesInner>}
     * @memberof GetOrganizationInvitation200Response
     */
    'organizationRoles': Array<ListApplicationOrganizations200ResponseInnerOrganizationRolesInner>;
}

export const GetOrganizationInvitation200ResponseStatusEnum = {
    Pending: 'Pending',
    Accepted: 'Accepted',
    Expired: 'Expired',
    Revoked: 'Revoked'
} as const;

export type GetOrganizationInvitation200ResponseStatusEnum = typeof GetOrganizationInvitation200ResponseStatusEnum[keyof typeof GetOrganizationInvitation200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface GetOrganizationRole200Response
 */
export interface GetOrganizationRole200Response {
    /**
     * 
     * @type {string}
     * @memberof GetOrganizationRole200Response
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof GetOrganizationRole200Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetOrganizationRole200Response
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetOrganizationRole200Response
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetOrganizationRole200Response
     */
    'type': GetOrganizationRole200ResponseTypeEnum;
}

export const GetOrganizationRole200ResponseTypeEnum = {
    User: 'User',
    MachineToMachine: 'MachineToMachine'
} as const;

export type GetOrganizationRole200ResponseTypeEnum = typeof GetOrganizationRole200ResponseTypeEnum[keyof typeof GetOrganizationRole200ResponseTypeEnum];

/**
 * 
 * @export
 * @interface GetSignInExp200Response
 */
export interface GetSignInExp200Response {
    /**
     * 
     * @type {string}
     * @memberof GetSignInExp200Response
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof GetSignInExp200Response
     */
    'id': string;
    /**
     * 
     * @type {GetSignInExp200ResponseColor}
     * @memberof GetSignInExp200Response
     */
    'color': GetSignInExp200ResponseColor;
    /**
     * 
     * @type {ApiInteractionConsentGet200ResponseApplicationBranding}
     * @memberof GetSignInExp200Response
     */
    'branding': ApiInteractionConsentGet200ResponseApplicationBranding;
    /**
     * 
     * @type {GetSignInExp200ResponseLanguageInfo}
     * @memberof GetSignInExp200Response
     */
    'languageInfo': GetSignInExp200ResponseLanguageInfo;
    /**
     * 
     * @type {string}
     * @memberof GetSignInExp200Response
     */
    'termsOfUseUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetSignInExp200Response
     */
    'privacyPolicyUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetSignInExp200Response
     */
    'agreeToTermsPolicy': GetSignInExp200ResponseAgreeToTermsPolicyEnum;
    /**
     * 
     * @type {GetSignInExp200ResponseSignIn}
     * @memberof GetSignInExp200Response
     */
    'signIn': GetSignInExp200ResponseSignIn;
    /**
     * 
     * @type {GetSignInExp200ResponseSignUp}
     * @memberof GetSignInExp200Response
     */
    'signUp': GetSignInExp200ResponseSignUp;
    /**
     * 
     * @type {GetSignInExp200ResponseSocialSignIn}
     * @memberof GetSignInExp200Response
     */
    'socialSignIn': GetSignInExp200ResponseSocialSignIn;
    /**
     * Enabled social sign-in connectors, will displayed on the sign-in page.
     * @type {Array<string>}
     * @memberof GetSignInExp200Response
     */
    'socialSignInConnectorTargets': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GetSignInExp200Response
     */
    'signInMode': GetSignInExp200ResponseSignInModeEnum;
    /**
     * 
     * @type {string}
     * @memberof GetSignInExp200Response
     */
    'customCss': string | null;
    /**
     * Custom content to display on experience flow pages. the page pathname will be the config key, the content will be the config value.
     * @type {{ [key: string]: string; }}
     * @memberof GetSignInExp200Response
     */
    'customContent': { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof GetSignInExp200Response
     */
    'customUiAssetId': string | null;
    /**
     * 
     * @type {GetSignInExp200ResponsePasswordPolicy}
     * @memberof GetSignInExp200Response
     */
    'passwordPolicy': GetSignInExp200ResponsePasswordPolicy;
    /**
     * 
     * @type {GetSignInExp200ResponseMfa}
     * @memberof GetSignInExp200Response
     */
    'mfa': GetSignInExp200ResponseMfa;
    /**
     * 
     * @type {boolean}
     * @memberof GetSignInExp200Response
     */
    'singleSignOnEnabled': boolean;
}

export const GetSignInExp200ResponseAgreeToTermsPolicyEnum = {
    Automatic: 'Automatic',
    ManualRegistrationOnly: 'ManualRegistrationOnly',
    Manual: 'Manual'
} as const;

export type GetSignInExp200ResponseAgreeToTermsPolicyEnum = typeof GetSignInExp200ResponseAgreeToTermsPolicyEnum[keyof typeof GetSignInExp200ResponseAgreeToTermsPolicyEnum];
export const GetSignInExp200ResponseSignInModeEnum = {
    SignIn: 'SignIn',
    Register: 'Register',
    SignInAndRegister: 'SignInAndRegister'
} as const;

export type GetSignInExp200ResponseSignInModeEnum = typeof GetSignInExp200ResponseSignInModeEnum[keyof typeof GetSignInExp200ResponseSignInModeEnum];

/**
 * The primary branding color for the sign-in page (both light/dark mode).
 * @export
 * @interface GetSignInExp200ResponseColor
 */
export interface GetSignInExp200ResponseColor {
    /**
     * 
     * @type {string}
     * @memberof GetSignInExp200ResponseColor
     */
    'primaryColor': string;
    /**
     * 
     * @type {boolean}
     * @memberof GetSignInExp200ResponseColor
     */
    'isDarkModeEnabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof GetSignInExp200ResponseColor
     */
    'darkPrimaryColor': string;
}
/**
 * The language detection policy for the sign-in page.
 * @export
 * @interface GetSignInExp200ResponseLanguageInfo
 */
export interface GetSignInExp200ResponseLanguageInfo {
    /**
     * 
     * @type {boolean}
     * @memberof GetSignInExp200ResponseLanguageInfo
     */
    'autoDetect': boolean;
    /**
     * 
     * @type {string}
     * @memberof GetSignInExp200ResponseLanguageInfo
     */
    'fallbackLanguage': GetSignInExp200ResponseLanguageInfoFallbackLanguageEnum;
}

export const GetSignInExp200ResponseLanguageInfoFallbackLanguageEnum = {
    AfZa: 'af-ZA',
    AmEt: 'am-ET',
    ArAr: 'ar-AR',
    AsIn: 'as-IN',
    AzAz: 'az-AZ',
    BeBy: 'be-BY',
    BgBg: 'bg-BG',
    BnIn: 'bn-IN',
    BrFr: 'br-FR',
    BsBa: 'bs-BA',
    CaEs: 'ca-ES',
    CbIq: 'cb-IQ',
    CoFr: 'co-FR',
    CsCz: 'cs-CZ',
    CxPh: 'cx-PH',
    CyGb: 'cy-GB',
    DaDk: 'da-DK',
    De: 'de',
    DeDe: 'de-DE',
    ElGr: 'el-GR',
    En: 'en',
    EnGb: 'en-GB',
    EnUs: 'en-US',
    EoEo: 'eo-EO',
    Es: 'es',
    EsEs: 'es-ES',
    Es419: 'es-419',
    EtEe: 'et-EE',
    EuEs: 'eu-ES',
    FaIr: 'fa-IR',
    FfNg: 'ff-NG',
    FiFi: 'fi-FI',
    FoFo: 'fo-FO',
    Fr: 'fr',
    FrCa: 'fr-CA',
    FrFr: 'fr-FR',
    FyNl: 'fy-NL',
    GaIe: 'ga-IE',
    GlEs: 'gl-ES',
    GnPy: 'gn-PY',
    GuIn: 'gu-IN',
    HaNg: 'ha-NG',
    HeIl: 'he-IL',
    HiIn: 'hi-IN',
    HrHr: 'hr-HR',
    HtHt: 'ht-HT',
    HuHu: 'hu-HU',
    HyAm: 'hy-AM',
    IdId: 'id-ID',
    IkUs: 'ik-US',
    IsIs: 'is-IS',
    It: 'it',
    ItIt: 'it-IT',
    IuCa: 'iu-CA',
    Ja: 'ja',
    JaJp: 'ja-JP',
    JaKs: 'ja-KS',
    JvId: 'jv-ID',
    KaGe: 'ka-GE',
    KkKz: 'kk-KZ',
    KmKh: 'km-KH',
    KnIn: 'kn-IN',
    Ko: 'ko',
    KoKr: 'ko-KR',
    KuTr: 'ku-TR',
    KyKg: 'ky-KG',
    LoLa: 'lo-LA',
    LtLt: 'lt-LT',
    LvLv: 'lv-LV',
    MgMg: 'mg-MG',
    MkMk: 'mk-MK',
    MlIn: 'ml-IN',
    MnMn: 'mn-MN',
    MrIn: 'mr-IN',
    MsMy: 'ms-MY',
    MtMt: 'mt-MT',
    MyMm: 'my-MM',
    NbNo: 'nb-NO',
    NeNp: 'ne-NP',
    NlBe: 'nl-BE',
    NlNl: 'nl-NL',
    NnNo: 'nn-NO',
    OrIn: 'or-IN',
    PaIn: 'pa-IN',
    PlPl: 'pl-PL',
    PsAf: 'ps-AF',
    Pt: 'pt',
    PtBr: 'pt-BR',
    PtPt: 'pt-PT',
    RoRo: 'ro-RO',
    Ru: 'ru',
    RuRu: 'ru-RU',
    RwRw: 'rw-RW',
    ScIt: 'sc-IT',
    SiLk: 'si-LK',
    SkSk: 'sk-SK',
    SlSi: 'sl-SI',
    SnZw: 'sn-ZW',
    SqAl: 'sq-AL',
    SrRs: 'sr-RS',
    SvSe: 'sv-SE',
    SwKe: 'sw-KE',
    SySy: 'sy-SY',
    SzPl: 'sz-PL',
    TaIn: 'ta-IN',
    TeIn: 'te-IN',
    TgTj: 'tg-TJ',
    ThTh: 'th-TH',
    TlPh: 'tl-PH',
    Tr: 'tr',
    TrTr: 'tr-TR',
    TtRu: 'tt-RU',
    TzMa: 'tz-MA',
    UkUa: 'uk-UA',
    UrPk: 'ur-PK',
    UzUz: 'uz-UZ',
    ViVn: 'vi-VN',
    Zh: 'zh',
    ZhCn: 'zh-CN',
    ZhHk: 'zh-HK',
    ZhMo: 'zh-MO',
    ZhTw: 'zh-TW',
    ZzTr: 'zz-TR'
} as const;

export type GetSignInExp200ResponseLanguageInfoFallbackLanguageEnum = typeof GetSignInExp200ResponseLanguageInfoFallbackLanguageEnum[keyof typeof GetSignInExp200ResponseLanguageInfoFallbackLanguageEnum];

/**
 * MFA settings
 * @export
 * @interface GetSignInExp200ResponseMfa
 */
export interface GetSignInExp200ResponseMfa {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetSignInExp200ResponseMfa
     */
    'factors': Array<GetSignInExp200ResponseMfaFactorsEnum>;
    /**
     * 
     * @type {string}
     * @memberof GetSignInExp200ResponseMfa
     */
    'policy': GetSignInExp200ResponseMfaPolicyEnum;
}

export const GetSignInExp200ResponseMfaFactorsEnum = {
    Totp: 'Totp',
    WebAuthn: 'WebAuthn',
    BackupCode: 'BackupCode'
} as const;

export type GetSignInExp200ResponseMfaFactorsEnum = typeof GetSignInExp200ResponseMfaFactorsEnum[keyof typeof GetSignInExp200ResponseMfaFactorsEnum];
export const GetSignInExp200ResponseMfaPolicyEnum = {
    UserControlled: 'UserControlled',
    Mandatory: 'Mandatory'
} as const;

export type GetSignInExp200ResponseMfaPolicyEnum = typeof GetSignInExp200ResponseMfaPolicyEnum[keyof typeof GetSignInExp200ResponseMfaPolicyEnum];

/**
 * Password policies to adjust the password strength requirements.
 * @export
 * @interface GetSignInExp200ResponsePasswordPolicy
 */
export interface GetSignInExp200ResponsePasswordPolicy {
    /**
     * 
     * @type {GetSignInExp200ResponsePasswordPolicyLength}
     * @memberof GetSignInExp200ResponsePasswordPolicy
     */
    'length'?: GetSignInExp200ResponsePasswordPolicyLength;
    /**
     * 
     * @type {GetSignInExp200ResponsePasswordPolicyCharacterTypes}
     * @memberof GetSignInExp200ResponsePasswordPolicy
     */
    'characterTypes'?: GetSignInExp200ResponsePasswordPolicyCharacterTypes;
    /**
     * 
     * @type {GetSignInExp200ResponsePasswordPolicyRejects}
     * @memberof GetSignInExp200ResponsePasswordPolicy
     */
    'rejects'?: GetSignInExp200ResponsePasswordPolicyRejects;
}
/**
 * 
 * @export
 * @interface GetSignInExp200ResponsePasswordPolicyCharacterTypes
 */
export interface GetSignInExp200ResponsePasswordPolicyCharacterTypes {
    /**
     * 
     * @type {number}
     * @memberof GetSignInExp200ResponsePasswordPolicyCharacterTypes
     */
    'min': number;
}
/**
 * 
 * @export
 * @interface GetSignInExp200ResponsePasswordPolicyLength
 */
export interface GetSignInExp200ResponsePasswordPolicyLength {
    /**
     * 
     * @type {number}
     * @memberof GetSignInExp200ResponsePasswordPolicyLength
     */
    'min': number;
    /**
     * 
     * @type {number}
     * @memberof GetSignInExp200ResponsePasswordPolicyLength
     */
    'max': number;
}
/**
 * 
 * @export
 * @interface GetSignInExp200ResponsePasswordPolicyRejects
 */
export interface GetSignInExp200ResponsePasswordPolicyRejects {
    /**
     * 
     * @type {boolean}
     * @memberof GetSignInExp200ResponsePasswordPolicyRejects
     */
    'pwned': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetSignInExp200ResponsePasswordPolicyRejects
     */
    'repetitionAndSequence': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetSignInExp200ResponsePasswordPolicyRejects
     */
    'userInfo': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetSignInExp200ResponsePasswordPolicyRejects
     */
    'words': Array<string>;
}
/**
 * Sign-in method settings.
 * @export
 * @interface GetSignInExp200ResponseSignIn
 */
export interface GetSignInExp200ResponseSignIn {
    /**
     * 
     * @type {Array<GetSignInExp200ResponseSignInMethodsInner>}
     * @memberof GetSignInExp200ResponseSignIn
     */
    'methods': Array<GetSignInExp200ResponseSignInMethodsInner>;
}
/**
 * 
 * @export
 * @interface GetSignInExp200ResponseSignInMethodsInner
 */
export interface GetSignInExp200ResponseSignInMethodsInner {
    /**
     * 
     * @type {string}
     * @memberof GetSignInExp200ResponseSignInMethodsInner
     */
    'identifier': GetSignInExp200ResponseSignInMethodsInnerIdentifierEnum;
    /**
     * 
     * @type {boolean}
     * @memberof GetSignInExp200ResponseSignInMethodsInner
     */
    'password': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetSignInExp200ResponseSignInMethodsInner
     */
    'verificationCode': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetSignInExp200ResponseSignInMethodsInner
     */
    'isPasswordPrimary': boolean;
}

export const GetSignInExp200ResponseSignInMethodsInnerIdentifierEnum = {
    Username: 'username',
    Email: 'email',
    Phone: 'phone'
} as const;

export type GetSignInExp200ResponseSignInMethodsInnerIdentifierEnum = typeof GetSignInExp200ResponseSignInMethodsInnerIdentifierEnum[keyof typeof GetSignInExp200ResponseSignInMethodsInnerIdentifierEnum];

/**
 * Sign-up method settings.
 * @export
 * @interface GetSignInExp200ResponseSignUp
 */
export interface GetSignInExp200ResponseSignUp {
    /**
     * Allowed identifiers when signing-up.
     * @type {Array<string>}
     * @memberof GetSignInExp200ResponseSignUp
     */
    'identifiers': Array<GetSignInExp200ResponseSignUpIdentifiersEnum>;
    /**
     * Whether the user is required to set a password when signing-up.
     * @type {boolean}
     * @memberof GetSignInExp200ResponseSignUp
     */
    'password': boolean;
    /**
     * Whether the user is required to verify their email/phone when signing-up.
     * @type {boolean}
     * @memberof GetSignInExp200ResponseSignUp
     */
    'verify': boolean;
}

export const GetSignInExp200ResponseSignUpIdentifiersEnum = {
    Username: 'username',
    Email: 'email',
    Phone: 'phone'
} as const;

export type GetSignInExp200ResponseSignUpIdentifiersEnum = typeof GetSignInExp200ResponseSignUpIdentifiersEnum[keyof typeof GetSignInExp200ResponseSignUpIdentifiersEnum];

/**
 * 
 * @export
 * @interface GetSignInExp200ResponseSocialSignIn
 */
export interface GetSignInExp200ResponseSocialSignIn {
    /**
     * 
     * @type {boolean}
     * @memberof GetSignInExp200ResponseSocialSignIn
     */
    'automaticAccountLinking'?: boolean;
}
/**
 * 
 * @export
 * @interface GetSignInExperienceConfig200Response
 */
export interface GetSignInExperienceConfig200Response {
    /**
     * 
     * @type {string}
     * @memberof GetSignInExperienceConfig200Response
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof GetSignInExperienceConfig200Response
     */
    'id': string;
    /**
     * 
     * @type {UpdateSignInExp200ResponseColor}
     * @memberof GetSignInExperienceConfig200Response
     */
    'color': UpdateSignInExp200ResponseColor;
    /**
     * 
     * @type {ApiInteractionConsentGet200ResponseApplicationBranding}
     * @memberof GetSignInExperienceConfig200Response
     */
    'branding': ApiInteractionConsentGet200ResponseApplicationBranding;
    /**
     * 
     * @type {UpdateSignInExp200ResponseLanguageInfo}
     * @memberof GetSignInExperienceConfig200Response
     */
    'languageInfo': UpdateSignInExp200ResponseLanguageInfo;
    /**
     * 
     * @type {string}
     * @memberof GetSignInExperienceConfig200Response
     */
    'termsOfUseUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetSignInExperienceConfig200Response
     */
    'privacyPolicyUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetSignInExperienceConfig200Response
     */
    'agreeToTermsPolicy': GetSignInExperienceConfig200ResponseAgreeToTermsPolicyEnum;
    /**
     * 
     * @type {UpdateSignInExp200ResponseSignIn}
     * @memberof GetSignInExperienceConfig200Response
     */
    'signIn': UpdateSignInExp200ResponseSignIn;
    /**
     * 
     * @type {UpdateSignInExp200ResponseSignUp}
     * @memberof GetSignInExperienceConfig200Response
     */
    'signUp': UpdateSignInExp200ResponseSignUp;
    /**
     * 
     * @type {GetSignInExp200ResponseSocialSignIn}
     * @memberof GetSignInExperienceConfig200Response
     */
    'socialSignIn': GetSignInExp200ResponseSocialSignIn;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetSignInExperienceConfig200Response
     */
    'socialSignInConnectorTargets': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GetSignInExperienceConfig200Response
     */
    'signInMode': GetSignInExperienceConfig200ResponseSignInModeEnum;
    /**
     * 
     * @type {string}
     * @memberof GetSignInExperienceConfig200Response
     */
    'customCss': string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GetSignInExperienceConfig200Response
     */
    'customContent': { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof GetSignInExperienceConfig200Response
     */
    'customUiAssetId': string | null;
    /**
     * 
     * @type {UpdateSignInExp200ResponsePasswordPolicy}
     * @memberof GetSignInExperienceConfig200Response
     */
    'passwordPolicy': UpdateSignInExp200ResponsePasswordPolicy;
    /**
     * 
     * @type {UpdateSignInExp200ResponseMfa}
     * @memberof GetSignInExperienceConfig200Response
     */
    'mfa': UpdateSignInExp200ResponseMfa;
    /**
     * 
     * @type {boolean}
     * @memberof GetSignInExperienceConfig200Response
     */
    'singleSignOnEnabled': boolean;
    /**
     * 
     * @type {Array<GetSignInExperienceConfig200ResponseSocialConnectorsInner>}
     * @memberof GetSignInExperienceConfig200Response
     */
    'socialConnectors': Array<GetSignInExperienceConfig200ResponseSocialConnectorsInner>;
    /**
     * 
     * @type {Array<GetSignInExperienceConfig200ResponseSsoConnectorsInner>}
     * @memberof GetSignInExperienceConfig200Response
     */
    'ssoConnectors': Array<GetSignInExperienceConfig200ResponseSsoConnectorsInner>;
    /**
     * 
     * @type {GetSignInExperienceConfig200ResponseForgotPassword}
     * @memberof GetSignInExperienceConfig200Response
     */
    'forgotPassword': GetSignInExperienceConfig200ResponseForgotPassword;
    /**
     * 
     * @type {boolean}
     * @memberof GetSignInExperienceConfig200Response
     */
    'isDevelopmentTenant': boolean;
    /**
     * 
     * @type {GetSignInExperienceConfig200ResponseGoogleOneTap}
     * @memberof GetSignInExperienceConfig200Response
     */
    'googleOneTap'?: GetSignInExperienceConfig200ResponseGoogleOneTap;
}

export const GetSignInExperienceConfig200ResponseAgreeToTermsPolicyEnum = {
    Automatic: 'Automatic',
    ManualRegistrationOnly: 'ManualRegistrationOnly',
    Manual: 'Manual'
} as const;

export type GetSignInExperienceConfig200ResponseAgreeToTermsPolicyEnum = typeof GetSignInExperienceConfig200ResponseAgreeToTermsPolicyEnum[keyof typeof GetSignInExperienceConfig200ResponseAgreeToTermsPolicyEnum];
export const GetSignInExperienceConfig200ResponseSignInModeEnum = {
    SignIn: 'SignIn',
    Register: 'Register',
    SignInAndRegister: 'SignInAndRegister'
} as const;

export type GetSignInExperienceConfig200ResponseSignInModeEnum = typeof GetSignInExperienceConfig200ResponseSignInModeEnum[keyof typeof GetSignInExperienceConfig200ResponseSignInModeEnum];

/**
 * 
 * @export
 * @interface GetSignInExperienceConfig200ResponseForgotPassword
 */
export interface GetSignInExperienceConfig200ResponseForgotPassword {
    /**
     * 
     * @type {boolean}
     * @memberof GetSignInExperienceConfig200ResponseForgotPassword
     */
    'phone': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetSignInExperienceConfig200ResponseForgotPassword
     */
    'email': boolean;
}
/**
 * 
 * @export
 * @interface GetSignInExperienceConfig200ResponseGoogleOneTap
 */
export interface GetSignInExperienceConfig200ResponseGoogleOneTap {
    /**
     * 
     * @type {boolean}
     * @memberof GetSignInExperienceConfig200ResponseGoogleOneTap
     */
    'isEnabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetSignInExperienceConfig200ResponseGoogleOneTap
     */
    'autoSelect'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetSignInExperienceConfig200ResponseGoogleOneTap
     */
    'closeOnTapOutside'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetSignInExperienceConfig200ResponseGoogleOneTap
     */
    'itpSupport'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetSignInExperienceConfig200ResponseGoogleOneTap
     */
    'clientId': string;
    /**
     * 
     * @type {string}
     * @memberof GetSignInExperienceConfig200ResponseGoogleOneTap
     */
    'connectorId': string;
}
/**
 * 
 * @export
 * @interface GetSignInExperienceConfig200ResponseSocialConnectorsInner
 */
export interface GetSignInExperienceConfig200ResponseSocialConnectorsInner {
    /**
     * 
     * @type {string}
     * @memberof GetSignInExperienceConfig200ResponseSocialConnectorsInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetSignInExperienceConfig200ResponseSocialConnectorsInner
     */
    'target': string;
    /**
     * Validator function
     * @type {object}
     * @memberof GetSignInExperienceConfig200ResponseSocialConnectorsInner
     */
    'name': object;
    /**
     * 
     * @type {string}
     * @memberof GetSignInExperienceConfig200ResponseSocialConnectorsInner
     */
    'logo': string;
    /**
     * 
     * @type {string}
     * @memberof GetSignInExperienceConfig200ResponseSocialConnectorsInner
     */
    'logoDark': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetSignInExperienceConfig200ResponseSocialConnectorsInner
     */
    'fromEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSignInExperienceConfig200ResponseSocialConnectorsInner
     */
    'platform': GetSignInExperienceConfig200ResponseSocialConnectorsInnerPlatformEnum | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetSignInExperienceConfig200ResponseSocialConnectorsInner
     */
    'isStandard'?: boolean;
}

export const GetSignInExperienceConfig200ResponseSocialConnectorsInnerPlatformEnum = {
    Native: 'Native',
    Universal: 'Universal',
    Web: 'Web'
} as const;

export type GetSignInExperienceConfig200ResponseSocialConnectorsInnerPlatformEnum = typeof GetSignInExperienceConfig200ResponseSocialConnectorsInnerPlatformEnum[keyof typeof GetSignInExperienceConfig200ResponseSocialConnectorsInnerPlatformEnum];

/**
 * 
 * @export
 * @interface GetSignInExperienceConfig200ResponseSsoConnectorsInner
 */
export interface GetSignInExperienceConfig200ResponseSsoConnectorsInner {
    /**
     * 
     * @type {string}
     * @memberof GetSignInExperienceConfig200ResponseSsoConnectorsInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetSignInExperienceConfig200ResponseSsoConnectorsInner
     */
    'connectorName': string;
    /**
     * 
     * @type {string}
     * @memberof GetSignInExperienceConfig200ResponseSsoConnectorsInner
     */
    'logo': string;
    /**
     * 
     * @type {string}
     * @memberof GetSignInExperienceConfig200ResponseSsoConnectorsInner
     */
    'darkLogo'?: string;
}
/**
 * @type GetSignInExperiencePhrases200ResponseValue
 * @export
 */
export type GetSignInExperiencePhrases200ResponseValue = string | { [key: string]: any; };

/**
 * 
 * @export
 * @interface GetSystemApplicationConfig200Response
 */
export interface GetSystemApplicationConfig200Response {
    /**
     * 
     * @type {GetSystemApplicationConfig200ResponseProtectedApps}
     * @memberof GetSystemApplicationConfig200Response
     */
    'protectedApps': GetSystemApplicationConfig200ResponseProtectedApps;
}
/**
 * 
 * @export
 * @interface GetSystemApplicationConfig200ResponseProtectedApps
 */
export interface GetSystemApplicationConfig200ResponseProtectedApps {
    /**
     * 
     * @type {string}
     * @memberof GetSystemApplicationConfig200ResponseProtectedApps
     */
    'defaultDomain': string;
}
/**
 * 
 * @export
 * @interface GetTotalUserCount200Response
 */
export interface GetTotalUserCount200Response {
    /**
     * 
     * @type {number}
     * @memberof GetTotalUserCount200Response
     */
    'totalUserCount': number;
}
/**
 * 
 * @export
 * @interface GetUser200Response
 */
export interface GetUser200Response {
    /**
     * 
     * @type {string}
     * @memberof GetUser200Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetUser200Response
     */
    'username': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetUser200Response
     */
    'primaryEmail': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetUser200Response
     */
    'primaryPhone': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetUser200Response
     */
    'name': string | null;
    /**
     * 
     * @type {string}
     * @memberof GetUser200Response
     */
    'avatar': string | null;
    /**
     * arbitrary
     * @type {object}
     * @memberof GetUser200Response
     */
    'customData': object;
    /**
     * 
     * @type {{ [key: string]: GetJwtCustomizer200ResponseOneOfContextSampleUserIdentitiesValue; }}
     * @memberof GetUser200Response
     */
    'identities': { [key: string]: GetJwtCustomizer200ResponseOneOfContextSampleUserIdentitiesValue; };
    /**
     * 
     * @type {number}
     * @memberof GetUser200Response
     */
    'lastSignInAt': number | null;
    /**
     * 
     * @type {number}
     * @memberof GetUser200Response
     */
    'createdAt': number;
    /**
     * 
     * @type {number}
     * @memberof GetUser200Response
     */
    'updatedAt': number;
    /**
     * 
     * @type {GetJwtCustomizer200ResponseOneOfContextSampleUserProfile}
     * @memberof GetUser200Response
     */
    'profile': GetJwtCustomizer200ResponseOneOfContextSampleUserProfile;
    /**
     * 
     * @type {string}
     * @memberof GetUser200Response
     */
    'applicationId': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetUser200Response
     */
    'isSuspended': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetUser200Response
     */
    'hasPassword'?: boolean;
    /**
     * List of SSO identities associated with the user. Only available when the `includeSsoIdentities` query parameter is provided with a truthy value.
     * @type {Array<GetUser200ResponseSsoIdentitiesInner>}
     * @memberof GetUser200Response
     */
    'ssoIdentities'?: Array<GetUser200ResponseSsoIdentitiesInner>;
}
/**
 * 
 * @export
 * @interface GetUser200ResponseSsoIdentitiesInner
 */
export interface GetUser200ResponseSsoIdentitiesInner {
    /**
     * 
     * @type {string}
     * @memberof GetUser200ResponseSsoIdentitiesInner
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof GetUser200ResponseSsoIdentitiesInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GetUser200ResponseSsoIdentitiesInner
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof GetUser200ResponseSsoIdentitiesInner
     */
    'issuer': string;
    /**
     * 
     * @type {string}
     * @memberof GetUser200ResponseSsoIdentitiesInner
     */
    'identityId': string;
    /**
     * arbitrary
     * @type {object}
     * @memberof GetUser200ResponseSsoIdentitiesInner
     */
    'detail': object;
    /**
     * 
     * @type {number}
     * @memberof GetUser200ResponseSsoIdentitiesInner
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof GetUser200ResponseSsoIdentitiesInner
     */
    'ssoConnectorId': string;
}
/**
 * 
 * @export
 * @interface GetUserAssetServiceStatus200Response
 */
export interface GetUserAssetServiceStatus200Response {
    /**
     * 
     * @type {GetUserAssetServiceStatus200ResponseStatus}
     * @memberof GetUserAssetServiceStatus200Response
     */
    'status': GetUserAssetServiceStatus200ResponseStatus;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetUserAssetServiceStatus200Response
     */
    'allowUploadMimeTypes'?: Array<GetUserAssetServiceStatus200ResponseAllowUploadMimeTypesEnum>;
    /**
     * 
     * @type {number}
     * @memberof GetUserAssetServiceStatus200Response
     */
    'maxUploadFileSize'?: number;
}

export const GetUserAssetServiceStatus200ResponseAllowUploadMimeTypesEnum = {
    Jpeg: 'image/jpeg',
    Png: 'image/png',
    Gif: 'image/gif',
    VndMicrosoftIcon: 'image/vnd.microsoft.icon',
    XIcon: 'image/x-icon',
    Svgxml: 'image/svg+xml',
    Tiff: 'image/tiff',
    Webp: 'image/webp',
    Bmp: 'image/bmp'
} as const;

export type GetUserAssetServiceStatus200ResponseAllowUploadMimeTypesEnum = typeof GetUserAssetServiceStatus200ResponseAllowUploadMimeTypesEnum[keyof typeof GetUserAssetServiceStatus200ResponseAllowUploadMimeTypesEnum];

/**
 * @type GetUserAssetServiceStatus200ResponseStatus
 * @export
 */
export type GetUserAssetServiceStatus200ResponseStatus = string;

/**
 * 
 * @export
 * @interface GetUserHasPassword200Response
 */
export interface GetUserHasPassword200Response {
    /**
     * 
     * @type {boolean}
     * @memberof GetUserHasPassword200Response
     */
    'hasPassword': boolean;
}
/**
 * 
 * @export
 * @interface ListApplicationOrganizations200ResponseInner
 */
export interface ListApplicationOrganizations200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ListApplicationOrganizations200ResponseInner
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof ListApplicationOrganizations200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListApplicationOrganizations200ResponseInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ListApplicationOrganizations200ResponseInner
     */
    'description': string | null;
    /**
     * arbitrary
     * @type {object}
     * @memberof ListApplicationOrganizations200ResponseInner
     */
    'customData': object;
    /**
     * 
     * @type {boolean}
     * @memberof ListApplicationOrganizations200ResponseInner
     */
    'isMfaRequired': boolean;
    /**
     * 
     * @type {number}
     * @memberof ListApplicationOrganizations200ResponseInner
     */
    'createdAt': number;
    /**
     * 
     * @type {Array<ListApplicationOrganizations200ResponseInnerOrganizationRolesInner>}
     * @memberof ListApplicationOrganizations200ResponseInner
     */
    'organizationRoles': Array<ListApplicationOrganizations200ResponseInnerOrganizationRolesInner>;
}
/**
 * 
 * @export
 * @interface ListApplicationOrganizations200ResponseInnerOrganizationRolesInner
 */
export interface ListApplicationOrganizations200ResponseInnerOrganizationRolesInner {
    /**
     * 
     * @type {string}
     * @memberof ListApplicationOrganizations200ResponseInnerOrganizationRolesInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListApplicationOrganizations200ResponseInnerOrganizationRolesInner
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ListApplicationRoles200ResponseInner
 */
export interface ListApplicationRoles200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ListApplicationRoles200ResponseInner
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof ListApplicationRoles200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListApplicationRoles200ResponseInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ListApplicationRoles200ResponseInner
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ListApplicationRoles200ResponseInner
     */
    'type': ListApplicationRoles200ResponseInnerTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ListApplicationRoles200ResponseInner
     */
    'isDefault': boolean;
}

export const ListApplicationRoles200ResponseInnerTypeEnum = {
    User: 'User',
    MachineToMachine: 'MachineToMachine'
} as const;

export type ListApplicationRoles200ResponseInnerTypeEnum = typeof ListApplicationRoles200ResponseInnerTypeEnum[keyof typeof ListApplicationRoles200ResponseInnerTypeEnum];

/**
 * 
 * @export
 * @interface ListApplicationUserConsentOrganizations200Response
 */
export interface ListApplicationUserConsentOrganizations200Response {
    /**
     * A list of organization entities granted by the user for the application.
     * @type {Array<ListApplicationUserConsentOrganizations200ResponseOrganizationsInner>}
     * @memberof ListApplicationUserConsentOrganizations200Response
     */
    'organizations': Array<ListApplicationUserConsentOrganizations200ResponseOrganizationsInner>;
}
/**
 * 
 * @export
 * @interface ListApplicationUserConsentOrganizations200ResponseOrganizationsInner
 */
export interface ListApplicationUserConsentOrganizations200ResponseOrganizationsInner {
    /**
     * 
     * @type {string}
     * @memberof ListApplicationUserConsentOrganizations200ResponseOrganizationsInner
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof ListApplicationUserConsentOrganizations200ResponseOrganizationsInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListApplicationUserConsentOrganizations200ResponseOrganizationsInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ListApplicationUserConsentOrganizations200ResponseOrganizationsInner
     */
    'description': string | null;
    /**
     * arbitrary
     * @type {object}
     * @memberof ListApplicationUserConsentOrganizations200ResponseOrganizationsInner
     */
    'customData': object;
    /**
     * 
     * @type {boolean}
     * @memberof ListApplicationUserConsentOrganizations200ResponseOrganizationsInner
     */
    'isMfaRequired': boolean;
    /**
     * 
     * @type {number}
     * @memberof ListApplicationUserConsentOrganizations200ResponseOrganizationsInner
     */
    'createdAt': number;
}
/**
 * 
 * @export
 * @interface ListApplicationUserConsentScopes200Response
 */
export interface ListApplicationUserConsentScopes200Response {
    /**
     * A list of organization scope details assigned to the application.
     * @type {Array<ListApplicationUserConsentScopes200ResponseOrganizationScopesInner>}
     * @memberof ListApplicationUserConsentScopes200Response
     */
    'organizationScopes': Array<ListApplicationUserConsentScopes200ResponseOrganizationScopesInner>;
    /**
     * A list of resource scope details grouped by resource id assigned to the application.
     * @type {Array<ListApplicationUserConsentScopes200ResponseResourceScopesInner>}
     * @memberof ListApplicationUserConsentScopes200Response
     */
    'resourceScopes': Array<ListApplicationUserConsentScopes200ResponseResourceScopesInner>;
    /**
     * A list of organization resource scope details grouped by resource id assigned to the application.
     * @type {Array<ListApplicationUserConsentScopes200ResponseResourceScopesInner>}
     * @memberof ListApplicationUserConsentScopes200Response
     */
    'organizationResourceScopes': Array<ListApplicationUserConsentScopes200ResponseResourceScopesInner>;
    /**
     * A list of user scope enum value assigned to the application.
     * @type {Array<string>}
     * @memberof ListApplicationUserConsentScopes200Response
     */
    'userScopes': Array<ListApplicationUserConsentScopes200ResponseUserScopesEnum>;
}

export const ListApplicationUserConsentScopes200ResponseUserScopesEnum = {
    Profile: 'profile',
    Email: 'email',
    Phone: 'phone',
    Address: 'address',
    CustomData: 'custom_data',
    Identities: 'identities',
    Roles: 'roles',
    Urnlogtoscopeorganizations: 'urn:logto:scope:organizations',
    UrnlogtoscopeorganizationRoles: 'urn:logto:scope:organization_roles'
} as const;

export type ListApplicationUserConsentScopes200ResponseUserScopesEnum = typeof ListApplicationUserConsentScopes200ResponseUserScopesEnum[keyof typeof ListApplicationUserConsentScopes200ResponseUserScopesEnum];

/**
 * 
 * @export
 * @interface ListApplicationUserConsentScopes200ResponseOrganizationScopesInner
 */
export interface ListApplicationUserConsentScopes200ResponseOrganizationScopesInner {
    /**
     * 
     * @type {string}
     * @memberof ListApplicationUserConsentScopes200ResponseOrganizationScopesInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListApplicationUserConsentScopes200ResponseOrganizationScopesInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ListApplicationUserConsentScopes200ResponseOrganizationScopesInner
     */
    'description': string | null;
}
/**
 * 
 * @export
 * @interface ListApplicationUserConsentScopes200ResponseResourceScopesInner
 */
export interface ListApplicationUserConsentScopes200ResponseResourceScopesInner {
    /**
     * 
     * @type {ListApplicationUserConsentScopes200ResponseResourceScopesInnerResource}
     * @memberof ListApplicationUserConsentScopes200ResponseResourceScopesInner
     */
    'resource': ListApplicationUserConsentScopes200ResponseResourceScopesInnerResource;
    /**
     * 
     * @type {Array<ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerScopesInner>}
     * @memberof ListApplicationUserConsentScopes200ResponseResourceScopesInner
     */
    'scopes': Array<ApiInteractionConsentGet200ResponseOrganizationsInnerMissingResourceScopesInnerScopesInner>;
}
/**
 * 
 * @export
 * @interface ListApplicationUserConsentScopes200ResponseResourceScopesInnerResource
 */
export interface ListApplicationUserConsentScopes200ResponseResourceScopesInnerResource {
    /**
     * 
     * @type {string}
     * @memberof ListApplicationUserConsentScopes200ResponseResourceScopesInnerResource
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListApplicationUserConsentScopes200ResponseResourceScopesInnerResource
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ListApplicationUserConsentScopes200ResponseResourceScopesInnerResource
     */
    'indicator': string;
}
/**
 * 
 * @export
 * @interface ListApplications200ResponseInner
 */
export interface ListApplications200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInner
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInner
     */
    'secret': string;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInner
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInner
     */
    'type': ListApplications200ResponseInnerTypeEnum;
    /**
     * 
     * @type {ListApplications200ResponseInnerOidcClientMetadata}
     * @memberof ListApplications200ResponseInner
     */
    'oidcClientMetadata': ListApplications200ResponseInnerOidcClientMetadata;
    /**
     * 
     * @type {ListApplications200ResponseInnerCustomClientMetadata}
     * @memberof ListApplications200ResponseInner
     */
    'customClientMetadata': ListApplications200ResponseInnerCustomClientMetadata;
    /**
     * 
     * @type {ListApplications200ResponseInnerProtectedAppMetadata}
     * @memberof ListApplications200ResponseInner
     */
    'protectedAppMetadata': ListApplications200ResponseInnerProtectedAppMetadata | null;
    /**
     * 
     * @type {boolean}
     * @memberof ListApplications200ResponseInner
     */
    'isThirdParty': boolean;
    /**
     * 
     * @type {number}
     * @memberof ListApplications200ResponseInner
     */
    'createdAt': number;
}

export const ListApplications200ResponseInnerTypeEnum = {
    Native: 'Native',
    Spa: 'SPA',
    Traditional: 'Traditional',
    MachineToMachine: 'MachineToMachine',
    Protected: 'Protected'
} as const;

export type ListApplications200ResponseInnerTypeEnum = typeof ListApplications200ResponseInnerTypeEnum[keyof typeof ListApplications200ResponseInnerTypeEnum];

/**
 * 
 * @export
 * @interface ListApplications200ResponseInnerCustomClientMetadata
 */
export interface ListApplications200ResponseInnerCustomClientMetadata {
    /**
     * 
     * @type {Array<string>}
     * @memberof ListApplications200ResponseInnerCustomClientMetadata
     */
    'corsAllowedOrigins'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ListApplications200ResponseInnerCustomClientMetadata
     */
    'idTokenTtl'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListApplications200ResponseInnerCustomClientMetadata
     */
    'refreshTokenTtl'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListApplications200ResponseInnerCustomClientMetadata
     */
    'refreshTokenTtlInDays'?: number;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerCustomClientMetadata
     */
    'tenantId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListApplications200ResponseInnerCustomClientMetadata
     */
    'alwaysIssueRefreshToken'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ListApplications200ResponseInnerCustomClientMetadata
     */
    'rotateRefreshToken'?: boolean;
}
/**
 * 
 * @export
 * @interface ListApplications200ResponseInnerOidcClientMetadata
 */
export interface ListApplications200ResponseInnerOidcClientMetadata {
    /**
     * 
     * @type {Array<ListApplications200ResponseInnerOidcClientMetadataRedirectUrisInner>}
     * @memberof ListApplications200ResponseInnerOidcClientMetadata
     */
    'redirectUris': Array<ListApplications200ResponseInnerOidcClientMetadataRedirectUrisInner>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListApplications200ResponseInnerOidcClientMetadata
     */
    'postLogoutRedirectUris': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerOidcClientMetadata
     */
    'backchannelLogoutUri'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListApplications200ResponseInnerOidcClientMetadata
     */
    'backchannelLogoutSessionRequired'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerOidcClientMetadata
     */
    'logoUri'?: string;
}
/**
 * @type ListApplications200ResponseInnerOidcClientMetadataRedirectUrisInner
 * @export
 */
export type ListApplications200ResponseInnerOidcClientMetadataRedirectUrisInner = object;

/**
 * 
 * @export
 * @interface ListApplications200ResponseInnerProtectedAppMetadata
 */
export interface ListApplications200ResponseInnerProtectedAppMetadata {
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerProtectedAppMetadata
     */
    'host': string;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerProtectedAppMetadata
     */
    'origin': string;
    /**
     * 
     * @type {number}
     * @memberof ListApplications200ResponseInnerProtectedAppMetadata
     */
    'sessionDuration': number;
    /**
     * 
     * @type {Array<ListApplications200ResponseInnerProtectedAppMetadataPageRulesInner>}
     * @memberof ListApplications200ResponseInnerProtectedAppMetadata
     */
    'pageRules': Array<ListApplications200ResponseInnerProtectedAppMetadataPageRulesInner>;
    /**
     * 
     * @type {Array<ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInner>}
     * @memberof ListApplications200ResponseInnerProtectedAppMetadata
     */
    'customDomains'?: Array<ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInner>;
}
/**
 * 
 * @export
 * @interface ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInner
 */
export interface ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInner {
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInner
     */
    'domain': string;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInner
     */
    'status': ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInner
     */
    'errorMessage': string | null;
    /**
     * 
     * @type {Array<ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerDnsRecordsInner>}
     * @memberof ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInner
     */
    'dnsRecords': Array<ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerDnsRecordsInner>;
    /**
     * 
     * @type {ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareData}
     * @memberof ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInner
     */
    'cloudflareData': ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareData | null;
}

export const ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerStatusEnum = {
    PendingVerification: 'PendingVerification',
    PendingSsl: 'PendingSsl',
    Active: 'Active',
    Error: 'Error'
} as const;

export type ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerStatusEnum = typeof ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerStatusEnum[keyof typeof ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerStatusEnum];

/**
 * 
 * @export
 * @interface ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareData
 */
export interface ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareData {
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareData
     */
    'status': string;
    /**
     * 
     * @type {ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareDataSsl}
     * @memberof ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareData
     */
    'ssl': ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareDataSsl;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareData
     */
    'verification_errors'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareDataSsl
 */
export interface ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareDataSsl {
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareDataSsl
     */
    'status': string;
    /**
     * 
     * @type {Array<ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareDataSslValidationErrorsInner>}
     * @memberof ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareDataSsl
     */
    'validation_errors'?: Array<ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareDataSslValidationErrorsInner>;
}
/**
 * 
 * @export
 * @interface ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareDataSslValidationErrorsInner
 */
export interface ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareDataSslValidationErrorsInner {
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerCloudflareDataSslValidationErrorsInner
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerDnsRecordsInner
 */
export interface ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerDnsRecordsInner {
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerDnsRecordsInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerDnsRecordsInner
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerDnsRecordsInner
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface ListApplications200ResponseInnerProtectedAppMetadataPageRulesInner
 */
export interface ListApplications200ResponseInnerProtectedAppMetadataPageRulesInner {
    /**
     * 
     * @type {string}
     * @memberof ListApplications200ResponseInnerProtectedAppMetadataPageRulesInner
     */
    'path': string;
}
/**
 * @type ListApplicationsIsThirdPartyParameter
 * @export
 */
export type ListApplicationsIsThirdPartyParameter = string;

/**
 * @type ListApplicationsTypesParameter
 * @export
 */
export type ListApplicationsTypesParameter = Array<string> | string;

/**
 * 
 * @export
 * @interface ListConnectorFactories200ResponseInner
 */
export interface ListConnectorFactories200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ListConnectorFactories200ResponseInner
     */
    'type': ListConnectorFactories200ResponseInnerTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ListConnectorFactories200ResponseInner
     */
    'isDemo'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ListConnectorFactories200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListConnectorFactories200ResponseInner
     */
    'target': string;
    /**
     * Validator function
     * @type {object}
     * @memberof ListConnectorFactories200ResponseInner
     */
    'name': object;
    /**
     * Validator function
     * @type {object}
     * @memberof ListConnectorFactories200ResponseInner
     */
    'description': object;
    /**
     * 
     * @type {string}
     * @memberof ListConnectorFactories200ResponseInner
     */
    'logo': string;
    /**
     * 
     * @type {string}
     * @memberof ListConnectorFactories200ResponseInner
     */
    'logoDark': string | null;
    /**
     * 
     * @type {string}
     * @memberof ListConnectorFactories200ResponseInner
     */
    'readme': string;
    /**
     * 
     * @type {string}
     * @memberof ListConnectorFactories200ResponseInner
     */
    'configTemplate'?: string;
    /**
     * 
     * @type {Array<ListConnectors200ResponseInnerFormItemsInner>}
     * @memberof ListConnectorFactories200ResponseInner
     */
    'formItems'?: Array<ListConnectors200ResponseInnerFormItemsInner>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ListConnectorFactories200ResponseInner
     */
    'customData'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ListConnectorFactories200ResponseInner
     */
    'fromEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListConnectorFactories200ResponseInner
     */
    'platform': ListConnectorFactories200ResponseInnerPlatformEnum | null;
    /**
     * 
     * @type {boolean}
     * @memberof ListConnectorFactories200ResponseInner
     */
    'isStandard'?: boolean;
}

export const ListConnectorFactories200ResponseInnerTypeEnum = {
    Email: 'Email',
    Sms: 'Sms',
    Social: 'Social'
} as const;

export type ListConnectorFactories200ResponseInnerTypeEnum = typeof ListConnectorFactories200ResponseInnerTypeEnum[keyof typeof ListConnectorFactories200ResponseInnerTypeEnum];
export const ListConnectorFactories200ResponseInnerPlatformEnum = {
    Native: 'Native',
    Universal: 'Universal',
    Web: 'Web'
} as const;

export type ListConnectorFactories200ResponseInnerPlatformEnum = typeof ListConnectorFactories200ResponseInnerPlatformEnum[keyof typeof ListConnectorFactories200ResponseInnerPlatformEnum];

/**
 * 
 * @export
 * @interface ListConnectors200ResponseInner
 */
export interface ListConnectors200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListConnectors200ResponseInner
     */
    'syncProfile': boolean;
    /**
     * arbitrary
     * @type {object}
     * @memberof ListConnectors200ResponseInner
     */
    'config': object;
    /**
     * 
     * @type {ListConnectors200ResponseInnerMetadata}
     * @memberof ListConnectors200ResponseInner
     */
    'metadata': ListConnectors200ResponseInnerMetadata;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInner
     */
    'connectorId': string;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInner
     */
    'target': string;
    /**
     * Validator function
     * @type {object}
     * @memberof ListConnectors200ResponseInner
     */
    'name': object;
    /**
     * Validator function
     * @type {object}
     * @memberof ListConnectors200ResponseInner
     */
    'description': object;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInner
     */
    'logo': string;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInner
     */
    'logoDark': string | null;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInner
     */
    'readme': string;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInner
     */
    'configTemplate'?: string;
    /**
     * 
     * @type {Array<ListConnectors200ResponseInnerFormItemsInner>}
     * @memberof ListConnectors200ResponseInner
     */
    'formItems'?: Array<ListConnectors200ResponseInnerFormItemsInner>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ListConnectors200ResponseInner
     */
    'customData'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInner
     */
    'fromEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInner
     */
    'platform': ListConnectors200ResponseInnerPlatformEnum | null;
    /**
     * 
     * @type {boolean}
     * @memberof ListConnectors200ResponseInner
     */
    'isStandard'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInner
     */
    'type': ListConnectors200ResponseInnerTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ListConnectors200ResponseInner
     */
    'isDemo'?: boolean;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ListConnectors200ResponseInner
     */
    'extraInfo'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof ListConnectors200ResponseInner
     */
    'usage'?: number;
}

export const ListConnectors200ResponseInnerPlatformEnum = {
    Native: 'Native',
    Universal: 'Universal',
    Web: 'Web'
} as const;

export type ListConnectors200ResponseInnerPlatformEnum = typeof ListConnectors200ResponseInnerPlatformEnum[keyof typeof ListConnectors200ResponseInnerPlatformEnum];
export const ListConnectors200ResponseInnerTypeEnum = {
    Email: 'Email',
    Sms: 'Sms',
    Social: 'Social'
} as const;

export type ListConnectors200ResponseInnerTypeEnum = typeof ListConnectors200ResponseInnerTypeEnum[keyof typeof ListConnectors200ResponseInnerTypeEnum];

/**
 * @type ListConnectors200ResponseInnerFormItemsInner
 * @export
 */
export type ListConnectors200ResponseInnerFormItemsInner = ListConnectors200ResponseInnerFormItemsInnerOneOf | ListConnectors200ResponseInnerFormItemsInnerOneOf1 | ListConnectors200ResponseInnerFormItemsInnerOneOf2;

/**
 * 
 * @export
 * @interface ListConnectors200ResponseInnerFormItemsInnerOneOf
 */
export interface ListConnectors200ResponseInnerFormItemsInnerOneOf {
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf
     */
    'type': string;
    /**
     * 
     * @type {Array<ListConnectors200ResponseInnerFormItemsInnerOneOfSelectItemsInner>}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf
     */
    'selectItems': Array<ListConnectors200ResponseInnerFormItemsInnerOneOfSelectItemsInner>;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf
     */
    'placeholder'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf
     */
    'required'?: boolean;
    /**
     * 
     * @type {any}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf
     */
    'defaultValue'?: any;
    /**
     * 
     * @type {Array<ListConnectors200ResponseInnerFormItemsInnerOneOfShowConditionsInner>}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf
     */
    'showConditions'?: Array<ListConnectors200ResponseInnerFormItemsInnerOneOfShowConditionsInner>;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf
     */
    'tooltip'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf
     */
    'isConfidential'?: boolean;
}
/**
 * 
 * @export
 * @interface ListConnectors200ResponseInnerFormItemsInnerOneOf1
 */
export interface ListConnectors200ResponseInnerFormItemsInnerOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf1
     */
    'type': string;
    /**
     * 
     * @type {Array<ListConnectors200ResponseInnerFormItemsInnerOneOf1SelectItemsInner>}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf1
     */
    'selectItems': Array<ListConnectors200ResponseInnerFormItemsInnerOneOf1SelectItemsInner>;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf1
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf1
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf1
     */
    'placeholder'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf1
     */
    'required'?: boolean;
    /**
     * 
     * @type {any}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf1
     */
    'defaultValue'?: any;
    /**
     * 
     * @type {Array<ListConnectors200ResponseInnerFormItemsInnerOneOfShowConditionsInner>}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf1
     */
    'showConditions'?: Array<ListConnectors200ResponseInnerFormItemsInnerOneOfShowConditionsInner>;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf1
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf1
     */
    'tooltip'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf1
     */
    'isConfidential'?: boolean;
}
/**
 * 
 * @export
 * @interface ListConnectors200ResponseInnerFormItemsInnerOneOf1SelectItemsInner
 */
export interface ListConnectors200ResponseInnerFormItemsInnerOneOf1SelectItemsInner {
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf1SelectItemsInner
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface ListConnectors200ResponseInnerFormItemsInnerOneOf2
 */
export interface ListConnectors200ResponseInnerFormItemsInnerOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf2
     */
    'type': ListConnectors200ResponseInnerFormItemsInnerOneOf2TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf2
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf2
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf2
     */
    'placeholder'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf2
     */
    'required'?: boolean;
    /**
     * 
     * @type {any}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf2
     */
    'defaultValue'?: any;
    /**
     * 
     * @type {Array<ListConnectors200ResponseInnerFormItemsInnerOneOfShowConditionsInner>}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf2
     */
    'showConditions'?: Array<ListConnectors200ResponseInnerFormItemsInnerOneOfShowConditionsInner>;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf2
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf2
     */
    'tooltip'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOf2
     */
    'isConfidential'?: boolean;
}

export const ListConnectors200ResponseInnerFormItemsInnerOneOf2TypeEnum = {
    Text: 'Text',
    Number: 'Number',
    MultilineText: 'MultilineText',
    Switch: 'Switch',
    Json: 'Json'
} as const;

export type ListConnectors200ResponseInnerFormItemsInnerOneOf2TypeEnum = typeof ListConnectors200ResponseInnerFormItemsInnerOneOf2TypeEnum[keyof typeof ListConnectors200ResponseInnerFormItemsInnerOneOf2TypeEnum];

/**
 * 
 * @export
 * @interface ListConnectors200ResponseInnerFormItemsInnerOneOfSelectItemsInner
 */
export interface ListConnectors200ResponseInnerFormItemsInnerOneOfSelectItemsInner {
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOfSelectItemsInner
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOfSelectItemsInner
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface ListConnectors200ResponseInnerFormItemsInnerOneOfShowConditionsInner
 */
export interface ListConnectors200ResponseInnerFormItemsInnerOneOfShowConditionsInner {
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOfShowConditionsInner
     */
    'targetKey': string;
    /**
     * 
     * @type {any}
     * @memberof ListConnectors200ResponseInnerFormItemsInnerOneOfShowConditionsInner
     */
    'expectValue'?: any;
}
/**
 * 
 * @export
 * @interface ListConnectors200ResponseInnerMetadata
 */
export interface ListConnectors200ResponseInnerMetadata {
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInnerMetadata
     */
    'target'?: string;
    /**
     * Validator function
     * @type {object}
     * @memberof ListConnectors200ResponseInnerMetadata
     */
    'name'?: object;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInnerMetadata
     */
    'logo'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListConnectors200ResponseInnerMetadata
     */
    'logoDark'?: string | null;
}
/**
 * 
 * @export
 * @interface ListCustomPhrases200ResponseInner
 */
export interface ListCustomPhrases200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ListCustomPhrases200ResponseInner
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof ListCustomPhrases200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListCustomPhrases200ResponseInner
     */
    'languageTag': string;
    /**
     * 
     * @type {TranslationObject}
     * @memberof ListCustomPhrases200ResponseInner
     */
    'translation': TranslationObject;
}
/**
 * 
 * @export
 * @interface ListDomains200ResponseInner
 */
export interface ListDomains200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ListDomains200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListDomains200ResponseInner
     */
    'domain': string;
    /**
     * 
     * @type {string}
     * @memberof ListDomains200ResponseInner
     */
    'status': ListDomains200ResponseInnerStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ListDomains200ResponseInner
     */
    'errorMessage': string | null;
    /**
     * 
     * @type {Array<ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerDnsRecordsInner>}
     * @memberof ListDomains200ResponseInner
     */
    'dnsRecords': Array<ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInnerDnsRecordsInner>;
}

export const ListDomains200ResponseInnerStatusEnum = {
    PendingVerification: 'PendingVerification',
    PendingSsl: 'PendingSsl',
    Active: 'Active',
    Error: 'Error'
} as const;

export type ListDomains200ResponseInnerStatusEnum = typeof ListDomains200ResponseInnerStatusEnum[keyof typeof ListDomains200ResponseInnerStatusEnum];

/**
 * 
 * @export
 * @interface ListHookRecentLogs200ResponseInner
 */
export interface ListHookRecentLogs200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ListHookRecentLogs200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListHookRecentLogs200ResponseInner
     */
    'key': string;
    /**
     * 
     * @type {ListLogs200ResponseInnerPayload}
     * @memberof ListHookRecentLogs200ResponseInner
     */
    'payload': ListLogs200ResponseInnerPayload;
    /**
     * 
     * @type {number}
     * @memberof ListHookRecentLogs200ResponseInner
     */
    'createdAt': number;
}
/**
 * 
 * @export
 * @interface ListHooks200ResponseInner
 */
export interface ListHooks200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ListHooks200ResponseInner
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof ListHooks200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListHooks200ResponseInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ListHooks200ResponseInner
     */
    'event': ListHooks200ResponseInnerEventEnum | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListHooks200ResponseInner
     */
    'events': Array<ListHooks200ResponseInnerEventsEnum>;
    /**
     * 
     * @type {ListHooks200ResponseInnerConfig}
     * @memberof ListHooks200ResponseInner
     */
    'config': ListHooks200ResponseInnerConfig;
    /**
     * 
     * @type {string}
     * @memberof ListHooks200ResponseInner
     */
    'signingKey': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListHooks200ResponseInner
     */
    'enabled': boolean;
    /**
     * 
     * @type {number}
     * @memberof ListHooks200ResponseInner
     */
    'createdAt': number;
    /**
     * 
     * @type {ListHooks200ResponseInnerExecutionStats}
     * @memberof ListHooks200ResponseInner
     */
    'executionStats'?: ListHooks200ResponseInnerExecutionStats;
}

export const ListHooks200ResponseInnerEventEnum = {
    PostRegister: 'PostRegister',
    PostSignIn: 'PostSignIn',
    PostResetPassword: 'PostResetPassword',
    UserCreated: 'User.Created',
    UserDeleted: 'User.Deleted',
    UserDataUpdated: 'User.Data.Updated',
    UserSuspensionStatusUpdated: 'User.SuspensionStatus.Updated',
    RoleCreated: 'Role.Created',
    RoleDeleted: 'Role.Deleted',
    RoleDataUpdated: 'Role.Data.Updated',
    RoleScopesUpdated: 'Role.Scopes.Updated',
    ScopeCreated: 'Scope.Created',
    ScopeDeleted: 'Scope.Deleted',
    ScopeDataUpdated: 'Scope.Data.Updated',
    OrganizationCreated: 'Organization.Created',
    OrganizationDeleted: 'Organization.Deleted',
    OrganizationDataUpdated: 'Organization.Data.Updated',
    OrganizationMembershipUpdated: 'Organization.Membership.Updated',
    OrganizationRoleCreated: 'OrganizationRole.Created',
    OrganizationRoleDeleted: 'OrganizationRole.Deleted',
    OrganizationRoleDataUpdated: 'OrganizationRole.Data.Updated',
    OrganizationRoleScopesUpdated: 'OrganizationRole.Scopes.Updated',
    OrganizationScopeCreated: 'OrganizationScope.Created',
    OrganizationScopeDeleted: 'OrganizationScope.Deleted',
    OrganizationScopeDataUpdated: 'OrganizationScope.Data.Updated'
} as const;

export type ListHooks200ResponseInnerEventEnum = typeof ListHooks200ResponseInnerEventEnum[keyof typeof ListHooks200ResponseInnerEventEnum];
export const ListHooks200ResponseInnerEventsEnum = {
    PostRegister: 'PostRegister',
    PostSignIn: 'PostSignIn',
    PostResetPassword: 'PostResetPassword',
    UserCreated: 'User.Created',
    UserDeleted: 'User.Deleted',
    UserDataUpdated: 'User.Data.Updated',
    UserSuspensionStatusUpdated: 'User.SuspensionStatus.Updated',
    RoleCreated: 'Role.Created',
    RoleDeleted: 'Role.Deleted',
    RoleDataUpdated: 'Role.Data.Updated',
    RoleScopesUpdated: 'Role.Scopes.Updated',
    ScopeCreated: 'Scope.Created',
    ScopeDeleted: 'Scope.Deleted',
    ScopeDataUpdated: 'Scope.Data.Updated',
    OrganizationCreated: 'Organization.Created',
    OrganizationDeleted: 'Organization.Deleted',
    OrganizationDataUpdated: 'Organization.Data.Updated',
    OrganizationMembershipUpdated: 'Organization.Membership.Updated',
    OrganizationRoleCreated: 'OrganizationRole.Created',
    OrganizationRoleDeleted: 'OrganizationRole.Deleted',
    OrganizationRoleDataUpdated: 'OrganizationRole.Data.Updated',
    OrganizationRoleScopesUpdated: 'OrganizationRole.Scopes.Updated',
    OrganizationScopeCreated: 'OrganizationScope.Created',
    OrganizationScopeDeleted: 'OrganizationScope.Deleted',
    OrganizationScopeDataUpdated: 'OrganizationScope.Data.Updated'
} as const;

export type ListHooks200ResponseInnerEventsEnum = typeof ListHooks200ResponseInnerEventsEnum[keyof typeof ListHooks200ResponseInnerEventsEnum];

/**
 * 
 * @export
 * @interface ListHooks200ResponseInnerConfig
 */
export interface ListHooks200ResponseInnerConfig {
    /**
     * 
     * @type {string}
     * @memberof ListHooks200ResponseInnerConfig
     */
    'url': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ListHooks200ResponseInnerConfig
     */
    'headers'?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof ListHooks200ResponseInnerConfig
     */
    'retries'?: number;
}
/**
 * 
 * @export
 * @interface ListHooks200ResponseInnerExecutionStats
 */
export interface ListHooks200ResponseInnerExecutionStats {
    /**
     * 
     * @type {number}
     * @memberof ListHooks200ResponseInnerExecutionStats
     */
    'successCount': number;
    /**
     * 
     * @type {number}
     * @memberof ListHooks200ResponseInnerExecutionStats
     */
    'requestCount': number;
}
/**
 * @type ListJwtCustomizers200ResponseInner
 * @export
 */
export type ListJwtCustomizers200ResponseInner = ListJwtCustomizers200ResponseInnerOneOf | ListJwtCustomizers200ResponseInnerOneOf1;

/**
 * 
 * @export
 * @interface ListJwtCustomizers200ResponseInnerOneOf
 */
export interface ListJwtCustomizers200ResponseInnerOneOf {
    /**
     * 
     * @type {string}
     * @memberof ListJwtCustomizers200ResponseInnerOneOf
     */
    'key': string;
    /**
     * 
     * @type {GetJwtCustomizer200ResponseOneOf}
     * @memberof ListJwtCustomizers200ResponseInnerOneOf
     */
    'value': GetJwtCustomizer200ResponseOneOf;
}
/**
 * 
 * @export
 * @interface ListJwtCustomizers200ResponseInnerOneOf1
 */
export interface ListJwtCustomizers200ResponseInnerOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof ListJwtCustomizers200ResponseInnerOneOf1
     */
    'key': string;
    /**
     * 
     * @type {GetJwtCustomizer200ResponseOneOf1}
     * @memberof ListJwtCustomizers200ResponseInnerOneOf1
     */
    'value': GetJwtCustomizer200ResponseOneOf1;
}
/**
 * 
 * @export
 * @interface ListLogs200ResponseInner
 */
export interface ListLogs200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ListLogs200ResponseInner
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof ListLogs200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListLogs200ResponseInner
     */
    'key': string;
    /**
     * 
     * @type {ListLogs200ResponseInnerPayload}
     * @memberof ListLogs200ResponseInner
     */
    'payload': ListLogs200ResponseInnerPayload;
    /**
     * 
     * @type {number}
     * @memberof ListLogs200ResponseInner
     */
    'createdAt': number;
}
/**
 * 
 * @export
 * @interface ListLogs200ResponseInnerPayload
 */
export interface ListLogs200ResponseInnerPayload {
    /**
     * 
     * @type {string}
     * @memberof ListLogs200ResponseInnerPayload
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ListLogs200ResponseInnerPayload
     */
    'result': ListLogs200ResponseInnerPayloadResultEnum;
    /**
     * 
     * @type {ListLogs200ResponseInnerPayloadError}
     * @memberof ListLogs200ResponseInnerPayload
     */
    'error'?: ListLogs200ResponseInnerPayloadError;
    /**
     * 
     * @type {string}
     * @memberof ListLogs200ResponseInnerPayload
     */
    'ip'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListLogs200ResponseInnerPayload
     */
    'userAgent'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListLogs200ResponseInnerPayload
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListLogs200ResponseInnerPayload
     */
    'applicationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListLogs200ResponseInnerPayload
     */
    'sessionId'?: string;
}

export const ListLogs200ResponseInnerPayloadResultEnum = {
    Success: 'Success',
    Error: 'Error'
} as const;

export type ListLogs200ResponseInnerPayloadResultEnum = typeof ListLogs200ResponseInnerPayloadResultEnum[keyof typeof ListLogs200ResponseInnerPayloadResultEnum];

/**
 * @type ListLogs200ResponseInnerPayloadError
 * @export
 */
export type ListLogs200ResponseInnerPayloadError = string | { [key: string]: any; };

/**
 * 
 * @export
 * @interface ListOrganizationApplications200ResponseInner
 */
export interface ListOrganizationApplications200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationApplications200ResponseInner
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationApplications200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationApplications200ResponseInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationApplications200ResponseInner
     */
    'secret': string;
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationApplications200ResponseInner
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationApplications200ResponseInner
     */
    'type': ListOrganizationApplications200ResponseInnerTypeEnum;
    /**
     * 
     * @type {ListApplications200ResponseInnerOidcClientMetadata}
     * @memberof ListOrganizationApplications200ResponseInner
     */
    'oidcClientMetadata': ListApplications200ResponseInnerOidcClientMetadata;
    /**
     * 
     * @type {ListApplications200ResponseInnerCustomClientMetadata}
     * @memberof ListOrganizationApplications200ResponseInner
     */
    'customClientMetadata': ListApplications200ResponseInnerCustomClientMetadata;
    /**
     * 
     * @type {ListApplications200ResponseInnerProtectedAppMetadata}
     * @memberof ListOrganizationApplications200ResponseInner
     */
    'protectedAppMetadata': ListApplications200ResponseInnerProtectedAppMetadata | null;
    /**
     * 
     * @type {boolean}
     * @memberof ListOrganizationApplications200ResponseInner
     */
    'isThirdParty': boolean;
    /**
     * 
     * @type {number}
     * @memberof ListOrganizationApplications200ResponseInner
     */
    'createdAt': number;
    /**
     * 
     * @type {Array<ListApplicationOrganizations200ResponseInnerOrganizationRolesInner>}
     * @memberof ListOrganizationApplications200ResponseInner
     */
    'organizationRoles': Array<ListApplicationOrganizations200ResponseInnerOrganizationRolesInner>;
}

export const ListOrganizationApplications200ResponseInnerTypeEnum = {
    Native: 'Native',
    Spa: 'SPA',
    Traditional: 'Traditional',
    MachineToMachine: 'MachineToMachine',
    Protected: 'Protected'
} as const;

export type ListOrganizationApplications200ResponseInnerTypeEnum = typeof ListOrganizationApplications200ResponseInnerTypeEnum[keyof typeof ListOrganizationApplications200ResponseInnerTypeEnum];

/**
 * 
 * @export
 * @interface ListOrganizationJitEmailDomains200ResponseInner
 */
export interface ListOrganizationJitEmailDomains200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationJitEmailDomains200ResponseInner
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationJitEmailDomains200ResponseInner
     */
    'organizationId': string;
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationJitEmailDomains200ResponseInner
     */
    'emailDomain': string;
}
/**
 * 
 * @export
 * @interface ListOrganizationJitSsoConnectors200ResponseInner
 */
export interface ListOrganizationJitSsoConnectors200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationJitSsoConnectors200ResponseInner
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationJitSsoConnectors200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationJitSsoConnectors200ResponseInner
     */
    'providerName': string;
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationJitSsoConnectors200ResponseInner
     */
    'connectorName': string;
    /**
     * arbitrary
     * @type {object}
     * @memberof ListOrganizationJitSsoConnectors200ResponseInner
     */
    'config': object;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListOrganizationJitSsoConnectors200ResponseInner
     */
    'domains': Array<string>;
    /**
     * 
     * @type {ListOrganizationJitSsoConnectors200ResponseInnerBranding}
     * @memberof ListOrganizationJitSsoConnectors200ResponseInner
     */
    'branding': ListOrganizationJitSsoConnectors200ResponseInnerBranding;
    /**
     * 
     * @type {boolean}
     * @memberof ListOrganizationJitSsoConnectors200ResponseInner
     */
    'syncProfile': boolean;
    /**
     * 
     * @type {number}
     * @memberof ListOrganizationJitSsoConnectors200ResponseInner
     */
    'createdAt': number;
}
/**
 * 
 * @export
 * @interface ListOrganizationJitSsoConnectors200ResponseInnerBranding
 */
export interface ListOrganizationJitSsoConnectors200ResponseInnerBranding {
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationJitSsoConnectors200ResponseInnerBranding
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationJitSsoConnectors200ResponseInnerBranding
     */
    'logo'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationJitSsoConnectors200ResponseInnerBranding
     */
    'darkLogo'?: string;
}
/**
 * 
 * @export
 * @interface ListOrganizationRoleScopes200ResponseInner
 */
export interface ListOrganizationRoleScopes200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationRoleScopes200ResponseInner
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationRoleScopes200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationRoleScopes200ResponseInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationRoleScopes200ResponseInner
     */
    'description': string | null;
}
/**
 * 
 * @export
 * @interface ListOrganizationRoles200ResponseInner
 */
export interface ListOrganizationRoles200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationRoles200ResponseInner
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationRoles200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationRoles200ResponseInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationRoles200ResponseInner
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationRoles200ResponseInner
     */
    'type': ListOrganizationRoles200ResponseInnerTypeEnum;
    /**
     * 
     * @type {Array<ListApplicationOrganizations200ResponseInnerOrganizationRolesInner>}
     * @memberof ListOrganizationRoles200ResponseInner
     */
    'scopes': Array<ListApplicationOrganizations200ResponseInnerOrganizationRolesInner>;
    /**
     * 
     * @type {Array<ListOrganizationRoles200ResponseInnerResourceScopesInner>}
     * @memberof ListOrganizationRoles200ResponseInner
     */
    'resourceScopes': Array<ListOrganizationRoles200ResponseInnerResourceScopesInner>;
}

export const ListOrganizationRoles200ResponseInnerTypeEnum = {
    User: 'User',
    MachineToMachine: 'MachineToMachine'
} as const;

export type ListOrganizationRoles200ResponseInnerTypeEnum = typeof ListOrganizationRoles200ResponseInnerTypeEnum[keyof typeof ListOrganizationRoles200ResponseInnerTypeEnum];

/**
 * 
 * @export
 * @interface ListOrganizationRoles200ResponseInnerResourceScopesInner
 */
export interface ListOrganizationRoles200ResponseInnerResourceScopesInner {
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationRoles200ResponseInnerResourceScopesInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationRoles200ResponseInnerResourceScopesInner
     */
    'name': string;
    /**
     * 
     * @type {ListApplicationOrganizations200ResponseInnerOrganizationRolesInner}
     * @memberof ListOrganizationRoles200ResponseInnerResourceScopesInner
     */
    'resource': ListApplicationOrganizations200ResponseInnerOrganizationRolesInner;
}
/**
 * 
 * @export
 * @interface ListOrganizationUsers200ResponseInner
 */
export interface ListOrganizationUsers200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationUsers200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationUsers200ResponseInner
     */
    'username': string | null;
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationUsers200ResponseInner
     */
    'primaryEmail': string | null;
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationUsers200ResponseInner
     */
    'primaryPhone': string | null;
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationUsers200ResponseInner
     */
    'name': string | null;
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationUsers200ResponseInner
     */
    'avatar': string | null;
    /**
     * arbitrary
     * @type {object}
     * @memberof ListOrganizationUsers200ResponseInner
     */
    'customData': object;
    /**
     * 
     * @type {{ [key: string]: GetJwtCustomizer200ResponseOneOfContextSampleUserIdentitiesValue; }}
     * @memberof ListOrganizationUsers200ResponseInner
     */
    'identities': { [key: string]: GetJwtCustomizer200ResponseOneOfContextSampleUserIdentitiesValue; };
    /**
     * 
     * @type {number}
     * @memberof ListOrganizationUsers200ResponseInner
     */
    'lastSignInAt': number | null;
    /**
     * 
     * @type {number}
     * @memberof ListOrganizationUsers200ResponseInner
     */
    'createdAt': number;
    /**
     * 
     * @type {number}
     * @memberof ListOrganizationUsers200ResponseInner
     */
    'updatedAt': number;
    /**
     * 
     * @type {GetJwtCustomizer200ResponseOneOfContextSampleUserProfile}
     * @memberof ListOrganizationUsers200ResponseInner
     */
    'profile': GetJwtCustomizer200ResponseOneOfContextSampleUserProfile;
    /**
     * 
     * @type {string}
     * @memberof ListOrganizationUsers200ResponseInner
     */
    'applicationId': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ListOrganizationUsers200ResponseInner
     */
    'isSuspended': boolean;
    /**
     * 
     * @type {Array<ListApplicationOrganizations200ResponseInnerOrganizationRolesInner>}
     * @memberof ListOrganizationUsers200ResponseInner
     */
    'organizationRoles': Array<ListApplicationOrganizations200ResponseInnerOrganizationRolesInner>;
}
/**
 * 
 * @export
 * @interface ListOrganizations200ResponseInner
 */
export interface ListOrganizations200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ListOrganizations200ResponseInner
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof ListOrganizations200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListOrganizations200ResponseInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ListOrganizations200ResponseInner
     */
    'description': string | null;
    /**
     * arbitrary
     * @type {object}
     * @memberof ListOrganizations200ResponseInner
     */
    'customData': object;
    /**
     * 
     * @type {boolean}
     * @memberof ListOrganizations200ResponseInner
     */
    'isMfaRequired': boolean;
    /**
     * 
     * @type {number}
     * @memberof ListOrganizations200ResponseInner
     */
    'createdAt': number;
    /**
     * 
     * @type {number}
     * @memberof ListOrganizations200ResponseInner
     */
    'usersCount'?: number;
    /**
     * 
     * @type {Array<ListRoles200ResponseInnerFeaturedUsersInner>}
     * @memberof ListOrganizations200ResponseInner
     */
    'featuredUsers'?: Array<ListRoles200ResponseInnerFeaturedUsersInner>;
}
/**
 * 
 * @export
 * @interface ListResources200ResponseInner
 */
export interface ListResources200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ListResources200ResponseInner
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof ListResources200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListResources200ResponseInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ListResources200ResponseInner
     */
    'indicator': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListResources200ResponseInner
     */
    'isDefault': boolean;
    /**
     * 
     * @type {number}
     * @memberof ListResources200ResponseInner
     */
    'accessTokenTtl': number;
    /**
     * 
     * @type {Array<ListResources200ResponseInnerScopesInner>}
     * @memberof ListResources200ResponseInner
     */
    'scopes'?: Array<ListResources200ResponseInnerScopesInner>;
}
/**
 * 
 * @export
 * @interface ListResources200ResponseInnerScopesInner
 */
export interface ListResources200ResponseInnerScopesInner {
    /**
     * 
     * @type {string}
     * @memberof ListResources200ResponseInnerScopesInner
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof ListResources200ResponseInnerScopesInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListResources200ResponseInnerScopesInner
     */
    'resourceId': string;
    /**
     * 
     * @type {string}
     * @memberof ListResources200ResponseInnerScopesInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ListResources200ResponseInnerScopesInner
     */
    'description': string | null;
    /**
     * 
     * @type {number}
     * @memberof ListResources200ResponseInnerScopesInner
     */
    'createdAt': number;
}
/**
 * 
 * @export
 * @interface ListRoleScopes200ResponseInner
 */
export interface ListRoleScopes200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ListRoleScopes200ResponseInner
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof ListRoleScopes200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListRoleScopes200ResponseInner
     */
    'resourceId': string;
    /**
     * 
     * @type {string}
     * @memberof ListRoleScopes200ResponseInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ListRoleScopes200ResponseInner
     */
    'description': string | null;
    /**
     * 
     * @type {number}
     * @memberof ListRoleScopes200ResponseInner
     */
    'createdAt': number;
    /**
     * 
     * @type {GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource}
     * @memberof ListRoleScopes200ResponseInner
     */
    'resource': GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource;
}
/**
 * 
 * @export
 * @interface ListRoles200ResponseInner
 */
export interface ListRoles200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ListRoles200ResponseInner
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof ListRoles200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListRoles200ResponseInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ListRoles200ResponseInner
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ListRoles200ResponseInner
     */
    'type': ListRoles200ResponseInnerTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ListRoles200ResponseInner
     */
    'isDefault': boolean;
    /**
     * 
     * @type {number}
     * @memberof ListRoles200ResponseInner
     */
    'usersCount': number;
    /**
     * 
     * @type {Array<ListRoles200ResponseInnerFeaturedUsersInner>}
     * @memberof ListRoles200ResponseInner
     */
    'featuredUsers': Array<ListRoles200ResponseInnerFeaturedUsersInner>;
    /**
     * 
     * @type {number}
     * @memberof ListRoles200ResponseInner
     */
    'applicationsCount': number;
    /**
     * 
     * @type {Array<ListRoles200ResponseInnerFeaturedApplicationsInner>}
     * @memberof ListRoles200ResponseInner
     */
    'featuredApplications': Array<ListRoles200ResponseInnerFeaturedApplicationsInner>;
}

export const ListRoles200ResponseInnerTypeEnum = {
    User: 'User',
    MachineToMachine: 'MachineToMachine'
} as const;

export type ListRoles200ResponseInnerTypeEnum = typeof ListRoles200ResponseInnerTypeEnum[keyof typeof ListRoles200ResponseInnerTypeEnum];

/**
 * 
 * @export
 * @interface ListRoles200ResponseInnerFeaturedApplicationsInner
 */
export interface ListRoles200ResponseInnerFeaturedApplicationsInner {
    /**
     * 
     * @type {string}
     * @memberof ListRoles200ResponseInnerFeaturedApplicationsInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListRoles200ResponseInnerFeaturedApplicationsInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ListRoles200ResponseInnerFeaturedApplicationsInner
     */
    'type': ListRoles200ResponseInnerFeaturedApplicationsInnerTypeEnum;
}

export const ListRoles200ResponseInnerFeaturedApplicationsInnerTypeEnum = {
    Native: 'Native',
    Spa: 'SPA',
    Traditional: 'Traditional',
    MachineToMachine: 'MachineToMachine',
    Protected: 'Protected'
} as const;

export type ListRoles200ResponseInnerFeaturedApplicationsInnerTypeEnum = typeof ListRoles200ResponseInnerFeaturedApplicationsInnerTypeEnum[keyof typeof ListRoles200ResponseInnerFeaturedApplicationsInnerTypeEnum];

/**
 * 
 * @export
 * @interface ListRoles200ResponseInnerFeaturedUsersInner
 */
export interface ListRoles200ResponseInnerFeaturedUsersInner {
    /**
     * 
     * @type {string}
     * @memberof ListRoles200ResponseInnerFeaturedUsersInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListRoles200ResponseInnerFeaturedUsersInner
     */
    'avatar': string | null;
    /**
     * 
     * @type {string}
     * @memberof ListRoles200ResponseInnerFeaturedUsersInner
     */
    'name': string | null;
}
/**
 * 
 * @export
 * @interface ListSsoConnectorProviders200ResponseInner
 */
export interface ListSsoConnectorProviders200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ListSsoConnectorProviders200ResponseInner
     */
    'providerName': ListSsoConnectorProviders200ResponseInnerProviderNameEnum;
    /**
     * 
     * @type {string}
     * @memberof ListSsoConnectorProviders200ResponseInner
     */
    'providerType': ListSsoConnectorProviders200ResponseInnerProviderTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ListSsoConnectorProviders200ResponseInner
     */
    'logo': string;
    /**
     * 
     * @type {string}
     * @memberof ListSsoConnectorProviders200ResponseInner
     */
    'logoDark': string;
    /**
     * 
     * @type {string}
     * @memberof ListSsoConnectorProviders200ResponseInner
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ListSsoConnectorProviders200ResponseInner
     */
    'name': string;
}

export const ListSsoConnectorProviders200ResponseInnerProviderNameEnum = {
    Oidc: 'OIDC',
    Saml: 'SAML',
    AzureAd: 'AzureAD',
    GoogleWorkspace: 'GoogleWorkspace',
    Okta: 'Okta',
    AzureAdOidc: 'AzureAdOidc'
} as const;

export type ListSsoConnectorProviders200ResponseInnerProviderNameEnum = typeof ListSsoConnectorProviders200ResponseInnerProviderNameEnum[keyof typeof ListSsoConnectorProviders200ResponseInnerProviderNameEnum];
export const ListSsoConnectorProviders200ResponseInnerProviderTypeEnum = {
    Oidc: 'oidc',
    Saml: 'saml'
} as const;

export type ListSsoConnectorProviders200ResponseInnerProviderTypeEnum = typeof ListSsoConnectorProviders200ResponseInnerProviderTypeEnum[keyof typeof ListSsoConnectorProviders200ResponseInnerProviderTypeEnum];

/**
 * 
 * @export
 * @interface ListSsoConnectors200ResponseInner
 */
export interface ListSsoConnectors200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ListSsoConnectors200ResponseInner
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof ListSsoConnectors200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListSsoConnectors200ResponseInner
     */
    'providerName': ListSsoConnectors200ResponseInnerProviderNameEnum;
    /**
     * 
     * @type {string}
     * @memberof ListSsoConnectors200ResponseInner
     */
    'connectorName': string;
    /**
     * arbitrary
     * @type {object}
     * @memberof ListSsoConnectors200ResponseInner
     */
    'config': object;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListSsoConnectors200ResponseInner
     */
    'domains': Array<string>;
    /**
     * 
     * @type {ListOrganizationJitSsoConnectors200ResponseInnerBranding}
     * @memberof ListSsoConnectors200ResponseInner
     */
    'branding': ListOrganizationJitSsoConnectors200ResponseInnerBranding;
    /**
     * 
     * @type {boolean}
     * @memberof ListSsoConnectors200ResponseInner
     */
    'syncProfile': boolean;
    /**
     * 
     * @type {number}
     * @memberof ListSsoConnectors200ResponseInner
     */
    'createdAt': number;
    /**
     * 
     * @type {string}
     * @memberof ListSsoConnectors200ResponseInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ListSsoConnectors200ResponseInner
     */
    'providerType': ListSsoConnectors200ResponseInnerProviderTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ListSsoConnectors200ResponseInner
     */
    'providerLogo': string;
    /**
     * 
     * @type {string}
     * @memberof ListSsoConnectors200ResponseInner
     */
    'providerLogoDark': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ListSsoConnectors200ResponseInner
     */
    'providerConfig'?: { [key: string]: any; };
}

export const ListSsoConnectors200ResponseInnerProviderNameEnum = {
    Oidc: 'OIDC',
    Saml: 'SAML',
    AzureAd: 'AzureAD',
    GoogleWorkspace: 'GoogleWorkspace',
    Okta: 'Okta',
    AzureAdOidc: 'AzureAdOidc'
} as const;

export type ListSsoConnectors200ResponseInnerProviderNameEnum = typeof ListSsoConnectors200ResponseInnerProviderNameEnum[keyof typeof ListSsoConnectors200ResponseInnerProviderNameEnum];
export const ListSsoConnectors200ResponseInnerProviderTypeEnum = {
    Oidc: 'oidc',
    Saml: 'saml'
} as const;

export type ListSsoConnectors200ResponseInnerProviderTypeEnum = typeof ListSsoConnectors200ResponseInnerProviderTypeEnum[keyof typeof ListSsoConnectors200ResponseInnerProviderTypeEnum];

/**
 * 
 * @export
 * @interface ListUserMfaVerifications200ResponseInner
 */
export interface ListUserMfaVerifications200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ListUserMfaVerifications200ResponseInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListUserMfaVerifications200ResponseInner
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ListUserMfaVerifications200ResponseInner
     */
    'type': ListUserMfaVerifications200ResponseInnerTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ListUserMfaVerifications200ResponseInner
     */
    'agent'?: string;
    /**
     * 
     * @type {number}
     * @memberof ListUserMfaVerifications200ResponseInner
     */
    'remainCodes'?: number;
}

export const ListUserMfaVerifications200ResponseInnerTypeEnum = {
    Totp: 'Totp',
    WebAuthn: 'WebAuthn',
    BackupCode: 'BackupCode'
} as const;

export type ListUserMfaVerifications200ResponseInnerTypeEnum = typeof ListUserMfaVerifications200ResponseInnerTypeEnum[keyof typeof ListUserMfaVerifications200ResponseInnerTypeEnum];

/**
 * 
 * @export
 * @interface ReplaceApplicationRolesRequest
 */
export interface ReplaceApplicationRolesRequest {
    /**
     * An array of API resource role IDs to update for the application.
     * @type {Array<string>}
     * @memberof ReplaceApplicationRolesRequest
     */
    'roleIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ReplaceApplicationSignInExperienceRequest
 */
export interface ReplaceApplicationSignInExperienceRequest {
    /**
     * 
     * @type {ApiInteractionConsentGet200ResponseApplicationBranding}
     * @memberof ReplaceApplicationSignInExperienceRequest
     */
    'branding'?: ApiInteractionConsentGet200ResponseApplicationBranding;
    /**
     * 
     * @type {string}
     * @memberof ReplaceApplicationSignInExperienceRequest
     */
    'displayName'?: string | null;
    /**
     * 
     * @type {ReplaceApplicationSignInExperienceRequestTermsOfUseUrl}
     * @memberof ReplaceApplicationSignInExperienceRequest
     */
    'termsOfUseUrl': ReplaceApplicationSignInExperienceRequestTermsOfUseUrl;
    /**
     * 
     * @type {ReplaceApplicationSignInExperienceRequestTermsOfUseUrl}
     * @memberof ReplaceApplicationSignInExperienceRequest
     */
    'privacyPolicyUrl': ReplaceApplicationSignInExperienceRequestTermsOfUseUrl;
}
/**
 * @type ReplaceApplicationSignInExperienceRequestTermsOfUseUrl
 * @export
 */
export type ReplaceApplicationSignInExperienceRequestTermsOfUseUrl = string;

/**
 * 
 * @export
 * @interface ReplaceApplicationUserConsentOrganizationsRequest
 */
export interface ReplaceApplicationUserConsentOrganizationsRequest {
    /**
     * A list of organization ids to be granted. <br/> All the existing organizations\' access will be revoked if not in the list. <br/> If the list is empty, all the organizations\' access will be revoked.
     * @type {Array<string>}
     * @memberof ReplaceApplicationUserConsentOrganizationsRequest
     */
    'organizationIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ReplaceOrganizationApplicationRolesRequest
 */
export interface ReplaceOrganizationApplicationRolesRequest {
    /**
     * An array of role IDs to replace existing roles.
     * @type {Array<string>}
     * @memberof ReplaceOrganizationApplicationRolesRequest
     */
    'organizationRoleIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ReplaceOrganizationApplicationsRequest
 */
export interface ReplaceOrganizationApplicationsRequest {
    /**
     * An array of application IDs to replace existing applications.
     * @type {Array<string>}
     * @memberof ReplaceOrganizationApplicationsRequest
     */
    'applicationIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ReplaceOrganizationInvitationStatusRequest
 */
export interface ReplaceOrganizationInvitationStatusRequest {
    /**
     * The ID of the user who accepted the organization invitation. Required if the status is \"Accepted\".
     * @type {string}
     * @memberof ReplaceOrganizationInvitationStatusRequest
     */
    'acceptedUserId'?: string | null;
    /**
     * The status of the organization invitation.
     * @type {string}
     * @memberof ReplaceOrganizationInvitationStatusRequest
     */
    'status': ReplaceOrganizationInvitationStatusRequestStatusEnum;
}

export const ReplaceOrganizationInvitationStatusRequestStatusEnum = {
    Accepted: 'Accepted',
    Revoked: 'Revoked'
} as const;

export type ReplaceOrganizationInvitationStatusRequestStatusEnum = typeof ReplaceOrganizationInvitationStatusRequestStatusEnum[keyof typeof ReplaceOrganizationInvitationStatusRequestStatusEnum];

/**
 * 
 * @export
 * @interface ReplaceOrganizationJitEmailDomainsRequest
 */
export interface ReplaceOrganizationJitEmailDomainsRequest {
    /**
     * An array of email domains to replace existing email domains.
     * @type {Array<string>}
     * @memberof ReplaceOrganizationJitEmailDomainsRequest
     */
    'emailDomains': Array<string>;
}
/**
 * 
 * @export
 * @interface ReplaceOrganizationJitRolesRequest
 */
export interface ReplaceOrganizationJitRolesRequest {
    /**
     * An array of organization role IDs to replace existing organization roles.
     * @type {Array<string>}
     * @memberof ReplaceOrganizationJitRolesRequest
     */
    'organizationRoleIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ReplaceOrganizationJitSsoConnectorsRequest
 */
export interface ReplaceOrganizationJitSsoConnectorsRequest {
    /**
     * An array of SSO connector IDs to replace existing SSO connectors.
     * @type {Array<string>}
     * @memberof ReplaceOrganizationJitSsoConnectorsRequest
     */
    'ssoConnectorIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ReplaceOrganizationRoleResourceScopesRequest
 */
export interface ReplaceOrganizationRoleResourceScopesRequest {
    /**
     * An array of resource scope IDs to replace existing scopes.
     * @type {Array<string>}
     * @memberof ReplaceOrganizationRoleResourceScopesRequest
     */
    'scopeIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ReplaceOrganizationRoleScopesRequest
 */
export interface ReplaceOrganizationRoleScopesRequest {
    /**
     * An array of organization scope IDs to replace existing scopes.
     * @type {Array<string>}
     * @memberof ReplaceOrganizationRoleScopesRequest
     */
    'organizationScopeIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ReplaceOrganizationUserRolesRequest
 */
export interface ReplaceOrganizationUserRolesRequest {
    /**
     * An array of organization role IDs to update for the user.
     * @type {Array<string>}
     * @memberof ReplaceOrganizationUserRolesRequest
     */
    'organizationRoleIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ReplaceOrganizationUsersRequest
 */
export interface ReplaceOrganizationUsersRequest {
    /**
     * An array of user IDs to replace existing users.
     * @type {Array<string>}
     * @memberof ReplaceOrganizationUsersRequest
     */
    'userIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ReplaceUserIdentityRequest
 */
export interface ReplaceUserIdentityRequest {
    /**
     * The user\'s social identity ID.
     * @type {string}
     * @memberof ReplaceUserIdentityRequest
     */
    'userId': string;
    /**
     * The user\'s social identity details.
     * @type {object}
     * @memberof ReplaceUserIdentityRequest
     */
    'details'?: object;
}
/**
 * 
 * @export
 * @interface RotateOidcKeysRequest
 */
export interface RotateOidcKeysRequest {
    /**
     * The signing key algorithm the new generated private key is using.  Only applicable when `keyType` is `private-keys`.
     * @type {string}
     * @memberof RotateOidcKeysRequest
     */
    'signingKeyAlgorithm'?: RotateOidcKeysRequestSigningKeyAlgorithmEnum;
}

export const RotateOidcKeysRequestSigningKeyAlgorithmEnum = {
    Rsa: 'RSA',
    Ec: 'EC'
} as const;

export type RotateOidcKeysRequestSigningKeyAlgorithmEnum = typeof RotateOidcKeysRequestSigningKeyAlgorithmEnum[keyof typeof RotateOidcKeysRequestSigningKeyAlgorithmEnum];

/**
 * @type TestJwtCustomizerRequest
 * @export
 */
export type TestJwtCustomizerRequest = TestJwtCustomizerRequestOneOf | TestJwtCustomizerRequestOneOf1;

/**
 * 
 * @export
 * @interface TestJwtCustomizerRequestOneOf
 */
export interface TestJwtCustomizerRequestOneOf {
    /**
     * 
     * @type {string}
     * @memberof TestJwtCustomizerRequestOneOf
     */
    'tokenType': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TestJwtCustomizerRequestOneOf
     */
    'environmentVariables'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof TestJwtCustomizerRequestOneOf
     */
    'script': string;
    /**
     * 
     * @type {GetJwtCustomizer200ResponseOneOfTokenSample}
     * @memberof TestJwtCustomizerRequestOneOf
     */
    'token': GetJwtCustomizer200ResponseOneOfTokenSample;
    /**
     * 
     * @type {GetJwtCustomizer200ResponseOneOfContextSample}
     * @memberof TestJwtCustomizerRequestOneOf
     */
    'context': GetJwtCustomizer200ResponseOneOfContextSample;
}
/**
 * 
 * @export
 * @interface TestJwtCustomizerRequestOneOf1
 */
export interface TestJwtCustomizerRequestOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof TestJwtCustomizerRequestOneOf1
     */
    'tokenType': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TestJwtCustomizerRequestOneOf1
     */
    'environmentVariables'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof TestJwtCustomizerRequestOneOf1
     */
    'script': string;
    /**
     * 
     * @type {GetJwtCustomizer200ResponseOneOf1TokenSample}
     * @memberof TestJwtCustomizerRequestOneOf1
     */
    'token': GetJwtCustomizer200ResponseOneOf1TokenSample;
}
/**
 * 
 * @export
 * @interface TestJwtCustomizerRequestPayload
 */
export interface TestJwtCustomizerRequestPayload {
    /**
     * The code snippet of the JWT customizer.
     * @type {any}
     * @memberof TestJwtCustomizerRequestPayload
     */
    'script'?: any;
    /**
     * The environment variables for the JWT customizer.
     * @type {any}
     * @memberof TestJwtCustomizerRequestPayload
     */
    'environmentVariables'?: any;
    /**
     * The sample context for the JWT customizer script testing purpose.
     * @type {any}
     * @memberof TestJwtCustomizerRequestPayload
     */
    'contextSample'?: any;
    /**
     * The sample token payload for the JWT customizer script testing purpose.
     * @type {any}
     * @memberof TestJwtCustomizerRequestPayload
     */
    'tokenSample'?: any;
}
/**
 * @type Translation
 * @export
 */
export type Translation = string;

/**
 * 
 * @export
 * @interface TranslationObject
 */
export interface TranslationObject {
    /**
     * 
     * @type {Translation}
     * @memberof TranslationObject
     */
    '[translationKey]'?: Translation;
}
/**
 * 
 * @export
 * @interface UpdateAdminConsoleConfigRequest
 */
export interface UpdateAdminConsoleConfigRequest {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateAdminConsoleConfigRequest
     */
    'signInExperienceCustomized'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateAdminConsoleConfigRequest
     */
    'organizationCreated'?: boolean;
    /**
     * 
     * @type {GetAdminConsoleConfig200ResponseDevelopmentTenantMigrationNotification}
     * @memberof UpdateAdminConsoleConfigRequest
     */
    'developmentTenantMigrationNotification'?: GetAdminConsoleConfig200ResponseDevelopmentTenantMigrationNotification;
    /**
     * 
     * @type {GetAdminConsoleConfig200ResponseCheckedChargeNotification}
     * @memberof UpdateAdminConsoleConfigRequest
     */
    'checkedChargeNotification'?: GetAdminConsoleConfig200ResponseCheckedChargeNotification;
}
/**
 * 
 * @export
 * @interface UpdateApplicationRequest
 */
export interface UpdateApplicationRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {UpdateApplicationRequestOidcClientMetadata}
     * @memberof UpdateApplicationRequest
     */
    'oidcClientMetadata'?: UpdateApplicationRequestOidcClientMetadata;
    /**
     * 
     * @type {ListApplications200ResponseInnerCustomClientMetadata}
     * @memberof UpdateApplicationRequest
     */
    'customClientMetadata'?: ListApplications200ResponseInnerCustomClientMetadata;
    /**
     * 
     * @type {UpdateApplicationRequestProtectedAppMetadata}
     * @memberof UpdateApplicationRequest
     */
    'protectedAppMetadata'?: UpdateApplicationRequestProtectedAppMetadata;
    /**
     * Whether the application has admin access. User can enable the admin access for Machine-to-Machine apps.
     * @type {boolean}
     * @memberof UpdateApplicationRequest
     */
    'isAdmin'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateApplicationRequestOidcClientMetadata
 */
export interface UpdateApplicationRequestOidcClientMetadata {
    /**
     * 
     * @type {Array<ListApplications200ResponseInnerOidcClientMetadataRedirectUrisInner>}
     * @memberof UpdateApplicationRequestOidcClientMetadata
     */
    'redirectUris'?: Array<ListApplications200ResponseInnerOidcClientMetadataRedirectUrisInner>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateApplicationRequestOidcClientMetadata
     */
    'postLogoutRedirectUris'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationRequestOidcClientMetadata
     */
    'backchannelLogoutUri'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateApplicationRequestOidcClientMetadata
     */
    'backchannelLogoutSessionRequired'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationRequestOidcClientMetadata
     */
    'logoUri'?: string;
}
/**
 * 
 * @export
 * @interface UpdateApplicationRequestProtectedAppMetadata
 */
export interface UpdateApplicationRequestProtectedAppMetadata {
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationRequestProtectedAppMetadata
     */
    'origin'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateApplicationRequestProtectedAppMetadata
     */
    'sessionDuration'?: number;
    /**
     * 
     * @type {Array<ListApplications200ResponseInnerProtectedAppMetadataPageRulesInner>}
     * @memberof UpdateApplicationRequestProtectedAppMetadata
     */
    'pageRules'?: Array<ListApplications200ResponseInnerProtectedAppMetadataPageRulesInner>;
}
/**
 * 
 * @export
 * @interface UpdateConnectorRequest
 */
export interface UpdateConnectorRequest {
    /**
     * The connector config object that will be passed to the connector. The config object should be compatible with the connector factory.
     * @type {object}
     * @memberof UpdateConnectorRequest
     */
    'config'?: object;
    /**
     * 
     * @type {UpdateConnectorRequestMetadata}
     * @memberof UpdateConnectorRequest
     */
    'metadata'?: UpdateConnectorRequestMetadata;
    /**
     * Whether to sync user profile from the identity provider to Logto at each sign-in. If `false`, the user profile will only be synced when the user is created.
     * @type {boolean}
     * @memberof UpdateConnectorRequest
     */
    'syncProfile'?: boolean;
}
/**
 * Custom connector metadata, will be used to overwrite the default connector metadata.
 * @export
 * @interface UpdateConnectorRequestMetadata
 */
export interface UpdateConnectorRequestMetadata {
    /**
     * 
     * @type {string}
     * @memberof UpdateConnectorRequestMetadata
     */
    'target'?: string;
    /**
     * Validator function
     * @type {object}
     * @memberof UpdateConnectorRequestMetadata
     */
    'name'?: object;
    /**
     * 
     * @type {string}
     * @memberof UpdateConnectorRequestMetadata
     */
    'logo'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateConnectorRequestMetadata
     */
    'logoDark'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateHook200Response
 */
export interface UpdateHook200Response {
    /**
     * 
     * @type {string}
     * @memberof UpdateHook200Response
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateHook200Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateHook200Response
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateHook200Response
     */
    'event': UpdateHook200ResponseEventEnum | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateHook200Response
     */
    'events': Array<UpdateHook200ResponseEventsEnum>;
    /**
     * 
     * @type {ListHooks200ResponseInnerConfig}
     * @memberof UpdateHook200Response
     */
    'config': ListHooks200ResponseInnerConfig;
    /**
     * 
     * @type {string}
     * @memberof UpdateHook200Response
     */
    'signingKey': string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateHook200Response
     */
    'enabled': boolean;
    /**
     * 
     * @type {number}
     * @memberof UpdateHook200Response
     */
    'createdAt': number;
}

export const UpdateHook200ResponseEventEnum = {
    PostRegister: 'PostRegister',
    PostSignIn: 'PostSignIn',
    PostResetPassword: 'PostResetPassword',
    UserCreated: 'User.Created',
    UserDeleted: 'User.Deleted',
    UserDataUpdated: 'User.Data.Updated',
    UserSuspensionStatusUpdated: 'User.SuspensionStatus.Updated',
    RoleCreated: 'Role.Created',
    RoleDeleted: 'Role.Deleted',
    RoleDataUpdated: 'Role.Data.Updated',
    RoleScopesUpdated: 'Role.Scopes.Updated',
    ScopeCreated: 'Scope.Created',
    ScopeDeleted: 'Scope.Deleted',
    ScopeDataUpdated: 'Scope.Data.Updated',
    OrganizationCreated: 'Organization.Created',
    OrganizationDeleted: 'Organization.Deleted',
    OrganizationDataUpdated: 'Organization.Data.Updated',
    OrganizationMembershipUpdated: 'Organization.Membership.Updated',
    OrganizationRoleCreated: 'OrganizationRole.Created',
    OrganizationRoleDeleted: 'OrganizationRole.Deleted',
    OrganizationRoleDataUpdated: 'OrganizationRole.Data.Updated',
    OrganizationRoleScopesUpdated: 'OrganizationRole.Scopes.Updated',
    OrganizationScopeCreated: 'OrganizationScope.Created',
    OrganizationScopeDeleted: 'OrganizationScope.Deleted',
    OrganizationScopeDataUpdated: 'OrganizationScope.Data.Updated'
} as const;

export type UpdateHook200ResponseEventEnum = typeof UpdateHook200ResponseEventEnum[keyof typeof UpdateHook200ResponseEventEnum];
export const UpdateHook200ResponseEventsEnum = {
    PostRegister: 'PostRegister',
    PostSignIn: 'PostSignIn',
    PostResetPassword: 'PostResetPassword',
    UserCreated: 'User.Created',
    UserDeleted: 'User.Deleted',
    UserDataUpdated: 'User.Data.Updated',
    UserSuspensionStatusUpdated: 'User.SuspensionStatus.Updated',
    RoleCreated: 'Role.Created',
    RoleDeleted: 'Role.Deleted',
    RoleDataUpdated: 'Role.Data.Updated',
    RoleScopesUpdated: 'Role.Scopes.Updated',
    ScopeCreated: 'Scope.Created',
    ScopeDeleted: 'Scope.Deleted',
    ScopeDataUpdated: 'Scope.Data.Updated',
    OrganizationCreated: 'Organization.Created',
    OrganizationDeleted: 'Organization.Deleted',
    OrganizationDataUpdated: 'Organization.Data.Updated',
    OrganizationMembershipUpdated: 'Organization.Membership.Updated',
    OrganizationRoleCreated: 'OrganizationRole.Created',
    OrganizationRoleDeleted: 'OrganizationRole.Deleted',
    OrganizationRoleDataUpdated: 'OrganizationRole.Data.Updated',
    OrganizationRoleScopesUpdated: 'OrganizationRole.Scopes.Updated',
    OrganizationScopeCreated: 'OrganizationScope.Created',
    OrganizationScopeDeleted: 'OrganizationScope.Deleted',
    OrganizationScopeDataUpdated: 'OrganizationScope.Data.Updated'
} as const;

export type UpdateHook200ResponseEventsEnum = typeof UpdateHook200ResponseEventsEnum[keyof typeof UpdateHook200ResponseEventsEnum];

/**
 * 
 * @export
 * @interface UpdateHookRequest
 */
export interface UpdateHookRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateHookRequest
     */
    'tenantId'?: string;
    /**
     * The updated name of the hook.
     * @type {string}
     * @memberof UpdateHookRequest
     */
    'name'?: string;
    /**
     * Use `events` instead.
     * @type {string}
     * @memberof UpdateHookRequest
     * @deprecated
     */
    'event'?: UpdateHookRequestEventEnum | null;
    /**
     * An array of updated hook events.
     * @type {Array<string>}
     * @memberof UpdateHookRequest
     */
    'events'?: Array<UpdateHookRequestEventsEnum>;
    /**
     * 
     * @type {CreateHookRequestConfig}
     * @memberof UpdateHookRequest
     */
    'config'?: CreateHookRequestConfig;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateHookRequest
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UpdateHookRequest
     */
    'createdAt'?: number;
}

export const UpdateHookRequestEventEnum = {
    PostRegister: 'PostRegister',
    PostSignIn: 'PostSignIn',
    PostResetPassword: 'PostResetPassword',
    UserCreated: 'User.Created',
    UserDeleted: 'User.Deleted',
    UserDataUpdated: 'User.Data.Updated',
    UserSuspensionStatusUpdated: 'User.SuspensionStatus.Updated',
    RoleCreated: 'Role.Created',
    RoleDeleted: 'Role.Deleted',
    RoleDataUpdated: 'Role.Data.Updated',
    RoleScopesUpdated: 'Role.Scopes.Updated',
    ScopeCreated: 'Scope.Created',
    ScopeDeleted: 'Scope.Deleted',
    ScopeDataUpdated: 'Scope.Data.Updated',
    OrganizationCreated: 'Organization.Created',
    OrganizationDeleted: 'Organization.Deleted',
    OrganizationDataUpdated: 'Organization.Data.Updated',
    OrganizationMembershipUpdated: 'Organization.Membership.Updated',
    OrganizationRoleCreated: 'OrganizationRole.Created',
    OrganizationRoleDeleted: 'OrganizationRole.Deleted',
    OrganizationRoleDataUpdated: 'OrganizationRole.Data.Updated',
    OrganizationRoleScopesUpdated: 'OrganizationRole.Scopes.Updated',
    OrganizationScopeCreated: 'OrganizationScope.Created',
    OrganizationScopeDeleted: 'OrganizationScope.Deleted',
    OrganizationScopeDataUpdated: 'OrganizationScope.Data.Updated'
} as const;

export type UpdateHookRequestEventEnum = typeof UpdateHookRequestEventEnum[keyof typeof UpdateHookRequestEventEnum];
export const UpdateHookRequestEventsEnum = {
    PostRegister: 'PostRegister',
    PostSignIn: 'PostSignIn',
    PostResetPassword: 'PostResetPassword',
    UserCreated: 'User.Created',
    UserDeleted: 'User.Deleted',
    UserDataUpdated: 'User.Data.Updated',
    UserSuspensionStatusUpdated: 'User.SuspensionStatus.Updated',
    RoleCreated: 'Role.Created',
    RoleDeleted: 'Role.Deleted',
    RoleDataUpdated: 'Role.Data.Updated',
    RoleScopesUpdated: 'Role.Scopes.Updated',
    ScopeCreated: 'Scope.Created',
    ScopeDeleted: 'Scope.Deleted',
    ScopeDataUpdated: 'Scope.Data.Updated',
    OrganizationCreated: 'Organization.Created',
    OrganizationDeleted: 'Organization.Deleted',
    OrganizationDataUpdated: 'Organization.Data.Updated',
    OrganizationMembershipUpdated: 'Organization.Membership.Updated',
    OrganizationRoleCreated: 'OrganizationRole.Created',
    OrganizationRoleDeleted: 'OrganizationRole.Deleted',
    OrganizationRoleDataUpdated: 'OrganizationRole.Data.Updated',
    OrganizationRoleScopesUpdated: 'OrganizationRole.Scopes.Updated',
    OrganizationScopeCreated: 'OrganizationScope.Created',
    OrganizationScopeDeleted: 'OrganizationScope.Deleted',
    OrganizationScopeDataUpdated: 'OrganizationScope.Data.Updated'
} as const;

export type UpdateHookRequestEventsEnum = typeof UpdateHookRequestEventsEnum[keyof typeof UpdateHookRequestEventsEnum];

/**
 * 
 * @export
 * @interface UpdateOrganizationRequest
 */
export interface UpdateOrganizationRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationRequest
     */
    'tenantId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationRequest
     */
    'id'?: string;
    /**
     * The updated name of the organization.
     * @type {string}
     * @memberof UpdateOrganizationRequest
     */
    'name'?: string;
    /**
     * The updated description of the organization.
     * @type {string}
     * @memberof UpdateOrganizationRequest
     */
    'description'?: string | null;
    /**
     * arbitrary
     * @type {object}
     * @memberof UpdateOrganizationRequest
     */
    'customData'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateOrganizationRequest
     */
    'isMfaRequired'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UpdateOrganizationRequest
     */
    'createdAt'?: number;
}
/**
 * 
 * @export
 * @interface UpdateOrganizationRoleRequest
 */
export interface UpdateOrganizationRoleRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationRoleRequest
     */
    'tenantId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationRoleRequest
     */
    'id'?: string;
    /**
     * The updated name of the organization role. It must be unique within the organization template.
     * @type {string}
     * @memberof UpdateOrganizationRoleRequest
     */
    'name'?: string;
    /**
     * The updated description of the organization role.
     * @type {string}
     * @memberof UpdateOrganizationRoleRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationRoleRequest
     */
    'type'?: UpdateOrganizationRoleRequestTypeEnum;
}

export const UpdateOrganizationRoleRequestTypeEnum = {
    User: 'User',
    MachineToMachine: 'MachineToMachine'
} as const;

export type UpdateOrganizationRoleRequestTypeEnum = typeof UpdateOrganizationRoleRequestTypeEnum[keyof typeof UpdateOrganizationRoleRequestTypeEnum];

/**
 * 
 * @export
 * @interface UpdateOrganizationScopeRequest
 */
export interface UpdateOrganizationScopeRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationScopeRequest
     */
    'tenantId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationScopeRequest
     */
    'id'?: string;
    /**
     * The updated name of the organization scope. It must be unique within the organization template.
     * @type {string}
     * @memberof UpdateOrganizationScopeRequest
     */
    'name'?: string;
    /**
     * The updated description of the organization scope.
     * @type {string}
     * @memberof UpdateOrganizationScopeRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateResourceIsDefaultRequest
 */
export interface UpdateResourceIsDefaultRequest {
    /**
     * The updated value of the `isDefault` property.
     * @type {boolean}
     * @memberof UpdateResourceIsDefaultRequest
     */
    'isDefault': boolean;
}
/**
 * 
 * @export
 * @interface UpdateResourceRequest
 */
export interface UpdateResourceRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateResourceRequest
     */
    'tenantId'?: string;
    /**
     * The updated name of the resource.
     * @type {string}
     * @memberof UpdateResourceRequest
     */
    'name'?: string;
    /**
     * The updated access token TTL in seconds.
     * @type {number}
     * @memberof UpdateResourceRequest
     */
    'accessTokenTtl'?: number;
}
/**
 * 
 * @export
 * @interface UpdateResourceScopeRequest
 */
export interface UpdateResourceScopeRequest {
    /**
     * The updated name of the scope. It should be unique for the resource.
     * @type {string}
     * @memberof UpdateResourceScopeRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateResourceScopeRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateRoleRequest
 */
export interface UpdateRoleRequest {
    /**
     * The name of the role. It should be unique within the tenant.
     * @type {string}
     * @memberof UpdateRoleRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoleRequest
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateRoleRequest
     */
    'isDefault'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateSignInExp200Response
 */
export interface UpdateSignInExp200Response {
    /**
     * 
     * @type {string}
     * @memberof UpdateSignInExp200Response
     */
    'tenantId': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSignInExp200Response
     */
    'id': string;
    /**
     * 
     * @type {UpdateSignInExp200ResponseColor}
     * @memberof UpdateSignInExp200Response
     */
    'color': UpdateSignInExp200ResponseColor;
    /**
     * 
     * @type {ApiInteractionConsentGet200ResponseApplicationBranding}
     * @memberof UpdateSignInExp200Response
     */
    'branding': ApiInteractionConsentGet200ResponseApplicationBranding;
    /**
     * 
     * @type {UpdateSignInExp200ResponseLanguageInfo}
     * @memberof UpdateSignInExp200Response
     */
    'languageInfo': UpdateSignInExp200ResponseLanguageInfo;
    /**
     * 
     * @type {string}
     * @memberof UpdateSignInExp200Response
     */
    'termsOfUseUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSignInExp200Response
     */
    'privacyPolicyUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSignInExp200Response
     */
    'agreeToTermsPolicy': UpdateSignInExp200ResponseAgreeToTermsPolicyEnum;
    /**
     * 
     * @type {UpdateSignInExp200ResponseSignIn}
     * @memberof UpdateSignInExp200Response
     */
    'signIn': UpdateSignInExp200ResponseSignIn;
    /**
     * 
     * @type {UpdateSignInExp200ResponseSignUp}
     * @memberof UpdateSignInExp200Response
     */
    'signUp': UpdateSignInExp200ResponseSignUp;
    /**
     * 
     * @type {GetSignInExp200ResponseSocialSignIn}
     * @memberof UpdateSignInExp200Response
     */
    'socialSignIn': GetSignInExp200ResponseSocialSignIn;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateSignInExp200Response
     */
    'socialSignInConnectorTargets': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateSignInExp200Response
     */
    'signInMode': UpdateSignInExp200ResponseSignInModeEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateSignInExp200Response
     */
    'customCss': string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UpdateSignInExp200Response
     */
    'customContent': { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof UpdateSignInExp200Response
     */
    'customUiAssetId': string | null;
    /**
     * 
     * @type {UpdateSignInExp200ResponsePasswordPolicy}
     * @memberof UpdateSignInExp200Response
     */
    'passwordPolicy': UpdateSignInExp200ResponsePasswordPolicy;
    /**
     * 
     * @type {UpdateSignInExp200ResponseMfa}
     * @memberof UpdateSignInExp200Response
     */
    'mfa': UpdateSignInExp200ResponseMfa;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateSignInExp200Response
     */
    'singleSignOnEnabled': boolean;
}

export const UpdateSignInExp200ResponseAgreeToTermsPolicyEnum = {
    Automatic: 'Automatic',
    ManualRegistrationOnly: 'ManualRegistrationOnly',
    Manual: 'Manual'
} as const;

export type UpdateSignInExp200ResponseAgreeToTermsPolicyEnum = typeof UpdateSignInExp200ResponseAgreeToTermsPolicyEnum[keyof typeof UpdateSignInExp200ResponseAgreeToTermsPolicyEnum];
export const UpdateSignInExp200ResponseSignInModeEnum = {
    SignIn: 'SignIn',
    Register: 'Register',
    SignInAndRegister: 'SignInAndRegister'
} as const;

export type UpdateSignInExp200ResponseSignInModeEnum = typeof UpdateSignInExp200ResponseSignInModeEnum[keyof typeof UpdateSignInExp200ResponseSignInModeEnum];

/**
 * 
 * @export
 * @interface UpdateSignInExp200ResponseColor
 */
export interface UpdateSignInExp200ResponseColor {
    /**
     * 
     * @type {string}
     * @memberof UpdateSignInExp200ResponseColor
     */
    'primaryColor': string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateSignInExp200ResponseColor
     */
    'isDarkModeEnabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateSignInExp200ResponseColor
     */
    'darkPrimaryColor': string;
}
/**
 * 
 * @export
 * @interface UpdateSignInExp200ResponseLanguageInfo
 */
export interface UpdateSignInExp200ResponseLanguageInfo {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateSignInExp200ResponseLanguageInfo
     */
    'autoDetect': boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateSignInExp200ResponseLanguageInfo
     */
    'fallbackLanguage': UpdateSignInExp200ResponseLanguageInfoFallbackLanguageEnum;
}

export const UpdateSignInExp200ResponseLanguageInfoFallbackLanguageEnum = {
    AfZa: 'af-ZA',
    AmEt: 'am-ET',
    ArAr: 'ar-AR',
    AsIn: 'as-IN',
    AzAz: 'az-AZ',
    BeBy: 'be-BY',
    BgBg: 'bg-BG',
    BnIn: 'bn-IN',
    BrFr: 'br-FR',
    BsBa: 'bs-BA',
    CaEs: 'ca-ES',
    CbIq: 'cb-IQ',
    CoFr: 'co-FR',
    CsCz: 'cs-CZ',
    CxPh: 'cx-PH',
    CyGb: 'cy-GB',
    DaDk: 'da-DK',
    De: 'de',
    DeDe: 'de-DE',
    ElGr: 'el-GR',
    En: 'en',
    EnGb: 'en-GB',
    EnUs: 'en-US',
    EoEo: 'eo-EO',
    Es: 'es',
    EsEs: 'es-ES',
    Es419: 'es-419',
    EtEe: 'et-EE',
    EuEs: 'eu-ES',
    FaIr: 'fa-IR',
    FfNg: 'ff-NG',
    FiFi: 'fi-FI',
    FoFo: 'fo-FO',
    Fr: 'fr',
    FrCa: 'fr-CA',
    FrFr: 'fr-FR',
    FyNl: 'fy-NL',
    GaIe: 'ga-IE',
    GlEs: 'gl-ES',
    GnPy: 'gn-PY',
    GuIn: 'gu-IN',
    HaNg: 'ha-NG',
    HeIl: 'he-IL',
    HiIn: 'hi-IN',
    HrHr: 'hr-HR',
    HtHt: 'ht-HT',
    HuHu: 'hu-HU',
    HyAm: 'hy-AM',
    IdId: 'id-ID',
    IkUs: 'ik-US',
    IsIs: 'is-IS',
    It: 'it',
    ItIt: 'it-IT',
    IuCa: 'iu-CA',
    Ja: 'ja',
    JaJp: 'ja-JP',
    JaKs: 'ja-KS',
    JvId: 'jv-ID',
    KaGe: 'ka-GE',
    KkKz: 'kk-KZ',
    KmKh: 'km-KH',
    KnIn: 'kn-IN',
    Ko: 'ko',
    KoKr: 'ko-KR',
    KuTr: 'ku-TR',
    KyKg: 'ky-KG',
    LoLa: 'lo-LA',
    LtLt: 'lt-LT',
    LvLv: 'lv-LV',
    MgMg: 'mg-MG',
    MkMk: 'mk-MK',
    MlIn: 'ml-IN',
    MnMn: 'mn-MN',
    MrIn: 'mr-IN',
    MsMy: 'ms-MY',
    MtMt: 'mt-MT',
    MyMm: 'my-MM',
    NbNo: 'nb-NO',
    NeNp: 'ne-NP',
    NlBe: 'nl-BE',
    NlNl: 'nl-NL',
    NnNo: 'nn-NO',
    OrIn: 'or-IN',
    PaIn: 'pa-IN',
    PlPl: 'pl-PL',
    PsAf: 'ps-AF',
    Pt: 'pt',
    PtBr: 'pt-BR',
    PtPt: 'pt-PT',
    RoRo: 'ro-RO',
    Ru: 'ru',
    RuRu: 'ru-RU',
    RwRw: 'rw-RW',
    ScIt: 'sc-IT',
    SiLk: 'si-LK',
    SkSk: 'sk-SK',
    SlSi: 'sl-SI',
    SnZw: 'sn-ZW',
    SqAl: 'sq-AL',
    SrRs: 'sr-RS',
    SvSe: 'sv-SE',
    SwKe: 'sw-KE',
    SySy: 'sy-SY',
    SzPl: 'sz-PL',
    TaIn: 'ta-IN',
    TeIn: 'te-IN',
    TgTj: 'tg-TJ',
    ThTh: 'th-TH',
    TlPh: 'tl-PH',
    Tr: 'tr',
    TrTr: 'tr-TR',
    TtRu: 'tt-RU',
    TzMa: 'tz-MA',
    UkUa: 'uk-UA',
    UrPk: 'ur-PK',
    UzUz: 'uz-UZ',
    ViVn: 'vi-VN',
    Zh: 'zh',
    ZhCn: 'zh-CN',
    ZhHk: 'zh-HK',
    ZhMo: 'zh-MO',
    ZhTw: 'zh-TW',
    ZzTr: 'zz-TR'
} as const;

export type UpdateSignInExp200ResponseLanguageInfoFallbackLanguageEnum = typeof UpdateSignInExp200ResponseLanguageInfoFallbackLanguageEnum[keyof typeof UpdateSignInExp200ResponseLanguageInfoFallbackLanguageEnum];

/**
 * 
 * @export
 * @interface UpdateSignInExp200ResponseMfa
 */
export interface UpdateSignInExp200ResponseMfa {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateSignInExp200ResponseMfa
     */
    'factors': Array<UpdateSignInExp200ResponseMfaFactorsEnum>;
    /**
     * 
     * @type {string}
     * @memberof UpdateSignInExp200ResponseMfa
     */
    'policy': UpdateSignInExp200ResponseMfaPolicyEnum;
}

export const UpdateSignInExp200ResponseMfaFactorsEnum = {
    Totp: 'Totp',
    WebAuthn: 'WebAuthn',
    BackupCode: 'BackupCode'
} as const;

export type UpdateSignInExp200ResponseMfaFactorsEnum = typeof UpdateSignInExp200ResponseMfaFactorsEnum[keyof typeof UpdateSignInExp200ResponseMfaFactorsEnum];
export const UpdateSignInExp200ResponseMfaPolicyEnum = {
    UserControlled: 'UserControlled',
    Mandatory: 'Mandatory'
} as const;

export type UpdateSignInExp200ResponseMfaPolicyEnum = typeof UpdateSignInExp200ResponseMfaPolicyEnum[keyof typeof UpdateSignInExp200ResponseMfaPolicyEnum];

/**
 * 
 * @export
 * @interface UpdateSignInExp200ResponsePasswordPolicy
 */
export interface UpdateSignInExp200ResponsePasswordPolicy {
    /**
     * 
     * @type {GetSignInExp200ResponsePasswordPolicyLength}
     * @memberof UpdateSignInExp200ResponsePasswordPolicy
     */
    'length'?: GetSignInExp200ResponsePasswordPolicyLength;
    /**
     * 
     * @type {GetSignInExp200ResponsePasswordPolicyCharacterTypes}
     * @memberof UpdateSignInExp200ResponsePasswordPolicy
     */
    'characterTypes'?: GetSignInExp200ResponsePasswordPolicyCharacterTypes;
    /**
     * 
     * @type {GetSignInExp200ResponsePasswordPolicyRejects}
     * @memberof UpdateSignInExp200ResponsePasswordPolicy
     */
    'rejects'?: GetSignInExp200ResponsePasswordPolicyRejects;
}
/**
 * 
 * @export
 * @interface UpdateSignInExp200ResponseSignIn
 */
export interface UpdateSignInExp200ResponseSignIn {
    /**
     * 
     * @type {Array<GetSignInExp200ResponseSignInMethodsInner>}
     * @memberof UpdateSignInExp200ResponseSignIn
     */
    'methods': Array<GetSignInExp200ResponseSignInMethodsInner>;
}
/**
 * 
 * @export
 * @interface UpdateSignInExp200ResponseSignUp
 */
export interface UpdateSignInExp200ResponseSignUp {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateSignInExp200ResponseSignUp
     */
    'identifiers': Array<UpdateSignInExp200ResponseSignUpIdentifiersEnum>;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateSignInExp200ResponseSignUp
     */
    'password': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateSignInExp200ResponseSignUp
     */
    'verify': boolean;
}

export const UpdateSignInExp200ResponseSignUpIdentifiersEnum = {
    Username: 'username',
    Email: 'email',
    Phone: 'phone'
} as const;

export type UpdateSignInExp200ResponseSignUpIdentifiersEnum = typeof UpdateSignInExp200ResponseSignUpIdentifiersEnum[keyof typeof UpdateSignInExp200ResponseSignUpIdentifiersEnum];

/**
 * 
 * @export
 * @interface UpdateSignInExpRequest
 */
export interface UpdateSignInExpRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateSignInExpRequest
     */
    'tenantId'?: string;
    /**
     * 
     * @type {UpdateSignInExpRequestColor}
     * @memberof UpdateSignInExpRequest
     */
    'color'?: UpdateSignInExpRequestColor;
    /**
     * 
     * @type {ApiInteractionConsentGet200ResponseApplicationBranding}
     * @memberof UpdateSignInExpRequest
     */
    'branding'?: ApiInteractionConsentGet200ResponseApplicationBranding;
    /**
     * 
     * @type {UpdateSignInExpRequestLanguageInfo}
     * @memberof UpdateSignInExpRequest
     */
    'languageInfo'?: UpdateSignInExpRequestLanguageInfo;
    /**
     * 
     * @type {string}
     * @memberof UpdateSignInExpRequest
     */
    'agreeToTermsPolicy'?: UpdateSignInExpRequestAgreeToTermsPolicyEnum;
    /**
     * 
     * @type {UpdateSignInExpRequestSignIn}
     * @memberof UpdateSignInExpRequest
     */
    'signIn'?: UpdateSignInExpRequestSignIn;
    /**
     * 
     * @type {UpdateSignInExpRequestSignUp}
     * @memberof UpdateSignInExpRequest
     */
    'signUp'?: UpdateSignInExpRequestSignUp;
    /**
     * 
     * @type {GetSignInExp200ResponseSocialSignIn}
     * @memberof UpdateSignInExpRequest
     */
    'socialSignIn'?: GetSignInExp200ResponseSocialSignIn;
    /**
     * Specify the social sign-in connectors to display on the sign-in page.
     * @type {Array<string>}
     * @memberof UpdateSignInExpRequest
     */
    'socialSignInConnectorTargets'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateSignInExpRequest
     */
    'signInMode'?: UpdateSignInExpRequestSignInModeEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateSignInExpRequest
     */
    'customCss'?: string | null;
    /**
     * Custom content to display on experience flow pages. the page pathname will be the config key, the content will be the config value.
     * @type {{ [key: string]: string; }}
     * @memberof UpdateSignInExpRequest
     */
    'customContent'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof UpdateSignInExpRequest
     */
    'customUiAssetId'?: string | null;
    /**
     * 
     * @type {GetSignInExp200ResponsePasswordPolicy}
     * @memberof UpdateSignInExpRequest
     */
    'passwordPolicy'?: GetSignInExp200ResponsePasswordPolicy;
    /**
     * 
     * @type {GetSignInExp200ResponseMfa}
     * @memberof UpdateSignInExpRequest
     */
    'mfa'?: GetSignInExp200ResponseMfa;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateSignInExpRequest
     */
    'singleSignOnEnabled'?: boolean;
    /**
     * 
     * @type {UpdateSignInExpRequestTermsOfUseUrl}
     * @memberof UpdateSignInExpRequest
     */
    'termsOfUseUrl'?: UpdateSignInExpRequestTermsOfUseUrl;
    /**
     * 
     * @type {UpdateSignInExpRequestTermsOfUseUrl}
     * @memberof UpdateSignInExpRequest
     */
    'privacyPolicyUrl'?: UpdateSignInExpRequestTermsOfUseUrl;
}

export const UpdateSignInExpRequestAgreeToTermsPolicyEnum = {
    Automatic: 'Automatic',
    ManualRegistrationOnly: 'ManualRegistrationOnly',
    Manual: 'Manual'
} as const;

export type UpdateSignInExpRequestAgreeToTermsPolicyEnum = typeof UpdateSignInExpRequestAgreeToTermsPolicyEnum[keyof typeof UpdateSignInExpRequestAgreeToTermsPolicyEnum];
export const UpdateSignInExpRequestSignInModeEnum = {
    SignIn: 'SignIn',
    Register: 'Register',
    SignInAndRegister: 'SignInAndRegister'
} as const;

export type UpdateSignInExpRequestSignInModeEnum = typeof UpdateSignInExpRequestSignInModeEnum[keyof typeof UpdateSignInExpRequestSignInModeEnum];

/**
 * Specify the primary branding color for the sign-in page (both light/dark mode).
 * @export
 * @interface UpdateSignInExpRequestColor
 */
export interface UpdateSignInExpRequestColor {
    /**
     * 
     * @type {string}
     * @memberof UpdateSignInExpRequestColor
     */
    'primaryColor': string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateSignInExpRequestColor
     */
    'isDarkModeEnabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateSignInExpRequestColor
     */
    'darkPrimaryColor': string;
}
/**
 * Control the language detection policy for the sign-in page.
 * @export
 * @interface UpdateSignInExpRequestLanguageInfo
 */
export interface UpdateSignInExpRequestLanguageInfo {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateSignInExpRequestLanguageInfo
     */
    'autoDetect': boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateSignInExpRequestLanguageInfo
     */
    'fallbackLanguage': UpdateSignInExpRequestLanguageInfoFallbackLanguageEnum;
}

export const UpdateSignInExpRequestLanguageInfoFallbackLanguageEnum = {
    AfZa: 'af-ZA',
    AmEt: 'am-ET',
    ArAr: 'ar-AR',
    AsIn: 'as-IN',
    AzAz: 'az-AZ',
    BeBy: 'be-BY',
    BgBg: 'bg-BG',
    BnIn: 'bn-IN',
    BrFr: 'br-FR',
    BsBa: 'bs-BA',
    CaEs: 'ca-ES',
    CbIq: 'cb-IQ',
    CoFr: 'co-FR',
    CsCz: 'cs-CZ',
    CxPh: 'cx-PH',
    CyGb: 'cy-GB',
    DaDk: 'da-DK',
    De: 'de',
    DeDe: 'de-DE',
    ElGr: 'el-GR',
    En: 'en',
    EnGb: 'en-GB',
    EnUs: 'en-US',
    EoEo: 'eo-EO',
    Es: 'es',
    EsEs: 'es-ES',
    Es419: 'es-419',
    EtEe: 'et-EE',
    EuEs: 'eu-ES',
    FaIr: 'fa-IR',
    FfNg: 'ff-NG',
    FiFi: 'fi-FI',
    FoFo: 'fo-FO',
    Fr: 'fr',
    FrCa: 'fr-CA',
    FrFr: 'fr-FR',
    FyNl: 'fy-NL',
    GaIe: 'ga-IE',
    GlEs: 'gl-ES',
    GnPy: 'gn-PY',
    GuIn: 'gu-IN',
    HaNg: 'ha-NG',
    HeIl: 'he-IL',
    HiIn: 'hi-IN',
    HrHr: 'hr-HR',
    HtHt: 'ht-HT',
    HuHu: 'hu-HU',
    HyAm: 'hy-AM',
    IdId: 'id-ID',
    IkUs: 'ik-US',
    IsIs: 'is-IS',
    It: 'it',
    ItIt: 'it-IT',
    IuCa: 'iu-CA',
    Ja: 'ja',
    JaJp: 'ja-JP',
    JaKs: 'ja-KS',
    JvId: 'jv-ID',
    KaGe: 'ka-GE',
    KkKz: 'kk-KZ',
    KmKh: 'km-KH',
    KnIn: 'kn-IN',
    Ko: 'ko',
    KoKr: 'ko-KR',
    KuTr: 'ku-TR',
    KyKg: 'ky-KG',
    LoLa: 'lo-LA',
    LtLt: 'lt-LT',
    LvLv: 'lv-LV',
    MgMg: 'mg-MG',
    MkMk: 'mk-MK',
    MlIn: 'ml-IN',
    MnMn: 'mn-MN',
    MrIn: 'mr-IN',
    MsMy: 'ms-MY',
    MtMt: 'mt-MT',
    MyMm: 'my-MM',
    NbNo: 'nb-NO',
    NeNp: 'ne-NP',
    NlBe: 'nl-BE',
    NlNl: 'nl-NL',
    NnNo: 'nn-NO',
    OrIn: 'or-IN',
    PaIn: 'pa-IN',
    PlPl: 'pl-PL',
    PsAf: 'ps-AF',
    Pt: 'pt',
    PtBr: 'pt-BR',
    PtPt: 'pt-PT',
    RoRo: 'ro-RO',
    Ru: 'ru',
    RuRu: 'ru-RU',
    RwRw: 'rw-RW',
    ScIt: 'sc-IT',
    SiLk: 'si-LK',
    SkSk: 'sk-SK',
    SlSi: 'sl-SI',
    SnZw: 'sn-ZW',
    SqAl: 'sq-AL',
    SrRs: 'sr-RS',
    SvSe: 'sv-SE',
    SwKe: 'sw-KE',
    SySy: 'sy-SY',
    SzPl: 'sz-PL',
    TaIn: 'ta-IN',
    TeIn: 'te-IN',
    TgTj: 'tg-TJ',
    ThTh: 'th-TH',
    TlPh: 'tl-PH',
    Tr: 'tr',
    TrTr: 'tr-TR',
    TtRu: 'tt-RU',
    TzMa: 'tz-MA',
    UkUa: 'uk-UA',
    UrPk: 'ur-PK',
    UzUz: 'uz-UZ',
    ViVn: 'vi-VN',
    Zh: 'zh',
    ZhCn: 'zh-CN',
    ZhHk: 'zh-HK',
    ZhMo: 'zh-MO',
    ZhTw: 'zh-TW',
    ZzTr: 'zz-TR'
} as const;

export type UpdateSignInExpRequestLanguageInfoFallbackLanguageEnum = typeof UpdateSignInExpRequestLanguageInfoFallbackLanguageEnum[keyof typeof UpdateSignInExpRequestLanguageInfoFallbackLanguageEnum];

/**
 * Sign-in method settings
 * @export
 * @interface UpdateSignInExpRequestSignIn
 */
export interface UpdateSignInExpRequestSignIn {
    /**
     * 
     * @type {Array<GetSignInExp200ResponseSignInMethodsInner>}
     * @memberof UpdateSignInExpRequestSignIn
     */
    'methods': Array<GetSignInExp200ResponseSignInMethodsInner>;
}
/**
 * Sign-up method settings
 * @export
 * @interface UpdateSignInExpRequestSignUp
 */
export interface UpdateSignInExpRequestSignUp {
    /**
     * Specify allowed identifiers when signing-up.
     * @type {Array<string>}
     * @memberof UpdateSignInExpRequestSignUp
     */
    'identifiers': Array<UpdateSignInExpRequestSignUpIdentifiersEnum>;
    /**
     * Whether the user is required to set a password when signing-up.
     * @type {boolean}
     * @memberof UpdateSignInExpRequestSignUp
     */
    'password': boolean;
    /**
     * Whether the user is required to verify their email/phone when signing-up.
     * @type {boolean}
     * @memberof UpdateSignInExpRequestSignUp
     */
    'verify': boolean;
}

export const UpdateSignInExpRequestSignUpIdentifiersEnum = {
    Username: 'username',
    Email: 'email',
    Phone: 'phone'
} as const;

export type UpdateSignInExpRequestSignUpIdentifiersEnum = typeof UpdateSignInExpRequestSignUpIdentifiersEnum[keyof typeof UpdateSignInExpRequestSignUpIdentifiersEnum];

/**
 * @type UpdateSignInExpRequestTermsOfUseUrl
 * @export
 */
export type UpdateSignInExpRequestTermsOfUseUrl = string;

/**
 * 
 * @export
 * @interface UpdateSsoConnectorRequest
 */
export interface UpdateSsoConnectorRequest {
    /**
     * arbitrary
     * @type {object}
     * @memberof UpdateSsoConnectorRequest
     */
    'config'?: object;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateSsoConnectorRequest
     */
    'domains'?: Array<string>;
    /**
     * 
     * @type {ListOrganizationJitSsoConnectors200ResponseInnerBranding}
     * @memberof UpdateSsoConnectorRequest
     */
    'branding'?: ListOrganizationJitSsoConnectors200ResponseInnerBranding;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateSsoConnectorRequest
     */
    'syncProfile'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateSsoConnectorRequest
     */
    'connectorName'?: string;
}
/**
 * 
 * @export
 * @interface UpdateUser200Response
 */
export interface UpdateUser200Response {
    /**
     * 
     * @type {string}
     * @memberof UpdateUser200Response
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUser200Response
     */
    'username': string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUser200Response
     */
    'primaryEmail': string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUser200Response
     */
    'primaryPhone': string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUser200Response
     */
    'name': string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUser200Response
     */
    'avatar': string | null;
    /**
     * arbitrary
     * @type {object}
     * @memberof UpdateUser200Response
     */
    'customData': object;
    /**
     * 
     * @type {{ [key: string]: GetJwtCustomizer200ResponseOneOfContextSampleUserIdentitiesValue; }}
     * @memberof UpdateUser200Response
     */
    'identities': { [key: string]: GetJwtCustomizer200ResponseOneOfContextSampleUserIdentitiesValue; };
    /**
     * 
     * @type {number}
     * @memberof UpdateUser200Response
     */
    'lastSignInAt': number | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateUser200Response
     */
    'createdAt': number;
    /**
     * 
     * @type {number}
     * @memberof UpdateUser200Response
     */
    'updatedAt': number;
    /**
     * 
     * @type {GetJwtCustomizer200ResponseOneOfContextSampleUserProfile}
     * @memberof UpdateUser200Response
     */
    'profile': GetJwtCustomizer200ResponseOneOfContextSampleUserProfile;
    /**
     * 
     * @type {string}
     * @memberof UpdateUser200Response
     */
    'applicationId': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUser200Response
     */
    'isSuspended': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUser200Response
     */
    'hasPassword'?: boolean;
    /**
     * 
     * @type {Array<GetUser200ResponseSsoIdentitiesInner>}
     * @memberof UpdateUser200Response
     */
    'ssoIdentities'?: Array<GetUser200ResponseSsoIdentitiesInner>;
}
/**
 * 
 * @export
 * @interface UpdateUserCustomDataRequest
 */
export interface UpdateUserCustomDataRequest {
    /**
     * Partial custom data object to update for the given user ID.
     * @type {object}
     * @memberof UpdateUserCustomDataRequest
     */
    'customData': object;
}
/**
 * 
 * @export
 * @interface UpdateUserIsSuspendedRequest
 */
export interface UpdateUserIsSuspendedRequest {
    /**
     * New suspension status for the user.
     * @type {boolean}
     * @memberof UpdateUserIsSuspendedRequest
     */
    'isSuspended': boolean;
}
/**
 * 
 * @export
 * @interface UpdateUserPasswordRequest
 */
export interface UpdateUserPasswordRequest {
    /**
     * New password for the user.
     * @type {string}
     * @memberof UpdateUserPasswordRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface UpdateUserProfileRequest
 */
export interface UpdateUserProfileRequest {
    /**
     * 
     * @type {UpdateUserProfileRequestProfile}
     * @memberof UpdateUserProfileRequest
     */
    'profile': UpdateUserProfileRequestProfile;
}
/**
 * Partial profile object to update for the given user ID.
 * @export
 * @interface UpdateUserProfileRequestProfile
 */
export interface UpdateUserProfileRequestProfile {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileRequestProfile
     */
    'familyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileRequestProfile
     */
    'givenName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileRequestProfile
     */
    'middleName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileRequestProfile
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileRequestProfile
     */
    'preferredUsername'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileRequestProfile
     */
    'profile'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileRequestProfile
     */
    'website'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileRequestProfile
     */
    'gender'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileRequestProfile
     */
    'birthdate'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileRequestProfile
     */
    'zoneinfo'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileRequestProfile
     */
    'locale'?: string;
    /**
     * 
     * @type {GetJwtCustomizer200ResponseOneOfContextSampleUserProfileAddress}
     * @memberof UpdateUserProfileRequestProfile
     */
    'address'?: GetJwtCustomizer200ResponseOneOfContextSampleUserProfileAddress;
}
/**
 * 
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * 
     * @type {UpdateUserRequestUsername}
     * @memberof UpdateUserRequest
     */
    'username'?: UpdateUserRequestUsername | null;
    /**
     * 
     * @type {UpdateUserRequestPrimaryEmail}
     * @memberof UpdateUserRequest
     */
    'primaryEmail'?: UpdateUserRequestPrimaryEmail | null;
    /**
     * 
     * @type {UpdateUserRequestPrimaryPhone}
     * @memberof UpdateUserRequest
     */
    'primaryPhone'?: UpdateUserRequestPrimaryPhone | null;
    /**
     * 
     * @type {UpdateUserRequestName}
     * @memberof UpdateUserRequest
     */
    'name'?: UpdateUserRequestName | null;
    /**
     * 
     * @type {UpdateUserRequestAvatar}
     * @memberof UpdateUserRequest
     */
    'avatar'?: UpdateUserRequestAvatar | null;
    /**
     * Custom data object to update for the given user ID. Note this will replace the entire custom data object.  If you want to perform a partial update, use the `PATCH /api/users/{userId}/custom-data` endpoint instead.
     * @type {object}
     * @memberof UpdateUserRequest
     */
    'customData'?: object;
    /**
     * 
     * @type {GetJwtCustomizer200ResponseOneOfContextSampleUserProfile}
     * @memberof UpdateUserRequest
     */
    'profile'?: GetJwtCustomizer200ResponseOneOfContextSampleUserProfile;
}
/**
 * @type UpdateUserRequestAvatar
 * @export
 */
export type UpdateUserRequestAvatar = string;

/**
 * @type UpdateUserRequestName
 * @export
 */
export type UpdateUserRequestName = string;

/**
 * @type UpdateUserRequestPrimaryEmail
 * Updated primary email address for the user. It should be unique across all users.
 * @export
 */
export type UpdateUserRequestPrimaryEmail = string;

/**
 * @type UpdateUserRequestPrimaryPhone
 * Updated primary phone number for the user. It should be unique across all users.
 * @export
 */
export type UpdateUserRequestPrimaryPhone = string;

/**
 * @type UpdateUserRequestUsername
 * Updated username for the user. It should be unique across all users.
 * @export
 */
export type UpdateUserRequestUsername = string;

/**
 * 
 * @export
 * @interface UpsertJwtCustomizerRequest
 */
export interface UpsertJwtCustomizerRequest {
    /**
     * The script of the JWT customizer.
     * @type {any}
     * @memberof UpsertJwtCustomizerRequest
     */
    'script'?: any;
    /**
     * The environment variables for the JWT customizer.
     * @type {any}
     * @memberof UpsertJwtCustomizerRequest
     */
    'environmentVariables'?: any;
    /**
     * The sample context for the JWT customizer script testing purpose.
     * @type {any}
     * @memberof UpsertJwtCustomizerRequest
     */
    'contextSample'?: any;
    /**
     * The sample raw token payload for the JWT customizer script testing purpose.
     * @type {any}
     * @memberof UpsertJwtCustomizerRequest
     */
    'tokenSample'?: any;
}
/**
 * 
 * @export
 * @interface VerifyUserPasswordRequest
 */
export interface VerifyUserPasswordRequest {
    /**
     * Password to verify.
     * @type {string}
     * @memberof VerifyUserPasswordRequest
     */
    'password': string;
}
/**
 * @type VerifyVerificationCodeRequest
 * @export
 */
export type VerifyVerificationCodeRequest = ApiInteractionPutRequestIdentifierOneOf3 | ApiInteractionPutRequestIdentifierOneOf4;


/**
 * ApplicationsApi - axios parameter creator
 * @export
 */
export const ApplicationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Assign API resource roles to the specified application. The API resource roles will be added to the existing API resource roles.
         * @summary Assign API resource roles to application
         * @param {string} applicationId The unique identifier of the application.
         * @param {AssignApplicationRolesRequest} assignApplicationRolesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignApplicationRoles: async (applicationId: string, assignApplicationRolesRequest: AssignApplicationRolesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('assignApplicationRoles', 'applicationId', applicationId)
            // verify required parameter 'assignApplicationRolesRequest' is not null or undefined
            assertParamExists('assignApplicationRoles', 'assignApplicationRolesRequest', assignApplicationRolesRequest)
            const localVarPath = `/api/applications/{applicationId}/roles`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignApplicationRolesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new application with the given data.
         * @summary Create an application
         * @param {CreateApplicationRequest} createApplicationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication: async (createApplicationRequest: CreateApplicationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createApplicationRequest' is not null or undefined
            assertParamExists('createApplication', 'createApplicationRequest', createApplicationRequest)
            const localVarPath = `/api/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createApplicationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a custom domain to the protected application. You\'ll need to setup DNS record later. This feature is not available for open source version.
         * @summary Add a custom domain to the protected application.
         * @param {string} id The unique identifier of the application.
         * @param {CreateApplicationProtectedAppMetadataCustomDomainRequest} createApplicationProtectedAppMetadataCustomDomainRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationProtectedAppMetadataCustomDomain: async (id: string, createApplicationProtectedAppMetadataCustomDomainRequest: CreateApplicationProtectedAppMetadataCustomDomainRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createApplicationProtectedAppMetadataCustomDomain', 'id', id)
            // verify required parameter 'createApplicationProtectedAppMetadataCustomDomainRequest' is not null or undefined
            assertParamExists('createApplicationProtectedAppMetadataCustomDomain', 'createApplicationProtectedAppMetadataCustomDomainRequest', createApplicationProtectedAppMetadataCustomDomainRequest)
            const localVarPath = `/api/applications/{id}/protected-app-metadata/custom-domains`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createApplicationProtectedAppMetadataCustomDomainRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Grant a list of organization access of a user for a application by application id and user id. <br/> The user must be a member of all the organizations. <br/> Only third-party application needs to be granted access to organizations, all the other applications can request for all the organizations\' access by default.
         * @summary Grant a list of organization access of a user for a application.
         * @param {string} id The unique identifier of the application.
         * @param {string} userId The unique identifier of the user.
         * @param {CreateApplicationUserConsentOrganizationRequest} createApplicationUserConsentOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationUserConsentOrganization: async (id: string, userId: string, createApplicationUserConsentOrganizationRequest: CreateApplicationUserConsentOrganizationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createApplicationUserConsentOrganization', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createApplicationUserConsentOrganization', 'userId', userId)
            // verify required parameter 'createApplicationUserConsentOrganizationRequest' is not null or undefined
            assertParamExists('createApplicationUserConsentOrganization', 'createApplicationUserConsentOrganizationRequest', createApplicationUserConsentOrganizationRequest)
            const localVarPath = `/api/applications/{id}/users/{userId}/consent-organizations`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createApplicationUserConsentOrganizationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign the user consent scopes to an application by application id
         * @summary Assign user consent scopes to application.
         * @param {string} applicationId The unique identifier of the application.
         * @param {CreateApplicationUserConsentScopeRequest} createApplicationUserConsentScopeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationUserConsentScope: async (applicationId: string, createApplicationUserConsentScopeRequest: CreateApplicationUserConsentScopeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('createApplicationUserConsentScope', 'applicationId', applicationId)
            // verify required parameter 'createApplicationUserConsentScopeRequest' is not null or undefined
            assertParamExists('createApplicationUserConsentScope', 'createApplicationUserConsentScopeRequest', createApplicationUserConsentScopeRequest)
            const localVarPath = `/api/applications/{applicationId}/user-consent-scopes`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createApplicationUserConsentScopeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete application by ID.
         * @summary Delete application
         * @param {string} id The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteApplication', 'id', id)
            const localVarPath = `/api/applications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a custom domain. This feature is not available for open source version.
         * @summary Delete a custom domain.
         * @param {string} id The unique identifier of the application.
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationProtectedAppMetadataCustomDomain: async (id: string, domain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteApplicationProtectedAppMetadataCustomDomain', 'id', id)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('deleteApplicationProtectedAppMetadataCustomDomain', 'domain', domain)
            const localVarPath = `/api/applications/{id}/protected-app-metadata/custom-domains/{domain}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a API resource role from the specified application.
         * @summary Remove a API resource role from application
         * @param {string} applicationId The unique identifier of the application.
         * @param {string} roleId The unique identifier of the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationRole: async (applicationId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplicationRole', 'applicationId', applicationId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('deleteApplicationRole', 'roleId', roleId)
            const localVarPath = `/api/applications/{applicationId}/roles/{roleId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke a user\'s access to an organization for a application by application id, user id and organization id.
         * @summary Revoke a user\'s access to an organization for a application.
         * @param {string} id The unique identifier of the application.
         * @param {string} userId The unique identifier of the user.
         * @param {string} organizationId The unique identifier of the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationUserConsentOrganization: async (id: string, userId: string, organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteApplicationUserConsentOrganization', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteApplicationUserConsentOrganization', 'userId', userId)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteApplicationUserConsentOrganization', 'organizationId', organizationId)
            const localVarPath = `/api/applications/{id}/users/{userId}/consent-organizations/{organizationId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove the user consent scope from an application by application id, scope type and scope id
         * @summary Remove user consent scope from application.
         * @param {string} applicationId The unique identifier of the application.
         * @param {DeleteApplicationUserConsentScopeScopeTypeEnum} scopeType 
         * @param {string} scopeId The unique identifier of the scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationUserConsentScope: async (applicationId: string, scopeType: DeleteApplicationUserConsentScopeScopeTypeEnum, scopeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteApplicationUserConsentScope', 'applicationId', applicationId)
            // verify required parameter 'scopeType' is not null or undefined
            assertParamExists('deleteApplicationUserConsentScope', 'scopeType', scopeType)
            // verify required parameter 'scopeId' is not null or undefined
            assertParamExists('deleteApplicationUserConsentScope', 'scopeId', scopeId)
            const localVarPath = `/api/applications/{applicationId}/user-consent-scopes/{scopeType}/{scopeId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"scopeType"}}`, encodeURIComponent(String(scopeType)))
                .replace(`{${"scopeId"}}`, encodeURIComponent(String(scopeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get application details by ID.
         * @summary Get application
         * @param {string} id The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getApplication', 'id', id)
            const localVarPath = `/api/applications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get application level sign-in experience for a given application.   - Only branding properties and terms links customization is supported for now.    - Only third-party applications can have the sign-in experience customization for now.
         * @summary Get the application level sign-in experience
         * @param {string} applicationId The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationSignInExperience: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('getApplicationSignInExperience', 'applicationId', applicationId)
            const localVarPath = `/api/applications/{applicationId}/sign-in-experience`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the list of organizations that an application is associated with.
         * @summary Get application organizations
         * @param {string} id The unique identifier of the application.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationOrganizations: async (id: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listApplicationOrganizations', 'id', id)
            const localVarPath = `/api/applications/{id}/organizations`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the list of custom domains of the protected application. This feature is not available for open source version.
         * @summary Get the list of custom domains of the protected application.
         * @param {string} id The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationProtectedAppMetadataCustomDomains: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listApplicationProtectedAppMetadataCustomDomains', 'id', id)
            const localVarPath = `/api/applications/{id}/protected-app-metadata/custom-domains`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get API resource roles assigned to the specified application with pagination.
         * @summary Get application API resource roles
         * @param {string} applicationId The unique identifier of the application.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationRoles: async (applicationId: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationRoles', 'applicationId', applicationId)
            const localVarPath = `/api/applications/{applicationId}/roles`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all the user consented organizations for a application by application id and user id.
         * @summary List all the user consented organizations of a application.
         * @param {string} id The unique identifier of the application.
         * @param {string} userId The unique identifier of the user.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationUserConsentOrganizations: async (id: string, userId: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listApplicationUserConsentOrganizations', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listApplicationUserConsentOrganizations', 'userId', userId)
            const localVarPath = `/api/applications/{id}/users/{userId}/consent-organizations`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all the user consent scopes of an application by application id
         * @summary List all the user consent scopes of an application.
         * @param {string} applicationId The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationUserConsentScopes: async (applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listApplicationUserConsentScopes', 'applicationId', applicationId)
            const localVarPath = `/api/applications/{applicationId}/user-consent-scopes`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get applications that match the given query with pagination.
         * @summary Get applications
         * @param {ListApplicationsTypesParameter} [types] An array of application types to filter applications.
         * @param {string} [excludeRoleId] 
         * @param {string} [excludeOrganizationId] 
         * @param {ListApplicationsIsThirdPartyParameter} [isThirdParty] 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplications: async (types?: ListApplicationsTypesParameter, excludeRoleId?: string, excludeOrganizationId?: string, isThirdParty?: ListApplicationsIsThirdPartyParameter, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (types !== undefined) {
                for (const [key, value] of Object.entries(types)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (excludeRoleId !== undefined) {
                localVarQueryParameter['excludeRoleId'] = excludeRoleId;
            }

            if (excludeOrganizationId !== undefined) {
                localVarQueryParameter['excludeOrganizationId'] = excludeOrganizationId;
            }

            if (isThirdParty !== undefined) {
                for (const [key, value] of Object.entries(isThirdParty)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update API resource roles assigned to the specified application. This will replace the existing API resource roles.
         * @summary Update API resource roles for application
         * @param {string} applicationId The unique identifier of the application.
         * @param {ReplaceApplicationRolesRequest} replaceApplicationRolesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceApplicationRoles: async (applicationId: string, replaceApplicationRolesRequest: ReplaceApplicationRolesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('replaceApplicationRoles', 'applicationId', applicationId)
            // verify required parameter 'replaceApplicationRolesRequest' is not null or undefined
            assertParamExists('replaceApplicationRoles', 'replaceApplicationRolesRequest', replaceApplicationRolesRequest)
            const localVarPath = `/api/applications/{applicationId}/roles`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(replaceApplicationRolesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update application level sign-in experience for the specified application. Create a new sign-in experience if it does not exist.   - Only branding properties and terms links customization is supported for now.    - Only third-party applications can be customized for now.    - Application level sign-in experience customization is optional, if provided, it will override the default branding and terms links.
         * @summary Update application level sign-in experience
         * @param {string} applicationId The unique identifier of the application.
         * @param {ReplaceApplicationSignInExperienceRequest} replaceApplicationSignInExperienceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceApplicationSignInExperience: async (applicationId: string, replaceApplicationSignInExperienceRequest: ReplaceApplicationSignInExperienceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('replaceApplicationSignInExperience', 'applicationId', applicationId)
            // verify required parameter 'replaceApplicationSignInExperienceRequest' is not null or undefined
            assertParamExists('replaceApplicationSignInExperience', 'replaceApplicationSignInExperienceRequest', replaceApplicationSignInExperienceRequest)
            const localVarPath = `/api/applications/{applicationId}/sign-in-experience`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(replaceApplicationSignInExperienceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Grant a list of organization access of a user for a application by application id and user id. <br/> The user must be a member of all the organizations. <br/> Only third-party application needs to be granted access to organizations, all the other applications can request for all the organizations\' access by default.
         * @summary Grant a list of organization access of a user for a application.
         * @param {string} id The unique identifier of the application.
         * @param {string} userId The unique identifier of the user.
         * @param {ReplaceApplicationUserConsentOrganizationsRequest} replaceApplicationUserConsentOrganizationsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceApplicationUserConsentOrganizations: async (id: string, userId: string, replaceApplicationUserConsentOrganizationsRequest: ReplaceApplicationUserConsentOrganizationsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('replaceApplicationUserConsentOrganizations', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('replaceApplicationUserConsentOrganizations', 'userId', userId)
            // verify required parameter 'replaceApplicationUserConsentOrganizationsRequest' is not null or undefined
            assertParamExists('replaceApplicationUserConsentOrganizations', 'replaceApplicationUserConsentOrganizationsRequest', replaceApplicationUserConsentOrganizationsRequest)
            const localVarPath = `/api/applications/{id}/users/{userId}/consent-organizations`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(replaceApplicationUserConsentOrganizationsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update application details by ID with the given data.
         * @summary Update application
         * @param {string} id The unique identifier of the application.
         * @param {UpdateApplicationRequest} updateApplicationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplication: async (id: string, updateApplicationRequest: UpdateApplicationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateApplication', 'id', id)
            // verify required parameter 'updateApplicationRequest' is not null or undefined
            assertParamExists('updateApplication', 'updateApplicationRequest', updateApplicationRequest)
            const localVarPath = `/api/applications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateApplicationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationsApi - functional programming interface
 * @export
 */
export const ApplicationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Assign API resource roles to the specified application. The API resource roles will be added to the existing API resource roles.
         * @summary Assign API resource roles to application
         * @param {string} applicationId The unique identifier of the application.
         * @param {AssignApplicationRolesRequest} assignApplicationRolesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignApplicationRoles(applicationId: string, assignApplicationRolesRequest: AssignApplicationRolesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignApplicationRoles(applicationId, assignApplicationRolesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.assignApplicationRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new application with the given data.
         * @summary Create an application
         * @param {CreateApplicationRequest} createApplicationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplication(createApplicationRequest: CreateApplicationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListApplications200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplication(createApplicationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.createApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a custom domain to the protected application. You\'ll need to setup DNS record later. This feature is not available for open source version.
         * @summary Add a custom domain to the protected application.
         * @param {string} id The unique identifier of the application.
         * @param {CreateApplicationProtectedAppMetadataCustomDomainRequest} createApplicationProtectedAppMetadataCustomDomainRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationProtectedAppMetadataCustomDomain(id: string, createApplicationProtectedAppMetadataCustomDomainRequest: CreateApplicationProtectedAppMetadataCustomDomainRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationProtectedAppMetadataCustomDomain(id, createApplicationProtectedAppMetadataCustomDomainRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.createApplicationProtectedAppMetadataCustomDomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Grant a list of organization access of a user for a application by application id and user id. <br/> The user must be a member of all the organizations. <br/> Only third-party application needs to be granted access to organizations, all the other applications can request for all the organizations\' access by default.
         * @summary Grant a list of organization access of a user for a application.
         * @param {string} id The unique identifier of the application.
         * @param {string} userId The unique identifier of the user.
         * @param {CreateApplicationUserConsentOrganizationRequest} createApplicationUserConsentOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationUserConsentOrganization(id: string, userId: string, createApplicationUserConsentOrganizationRequest: CreateApplicationUserConsentOrganizationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationUserConsentOrganization(id, userId, createApplicationUserConsentOrganizationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.createApplicationUserConsentOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Assign the user consent scopes to an application by application id
         * @summary Assign user consent scopes to application.
         * @param {string} applicationId The unique identifier of the application.
         * @param {CreateApplicationUserConsentScopeRequest} createApplicationUserConsentScopeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicationUserConsentScope(applicationId: string, createApplicationUserConsentScopeRequest: CreateApplicationUserConsentScopeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationUserConsentScope(applicationId, createApplicationUserConsentScopeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.createApplicationUserConsentScope']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete application by ID.
         * @summary Delete application
         * @param {string} id The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplication(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplication(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.deleteApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a custom domain. This feature is not available for open source version.
         * @summary Delete a custom domain.
         * @param {string} id The unique identifier of the application.
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicationProtectedAppMetadataCustomDomain(id: string, domain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicationProtectedAppMetadataCustomDomain(id, domain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.deleteApplicationProtectedAppMetadataCustomDomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a API resource role from the specified application.
         * @summary Remove a API resource role from application
         * @param {string} applicationId The unique identifier of the application.
         * @param {string} roleId The unique identifier of the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicationRole(applicationId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicationRole(applicationId, roleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.deleteApplicationRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revoke a user\'s access to an organization for a application by application id, user id and organization id.
         * @summary Revoke a user\'s access to an organization for a application.
         * @param {string} id The unique identifier of the application.
         * @param {string} userId The unique identifier of the user.
         * @param {string} organizationId The unique identifier of the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicationUserConsentOrganization(id: string, userId: string, organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicationUserConsentOrganization(id, userId, organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.deleteApplicationUserConsentOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove the user consent scope from an application by application id, scope type and scope id
         * @summary Remove user consent scope from application.
         * @param {string} applicationId The unique identifier of the application.
         * @param {DeleteApplicationUserConsentScopeScopeTypeEnum} scopeType 
         * @param {string} scopeId The unique identifier of the scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicationUserConsentScope(applicationId: string, scopeType: DeleteApplicationUserConsentScopeScopeTypeEnum, scopeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicationUserConsentScope(applicationId, scopeType, scopeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.deleteApplicationUserConsentScope']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get application details by ID.
         * @summary Get application
         * @param {string} id The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplication(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetApplication200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplication(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.getApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get application level sign-in experience for a given application.   - Only branding properties and terms links customization is supported for now.    - Only third-party applications can have the sign-in experience customization for now.
         * @summary Get the application level sign-in experience
         * @param {string} applicationId The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationSignInExperience(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetApplicationSignInExperience200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationSignInExperience(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.getApplicationSignInExperience']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the list of organizations that an application is associated with.
         * @summary Get application organizations
         * @param {string} id The unique identifier of the application.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationOrganizations(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListApplicationOrganizations200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationOrganizations(id, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.listApplicationOrganizations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the list of custom domains of the protected application. This feature is not available for open source version.
         * @summary Get the list of custom domains of the protected application.
         * @param {string} id The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationProtectedAppMetadataCustomDomains(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationProtectedAppMetadataCustomDomains(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.listApplicationProtectedAppMetadataCustomDomains']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get API resource roles assigned to the specified application with pagination.
         * @summary Get application API resource roles
         * @param {string} applicationId The unique identifier of the application.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationRoles(applicationId: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListApplicationRoles200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationRoles(applicationId, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.listApplicationRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all the user consented organizations for a application by application id and user id.
         * @summary List all the user consented organizations of a application.
         * @param {string} id The unique identifier of the application.
         * @param {string} userId The unique identifier of the user.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationUserConsentOrganizations(id: string, userId: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListApplicationUserConsentOrganizations200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationUserConsentOrganizations(id, userId, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.listApplicationUserConsentOrganizations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all the user consent scopes of an application by application id
         * @summary List all the user consent scopes of an application.
         * @param {string} applicationId The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicationUserConsentScopes(applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListApplicationUserConsentScopes200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationUserConsentScopes(applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.listApplicationUserConsentScopes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get applications that match the given query with pagination.
         * @summary Get applications
         * @param {ListApplicationsTypesParameter} [types] An array of application types to filter applications.
         * @param {string} [excludeRoleId] 
         * @param {string} [excludeOrganizationId] 
         * @param {ListApplicationsIsThirdPartyParameter} [isThirdParty] 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplications(types?: ListApplicationsTypesParameter, excludeRoleId?: string, excludeOrganizationId?: string, isThirdParty?: ListApplicationsIsThirdPartyParameter, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListApplications200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplications(types, excludeRoleId, excludeOrganizationId, isThirdParty, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.listApplications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update API resource roles assigned to the specified application. This will replace the existing API resource roles.
         * @summary Update API resource roles for application
         * @param {string} applicationId The unique identifier of the application.
         * @param {ReplaceApplicationRolesRequest} replaceApplicationRolesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaceApplicationRoles(applicationId: string, replaceApplicationRolesRequest: ReplaceApplicationRolesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceApplicationRoles(applicationId, replaceApplicationRolesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.replaceApplicationRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update application level sign-in experience for the specified application. Create a new sign-in experience if it does not exist.   - Only branding properties and terms links customization is supported for now.    - Only third-party applications can be customized for now.    - Application level sign-in experience customization is optional, if provided, it will override the default branding and terms links.
         * @summary Update application level sign-in experience
         * @param {string} applicationId The unique identifier of the application.
         * @param {ReplaceApplicationSignInExperienceRequest} replaceApplicationSignInExperienceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaceApplicationSignInExperience(applicationId: string, replaceApplicationSignInExperienceRequest: ReplaceApplicationSignInExperienceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetApplicationSignInExperience200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceApplicationSignInExperience(applicationId, replaceApplicationSignInExperienceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.replaceApplicationSignInExperience']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Grant a list of organization access of a user for a application by application id and user id. <br/> The user must be a member of all the organizations. <br/> Only third-party application needs to be granted access to organizations, all the other applications can request for all the organizations\' access by default.
         * @summary Grant a list of organization access of a user for a application.
         * @param {string} id The unique identifier of the application.
         * @param {string} userId The unique identifier of the user.
         * @param {ReplaceApplicationUserConsentOrganizationsRequest} replaceApplicationUserConsentOrganizationsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaceApplicationUserConsentOrganizations(id: string, userId: string, replaceApplicationUserConsentOrganizationsRequest: ReplaceApplicationUserConsentOrganizationsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceApplicationUserConsentOrganizations(id, userId, replaceApplicationUserConsentOrganizationsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.replaceApplicationUserConsentOrganizations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update application details by ID with the given data.
         * @summary Update application
         * @param {string} id The unique identifier of the application.
         * @param {UpdateApplicationRequest} updateApplicationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateApplication(id: string, updateApplicationRequest: UpdateApplicationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListApplications200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateApplication(id, updateApplicationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationsApi.updateApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApplicationsApi - factory interface
 * @export
 */
export const ApplicationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationsApiFp(configuration)
    return {
        /**
         * Assign API resource roles to the specified application. The API resource roles will be added to the existing API resource roles.
         * @summary Assign API resource roles to application
         * @param {string} applicationId The unique identifier of the application.
         * @param {AssignApplicationRolesRequest} assignApplicationRolesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignApplicationRoles(applicationId: string, assignApplicationRolesRequest: AssignApplicationRolesRequest, options?: any): AxiosPromise<void> {
            return localVarFp.assignApplicationRoles(applicationId, assignApplicationRolesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new application with the given data.
         * @summary Create an application
         * @param {CreateApplicationRequest} createApplicationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication(createApplicationRequest: CreateApplicationRequest, options?: any): AxiosPromise<ListApplications200ResponseInner> {
            return localVarFp.createApplication(createApplicationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a custom domain to the protected application. You\'ll need to setup DNS record later. This feature is not available for open source version.
         * @summary Add a custom domain to the protected application.
         * @param {string} id The unique identifier of the application.
         * @param {CreateApplicationProtectedAppMetadataCustomDomainRequest} createApplicationProtectedAppMetadataCustomDomainRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationProtectedAppMetadataCustomDomain(id: string, createApplicationProtectedAppMetadataCustomDomainRequest: CreateApplicationProtectedAppMetadataCustomDomainRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createApplicationProtectedAppMetadataCustomDomain(id, createApplicationProtectedAppMetadataCustomDomainRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Grant a list of organization access of a user for a application by application id and user id. <br/> The user must be a member of all the organizations. <br/> Only third-party application needs to be granted access to organizations, all the other applications can request for all the organizations\' access by default.
         * @summary Grant a list of organization access of a user for a application.
         * @param {string} id The unique identifier of the application.
         * @param {string} userId The unique identifier of the user.
         * @param {CreateApplicationUserConsentOrganizationRequest} createApplicationUserConsentOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationUserConsentOrganization(id: string, userId: string, createApplicationUserConsentOrganizationRequest: CreateApplicationUserConsentOrganizationRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createApplicationUserConsentOrganization(id, userId, createApplicationUserConsentOrganizationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign the user consent scopes to an application by application id
         * @summary Assign user consent scopes to application.
         * @param {string} applicationId The unique identifier of the application.
         * @param {CreateApplicationUserConsentScopeRequest} createApplicationUserConsentScopeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationUserConsentScope(applicationId: string, createApplicationUserConsentScopeRequest: CreateApplicationUserConsentScopeRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createApplicationUserConsentScope(applicationId, createApplicationUserConsentScopeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete application by ID.
         * @summary Delete application
         * @param {string} id The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplication(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a custom domain. This feature is not available for open source version.
         * @summary Delete a custom domain.
         * @param {string} id The unique identifier of the application.
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationProtectedAppMetadataCustomDomain(id: string, domain: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplicationProtectedAppMetadataCustomDomain(id, domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a API resource role from the specified application.
         * @summary Remove a API resource role from application
         * @param {string} applicationId The unique identifier of the application.
         * @param {string} roleId The unique identifier of the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationRole(applicationId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplicationRole(applicationId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke a user\'s access to an organization for a application by application id, user id and organization id.
         * @summary Revoke a user\'s access to an organization for a application.
         * @param {string} id The unique identifier of the application.
         * @param {string} userId The unique identifier of the user.
         * @param {string} organizationId The unique identifier of the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationUserConsentOrganization(id: string, userId: string, organizationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplicationUserConsentOrganization(id, userId, organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove the user consent scope from an application by application id, scope type and scope id
         * @summary Remove user consent scope from application.
         * @param {string} applicationId The unique identifier of the application.
         * @param {DeleteApplicationUserConsentScopeScopeTypeEnum} scopeType 
         * @param {string} scopeId The unique identifier of the scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicationUserConsentScope(applicationId: string, scopeType: DeleteApplicationUserConsentScopeScopeTypeEnum, scopeId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplicationUserConsentScope(applicationId, scopeType, scopeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get application details by ID.
         * @summary Get application
         * @param {string} id The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication(id: string, options?: any): AxiosPromise<GetApplication200Response> {
            return localVarFp.getApplication(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get application level sign-in experience for a given application.   - Only branding properties and terms links customization is supported for now.    - Only third-party applications can have the sign-in experience customization for now.
         * @summary Get the application level sign-in experience
         * @param {string} applicationId The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationSignInExperience(applicationId: string, options?: any): AxiosPromise<GetApplicationSignInExperience200Response> {
            return localVarFp.getApplicationSignInExperience(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the list of organizations that an application is associated with.
         * @summary Get application organizations
         * @param {string} id The unique identifier of the application.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationOrganizations(id: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ListApplicationOrganizations200ResponseInner>> {
            return localVarFp.listApplicationOrganizations(id, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the list of custom domains of the protected application. This feature is not available for open source version.
         * @summary Get the list of custom domains of the protected application.
         * @param {string} id The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationProtectedAppMetadataCustomDomains(id: string, options?: any): AxiosPromise<Array<ListApplications200ResponseInnerProtectedAppMetadataCustomDomainsInner>> {
            return localVarFp.listApplicationProtectedAppMetadataCustomDomains(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get API resource roles assigned to the specified application with pagination.
         * @summary Get application API resource roles
         * @param {string} applicationId The unique identifier of the application.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationRoles(applicationId: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ListApplicationRoles200ResponseInner>> {
            return localVarFp.listApplicationRoles(applicationId, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the user consented organizations for a application by application id and user id.
         * @summary List all the user consented organizations of a application.
         * @param {string} id The unique identifier of the application.
         * @param {string} userId The unique identifier of the user.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationUserConsentOrganizations(id: string, userId: string, page?: number, pageSize?: number, options?: any): AxiosPromise<ListApplicationUserConsentOrganizations200Response> {
            return localVarFp.listApplicationUserConsentOrganizations(id, userId, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * List all the user consent scopes of an application by application id
         * @summary List all the user consent scopes of an application.
         * @param {string} applicationId The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicationUserConsentScopes(applicationId: string, options?: any): AxiosPromise<ListApplicationUserConsentScopes200Response> {
            return localVarFp.listApplicationUserConsentScopes(applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get applications that match the given query with pagination.
         * @summary Get applications
         * @param {ListApplicationsTypesParameter} [types] An array of application types to filter applications.
         * @param {string} [excludeRoleId] 
         * @param {string} [excludeOrganizationId] 
         * @param {ListApplicationsIsThirdPartyParameter} [isThirdParty] 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplications(types?: ListApplicationsTypesParameter, excludeRoleId?: string, excludeOrganizationId?: string, isThirdParty?: ListApplicationsIsThirdPartyParameter, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ListApplications200ResponseInner>> {
            return localVarFp.listApplications(types, excludeRoleId, excludeOrganizationId, isThirdParty, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Update API resource roles assigned to the specified application. This will replace the existing API resource roles.
         * @summary Update API resource roles for application
         * @param {string} applicationId The unique identifier of the application.
         * @param {ReplaceApplicationRolesRequest} replaceApplicationRolesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceApplicationRoles(applicationId: string, replaceApplicationRolesRequest: ReplaceApplicationRolesRequest, options?: any): AxiosPromise<void> {
            return localVarFp.replaceApplicationRoles(applicationId, replaceApplicationRolesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update application level sign-in experience for the specified application. Create a new sign-in experience if it does not exist.   - Only branding properties and terms links customization is supported for now.    - Only third-party applications can be customized for now.    - Application level sign-in experience customization is optional, if provided, it will override the default branding and terms links.
         * @summary Update application level sign-in experience
         * @param {string} applicationId The unique identifier of the application.
         * @param {ReplaceApplicationSignInExperienceRequest} replaceApplicationSignInExperienceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceApplicationSignInExperience(applicationId: string, replaceApplicationSignInExperienceRequest: ReplaceApplicationSignInExperienceRequest, options?: any): AxiosPromise<GetApplicationSignInExperience200Response> {
            return localVarFp.replaceApplicationSignInExperience(applicationId, replaceApplicationSignInExperienceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Grant a list of organization access of a user for a application by application id and user id. <br/> The user must be a member of all the organizations. <br/> Only third-party application needs to be granted access to organizations, all the other applications can request for all the organizations\' access by default.
         * @summary Grant a list of organization access of a user for a application.
         * @param {string} id The unique identifier of the application.
         * @param {string} userId The unique identifier of the user.
         * @param {ReplaceApplicationUserConsentOrganizationsRequest} replaceApplicationUserConsentOrganizationsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceApplicationUserConsentOrganizations(id: string, userId: string, replaceApplicationUserConsentOrganizationsRequest: ReplaceApplicationUserConsentOrganizationsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.replaceApplicationUserConsentOrganizations(id, userId, replaceApplicationUserConsentOrganizationsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update application details by ID with the given data.
         * @summary Update application
         * @param {string} id The unique identifier of the application.
         * @param {UpdateApplicationRequest} updateApplicationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplication(id: string, updateApplicationRequest: UpdateApplicationRequest, options?: any): AxiosPromise<ListApplications200ResponseInner> {
            return localVarFp.updateApplication(id, updateApplicationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationsApi - object-oriented interface
 * @export
 * @class ApplicationsApi
 * @extends {BaseAPI}
 */
export class ApplicationsApi extends BaseAPI {
    /**
     * Assign API resource roles to the specified application. The API resource roles will be added to the existing API resource roles.
     * @summary Assign API resource roles to application
     * @param {string} applicationId The unique identifier of the application.
     * @param {AssignApplicationRolesRequest} assignApplicationRolesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public assignApplicationRoles(applicationId: string, assignApplicationRolesRequest: AssignApplicationRolesRequest, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).assignApplicationRoles(applicationId, assignApplicationRolesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new application with the given data.
     * @summary Create an application
     * @param {CreateApplicationRequest} createApplicationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public createApplication(createApplicationRequest: CreateApplicationRequest, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).createApplication(createApplicationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a custom domain to the protected application. You\'ll need to setup DNS record later. This feature is not available for open source version.
     * @summary Add a custom domain to the protected application.
     * @param {string} id The unique identifier of the application.
     * @param {CreateApplicationProtectedAppMetadataCustomDomainRequest} createApplicationProtectedAppMetadataCustomDomainRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public createApplicationProtectedAppMetadataCustomDomain(id: string, createApplicationProtectedAppMetadataCustomDomainRequest: CreateApplicationProtectedAppMetadataCustomDomainRequest, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).createApplicationProtectedAppMetadataCustomDomain(id, createApplicationProtectedAppMetadataCustomDomainRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Grant a list of organization access of a user for a application by application id and user id. <br/> The user must be a member of all the organizations. <br/> Only third-party application needs to be granted access to organizations, all the other applications can request for all the organizations\' access by default.
     * @summary Grant a list of organization access of a user for a application.
     * @param {string} id The unique identifier of the application.
     * @param {string} userId The unique identifier of the user.
     * @param {CreateApplicationUserConsentOrganizationRequest} createApplicationUserConsentOrganizationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public createApplicationUserConsentOrganization(id: string, userId: string, createApplicationUserConsentOrganizationRequest: CreateApplicationUserConsentOrganizationRequest, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).createApplicationUserConsentOrganization(id, userId, createApplicationUserConsentOrganizationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assign the user consent scopes to an application by application id
     * @summary Assign user consent scopes to application.
     * @param {string} applicationId The unique identifier of the application.
     * @param {CreateApplicationUserConsentScopeRequest} createApplicationUserConsentScopeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public createApplicationUserConsentScope(applicationId: string, createApplicationUserConsentScopeRequest: CreateApplicationUserConsentScopeRequest, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).createApplicationUserConsentScope(applicationId, createApplicationUserConsentScopeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete application by ID.
     * @summary Delete application
     * @param {string} id The unique identifier of the application.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public deleteApplication(id: string, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).deleteApplication(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a custom domain. This feature is not available for open source version.
     * @summary Delete a custom domain.
     * @param {string} id The unique identifier of the application.
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public deleteApplicationProtectedAppMetadataCustomDomain(id: string, domain: string, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).deleteApplicationProtectedAppMetadataCustomDomain(id, domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a API resource role from the specified application.
     * @summary Remove a API resource role from application
     * @param {string} applicationId The unique identifier of the application.
     * @param {string} roleId The unique identifier of the role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public deleteApplicationRole(applicationId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).deleteApplicationRole(applicationId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke a user\'s access to an organization for a application by application id, user id and organization id.
     * @summary Revoke a user\'s access to an organization for a application.
     * @param {string} id The unique identifier of the application.
     * @param {string} userId The unique identifier of the user.
     * @param {string} organizationId The unique identifier of the organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public deleteApplicationUserConsentOrganization(id: string, userId: string, organizationId: string, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).deleteApplicationUserConsentOrganization(id, userId, organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove the user consent scope from an application by application id, scope type and scope id
     * @summary Remove user consent scope from application.
     * @param {string} applicationId The unique identifier of the application.
     * @param {DeleteApplicationUserConsentScopeScopeTypeEnum} scopeType 
     * @param {string} scopeId The unique identifier of the scope.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public deleteApplicationUserConsentScope(applicationId: string, scopeType: DeleteApplicationUserConsentScopeScopeTypeEnum, scopeId: string, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).deleteApplicationUserConsentScope(applicationId, scopeType, scopeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get application details by ID.
     * @summary Get application
     * @param {string} id The unique identifier of the application.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getApplication(id: string, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getApplication(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get application level sign-in experience for a given application.   - Only branding properties and terms links customization is supported for now.    - Only third-party applications can have the sign-in experience customization for now.
     * @summary Get the application level sign-in experience
     * @param {string} applicationId The unique identifier of the application.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public getApplicationSignInExperience(applicationId: string, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).getApplicationSignInExperience(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the list of organizations that an application is associated with.
     * @summary Get application organizations
     * @param {string} id The unique identifier of the application.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public listApplicationOrganizations(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).listApplicationOrganizations(id, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the list of custom domains of the protected application. This feature is not available for open source version.
     * @summary Get the list of custom domains of the protected application.
     * @param {string} id The unique identifier of the application.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public listApplicationProtectedAppMetadataCustomDomains(id: string, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).listApplicationProtectedAppMetadataCustomDomains(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get API resource roles assigned to the specified application with pagination.
     * @summary Get application API resource roles
     * @param {string} applicationId The unique identifier of the application.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public listApplicationRoles(applicationId: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).listApplicationRoles(applicationId, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all the user consented organizations for a application by application id and user id.
     * @summary List all the user consented organizations of a application.
     * @param {string} id The unique identifier of the application.
     * @param {string} userId The unique identifier of the user.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public listApplicationUserConsentOrganizations(id: string, userId: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).listApplicationUserConsentOrganizations(id, userId, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all the user consent scopes of an application by application id
     * @summary List all the user consent scopes of an application.
     * @param {string} applicationId The unique identifier of the application.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public listApplicationUserConsentScopes(applicationId: string, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).listApplicationUserConsentScopes(applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get applications that match the given query with pagination.
     * @summary Get applications
     * @param {ListApplicationsTypesParameter} [types] An array of application types to filter applications.
     * @param {string} [excludeRoleId] 
     * @param {string} [excludeOrganizationId] 
     * @param {ListApplicationsIsThirdPartyParameter} [isThirdParty] 
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public listApplications(types?: ListApplicationsTypesParameter, excludeRoleId?: string, excludeOrganizationId?: string, isThirdParty?: ListApplicationsIsThirdPartyParameter, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).listApplications(types, excludeRoleId, excludeOrganizationId, isThirdParty, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update API resource roles assigned to the specified application. This will replace the existing API resource roles.
     * @summary Update API resource roles for application
     * @param {string} applicationId The unique identifier of the application.
     * @param {ReplaceApplicationRolesRequest} replaceApplicationRolesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public replaceApplicationRoles(applicationId: string, replaceApplicationRolesRequest: ReplaceApplicationRolesRequest, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).replaceApplicationRoles(applicationId, replaceApplicationRolesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update application level sign-in experience for the specified application. Create a new sign-in experience if it does not exist.   - Only branding properties and terms links customization is supported for now.    - Only third-party applications can be customized for now.    - Application level sign-in experience customization is optional, if provided, it will override the default branding and terms links.
     * @summary Update application level sign-in experience
     * @param {string} applicationId The unique identifier of the application.
     * @param {ReplaceApplicationSignInExperienceRequest} replaceApplicationSignInExperienceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public replaceApplicationSignInExperience(applicationId: string, replaceApplicationSignInExperienceRequest: ReplaceApplicationSignInExperienceRequest, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).replaceApplicationSignInExperience(applicationId, replaceApplicationSignInExperienceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Grant a list of organization access of a user for a application by application id and user id. <br/> The user must be a member of all the organizations. <br/> Only third-party application needs to be granted access to organizations, all the other applications can request for all the organizations\' access by default.
     * @summary Grant a list of organization access of a user for a application.
     * @param {string} id The unique identifier of the application.
     * @param {string} userId The unique identifier of the user.
     * @param {ReplaceApplicationUserConsentOrganizationsRequest} replaceApplicationUserConsentOrganizationsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public replaceApplicationUserConsentOrganizations(id: string, userId: string, replaceApplicationUserConsentOrganizationsRequest: ReplaceApplicationUserConsentOrganizationsRequest, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).replaceApplicationUserConsentOrganizations(id, userId, replaceApplicationUserConsentOrganizationsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update application details by ID with the given data.
     * @summary Update application
     * @param {string} id The unique identifier of the application.
     * @param {UpdateApplicationRequest} updateApplicationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationsApi
     */
    public updateApplication(id: string, updateApplicationRequest: UpdateApplicationRequest, options?: RawAxiosRequestConfig) {
        return ApplicationsApiFp(this.configuration).updateApplication(id, updateApplicationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeleteApplicationUserConsentScopeScopeTypeEnum = {
    OrganizationScopes: 'organization-scopes',
    ResourceScopes: 'resource-scopes',
    OrganizationResourceScopes: 'organization-resource-scopes',
    UserScopes: 'user-scopes'
} as const;
export type DeleteApplicationUserConsentScopeScopeTypeEnum = typeof DeleteApplicationUserConsentScopeScopeTypeEnum[keyof typeof DeleteApplicationUserConsentScopeScopeTypeEnum];


/**
 * AuditLogsApi - axios parameter creator
 * @export
 */
export const AuditLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get log details by ID.
         * @summary Get log
         * @param {string} id The unique identifier of the log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLog: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getLog', 'id', id)
            const localVarPath = `/api/logs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get logs that match the given query with pagination.
         * @summary Get logs
         * @param {string} [userId] Filter logs by user ID.
         * @param {string} [applicationId] Filter logs by application ID.
         * @param {string} [logKey] Filter logs by log key.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLogs: async (userId?: string, applicationId?: string, logKey?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (logKey !== undefined) {
                localVarQueryParameter['logKey'] = logKey;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuditLogsApi - functional programming interface
 * @export
 */
export const AuditLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuditLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get log details by ID.
         * @summary Get log
         * @param {string} id The unique identifier of the log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLog(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListLogs200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLog(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuditLogsApi.getLog']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get logs that match the given query with pagination.
         * @summary Get logs
         * @param {string} [userId] Filter logs by user ID.
         * @param {string} [applicationId] Filter logs by application ID.
         * @param {string} [logKey] Filter logs by log key.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLogs(userId?: string, applicationId?: string, logKey?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListLogs200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLogs(userId, applicationId, logKey, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuditLogsApi.listLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuditLogsApi - factory interface
 * @export
 */
export const AuditLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuditLogsApiFp(configuration)
    return {
        /**
         * Get log details by ID.
         * @summary Get log
         * @param {string} id The unique identifier of the log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLog(id: string, options?: any): AxiosPromise<ListLogs200ResponseInner> {
            return localVarFp.getLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get logs that match the given query with pagination.
         * @summary Get logs
         * @param {string} [userId] Filter logs by user ID.
         * @param {string} [applicationId] Filter logs by application ID.
         * @param {string} [logKey] Filter logs by log key.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLogs(userId?: string, applicationId?: string, logKey?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ListLogs200ResponseInner>> {
            return localVarFp.listLogs(userId, applicationId, logKey, page, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuditLogsApi - object-oriented interface
 * @export
 * @class AuditLogsApi
 * @extends {BaseAPI}
 */
export class AuditLogsApi extends BaseAPI {
    /**
     * Get log details by ID.
     * @summary Get log
     * @param {string} id The unique identifier of the log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogsApi
     */
    public getLog(id: string, options?: RawAxiosRequestConfig) {
        return AuditLogsApiFp(this.configuration).getLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get logs that match the given query with pagination.
     * @summary Get logs
     * @param {string} [userId] Filter logs by user ID.
     * @param {string} [applicationId] Filter logs by application ID.
     * @param {string} [logKey] Filter logs by log key.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogsApi
     */
    public listLogs(userId?: string, applicationId?: string, logKey?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return AuditLogsApiFp(this.configuration).listLogs(userId, applicationId, logKey, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthnApi - axios parameter creator
 * @export
 */
export const AuthnApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The Assertion Consumer Service (ACS) endpoint for Simple Assertion Markup Language (SAML) social connectors.  SAML social connectors are deprecated. Use the SSO SAML connector instead.
         * @summary SAML ACS endpoint (social)
         * @param {string} connectorId The unique identifier of the connector.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        assertSaml: async (connectorId: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('assertSaml', 'connectorId', connectorId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('assertSaml', 'body', body)
            const localVarPath = `/api/authn/saml/{connectorId}`
                .replace(`{${"connectorId"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Assertion Consumer Service (ACS) endpoint for Simple Assertion Markup Language (SAML) single sign-on (SSO) connectors.  This endpoint is used to complete the SAML SSO authentication flow. It receives the SAML assertion response from the identity provider (IdP) and redirects the user to complete the authentication flow.
         * @summary SAML ACS endpoint (SSO)
         * @param {string} connectorId The unique identifier of the connector.
         * @param {AssertSingleSignOnSamlRequest} assertSingleSignOnSamlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assertSingleSignOnSaml: async (connectorId: string, assertSingleSignOnSamlRequest: AssertSingleSignOnSamlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('assertSingleSignOnSaml', 'connectorId', connectorId)
            // verify required parameter 'assertSingleSignOnSamlRequest' is not null or undefined
            assertParamExists('assertSingleSignOnSaml', 'assertSingleSignOnSamlRequest', assertSingleSignOnSamlRequest)
            const localVarPath = `/api/authn/single-sign-on/saml/{connectorId}`
                .replace(`{${"connectorId"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assertSingleSignOnSamlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The `HASURA_GRAPHQL_AUTH_HOOK` endpoint for Hasura auth. Use this endpoint to integrate Hasura\'s [webhook authentication flow](https://hasura.io/docs/latest/auth/authentication/webhook/).
         * @summary Hasura auth hook endpoint
         * @param {string} resource 
         * @param {string} [unauthorizedRole] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHasuraAuth: async (resource: string, unauthorizedRole?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resource' is not null or undefined
            assertParamExists('getHasuraAuth', 'resource', resource)
            const localVarPath = `/api/authn/hasura`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (resource !== undefined) {
                localVarQueryParameter['resource'] = resource;
            }

            if (unauthorizedRole !== undefined) {
                localVarQueryParameter['unauthorizedRole'] = unauthorizedRole;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthnApi - functional programming interface
 * @export
 */
export const AuthnApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthnApiAxiosParamCreator(configuration)
    return {
        /**
         * The Assertion Consumer Service (ACS) endpoint for Simple Assertion Markup Language (SAML) social connectors.  SAML social connectors are deprecated. Use the SSO SAML connector instead.
         * @summary SAML ACS endpoint (social)
         * @param {string} connectorId The unique identifier of the connector.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async assertSaml(connectorId: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assertSaml(connectorId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthnApi.assertSaml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The Assertion Consumer Service (ACS) endpoint for Simple Assertion Markup Language (SAML) single sign-on (SSO) connectors.  This endpoint is used to complete the SAML SSO authentication flow. It receives the SAML assertion response from the identity provider (IdP) and redirects the user to complete the authentication flow.
         * @summary SAML ACS endpoint (SSO)
         * @param {string} connectorId The unique identifier of the connector.
         * @param {AssertSingleSignOnSamlRequest} assertSingleSignOnSamlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assertSingleSignOnSaml(connectorId: string, assertSingleSignOnSamlRequest: AssertSingleSignOnSamlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assertSingleSignOnSaml(connectorId, assertSingleSignOnSamlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthnApi.assertSingleSignOnSaml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The `HASURA_GRAPHQL_AUTH_HOOK` endpoint for Hasura auth. Use this endpoint to integrate Hasura\'s [webhook authentication flow](https://hasura.io/docs/latest/auth/authentication/webhook/).
         * @summary Hasura auth hook endpoint
         * @param {string} resource 
         * @param {string} [unauthorizedRole] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHasuraAuth(resource: string, unauthorizedRole?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetHasuraAuth200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHasuraAuth(resource, unauthorizedRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthnApi.getHasuraAuth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthnApi - factory interface
 * @export
 */
export const AuthnApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthnApiFp(configuration)
    return {
        /**
         * The Assertion Consumer Service (ACS) endpoint for Simple Assertion Markup Language (SAML) social connectors.  SAML social connectors are deprecated. Use the SSO SAML connector instead.
         * @summary SAML ACS endpoint (social)
         * @param {string} connectorId The unique identifier of the connector.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        assertSaml(connectorId: string, body: object, options?: any): AxiosPromise<void> {
            return localVarFp.assertSaml(connectorId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * The Assertion Consumer Service (ACS) endpoint for Simple Assertion Markup Language (SAML) single sign-on (SSO) connectors.  This endpoint is used to complete the SAML SSO authentication flow. It receives the SAML assertion response from the identity provider (IdP) and redirects the user to complete the authentication flow.
         * @summary SAML ACS endpoint (SSO)
         * @param {string} connectorId The unique identifier of the connector.
         * @param {AssertSingleSignOnSamlRequest} assertSingleSignOnSamlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assertSingleSignOnSaml(connectorId: string, assertSingleSignOnSamlRequest: AssertSingleSignOnSamlRequest, options?: any): AxiosPromise<void> {
            return localVarFp.assertSingleSignOnSaml(connectorId, assertSingleSignOnSamlRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The `HASURA_GRAPHQL_AUTH_HOOK` endpoint for Hasura auth. Use this endpoint to integrate Hasura\'s [webhook authentication flow](https://hasura.io/docs/latest/auth/authentication/webhook/).
         * @summary Hasura auth hook endpoint
         * @param {string} resource 
         * @param {string} [unauthorizedRole] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHasuraAuth(resource: string, unauthorizedRole?: string, options?: any): AxiosPromise<GetHasuraAuth200Response> {
            return localVarFp.getHasuraAuth(resource, unauthorizedRole, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthnApi - object-oriented interface
 * @export
 * @class AuthnApi
 * @extends {BaseAPI}
 */
export class AuthnApi extends BaseAPI {
    /**
     * The Assertion Consumer Service (ACS) endpoint for Simple Assertion Markup Language (SAML) social connectors.  SAML social connectors are deprecated. Use the SSO SAML connector instead.
     * @summary SAML ACS endpoint (social)
     * @param {string} connectorId The unique identifier of the connector.
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AuthnApi
     */
    public assertSaml(connectorId: string, body: object, options?: RawAxiosRequestConfig) {
        return AuthnApiFp(this.configuration).assertSaml(connectorId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The Assertion Consumer Service (ACS) endpoint for Simple Assertion Markup Language (SAML) single sign-on (SSO) connectors.  This endpoint is used to complete the SAML SSO authentication flow. It receives the SAML assertion response from the identity provider (IdP) and redirects the user to complete the authentication flow.
     * @summary SAML ACS endpoint (SSO)
     * @param {string} connectorId The unique identifier of the connector.
     * @param {AssertSingleSignOnSamlRequest} assertSingleSignOnSamlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthnApi
     */
    public assertSingleSignOnSaml(connectorId: string, assertSingleSignOnSamlRequest: AssertSingleSignOnSamlRequest, options?: RawAxiosRequestConfig) {
        return AuthnApiFp(this.configuration).assertSingleSignOnSaml(connectorId, assertSingleSignOnSamlRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The `HASURA_GRAPHQL_AUTH_HOOK` endpoint for Hasura auth. Use this endpoint to integrate Hasura\'s [webhook authentication flow](https://hasura.io/docs/latest/auth/authentication/webhook/).
     * @summary Hasura auth hook endpoint
     * @param {string} resource 
     * @param {string} [unauthorizedRole] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthnApi
     */
    public getHasuraAuth(resource: string, unauthorizedRole?: string, options?: RawAxiosRequestConfig) {
        return AuthnApiFp(this.configuration).getHasuraAuth(resource, unauthorizedRole, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConfigsApi - axios parameter creator
 * @export
 */
export const ConfigsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete the JWT customizer for the given token type.
         * @summary Delete JWT customizer
         * @param {DeleteJwtCustomizerTokenTypePathEnum} tokenTypePath The token type path to delete the JWT customizer for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJwtCustomizer: async (tokenTypePath: DeleteJwtCustomizerTokenTypePathEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenTypePath' is not null or undefined
            assertParamExists('deleteJwtCustomizer', 'tokenTypePath', tokenTypePath)
            const localVarPath = `/api/configs/jwt-customizer/{tokenTypePath}`
                .replace(`{${"tokenTypePath"}}`, encodeURIComponent(String(tokenTypePath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an OIDC signing key by key type and key ID.
         * @summary Delete OIDC key
         * @param {DeleteOidcKeyKeyTypeEnum} keyType Private keys are used to sign OIDC JWTs. Cookie keys are used to sign OIDC cookies. For clients, they do not need to know private keys to verify OIDC JWTs; they can use public keys from the JWKS endpoint instead.
         * @param {string} keyId The unique identifier of the key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOidcKey: async (keyType: DeleteOidcKeyKeyTypeEnum, keyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyType' is not null or undefined
            assertParamExists('deleteOidcKey', 'keyType', keyType)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('deleteOidcKey', 'keyId', keyId)
            const localVarPath = `/api/configs/oidc/{keyType}/{keyId}`
                .replace(`{${"keyType"}}`, encodeURIComponent(String(keyType)))
                .replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the global configuration object for Logto Console.
         * @summary Get admin console config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdminConsoleConfig: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/configs/admin-console`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the JWT customizer for the given token type.
         * @summary Get JWT customizer
         * @param {GetJwtCustomizerTokenTypePathEnum} tokenTypePath The token type to get the JWT customizer for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJwtCustomizer: async (tokenTypePath: GetJwtCustomizerTokenTypePathEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenTypePath' is not null or undefined
            assertParamExists('getJwtCustomizer', 'tokenTypePath', tokenTypePath)
            const localVarPath = `/api/configs/jwt-customizer/{tokenTypePath}`
                .replace(`{${"tokenTypePath"}}`, encodeURIComponent(String(tokenTypePath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get OIDC signing keys by key type. The actual key will be redacted from the result.
         * @summary Get OIDC keys
         * @param {GetOidcKeysKeyTypeEnum} keyType Private keys are used to sign OIDC JWTs. Cookie keys are used to sign OIDC cookies. For clients, they do not need to know private keys to verify OIDC JWTs; they can use public keys from the JWKS endpoint instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOidcKeys: async (keyType: GetOidcKeysKeyTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyType' is not null or undefined
            assertParamExists('getOidcKeys', 'keyType', keyType)
            const localVarPath = `/api/configs/oidc/{keyType}`
                .replace(`{${"keyType"}}`, encodeURIComponent(String(keyType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all JWT customizers for the tenant.
         * @summary Get all JWT customizers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJwtCustomizers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/configs/jwt-customizer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A new key will be generated and prepend to the list of keys.  Only two recent keys will be kept. The oldest key will be automatically removed if there are more than two keys.
         * @summary Rotate OIDC keys
         * @param {RotateOidcKeysKeyTypeEnum} keyType Private keys are used to sign OIDC JWTs. Cookie keys are used to sign OIDC cookies. For clients, they do not need to know private keys to verify OIDC JWTs; they can use public keys from the JWKS endpoint instead.
         * @param {RotateOidcKeysRequest} rotateOidcKeysRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rotateOidcKeys: async (keyType: RotateOidcKeysKeyTypeEnum, rotateOidcKeysRequest: RotateOidcKeysRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyType' is not null or undefined
            assertParamExists('rotateOidcKeys', 'keyType', keyType)
            // verify required parameter 'rotateOidcKeysRequest' is not null or undefined
            assertParamExists('rotateOidcKeys', 'rotateOidcKeysRequest', rotateOidcKeysRequest)
            const localVarPath = `/api/configs/oidc/{keyType}/rotate`
                .replace(`{${"keyType"}}`, encodeURIComponent(String(keyType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rotateOidcKeysRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test the JWT customizer script with the given sample context and sample token payload.
         * @summary Test JWT customizer
         * @param {TestJwtCustomizerRequest} testJwtCustomizerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testJwtCustomizer: async (testJwtCustomizerRequest: TestJwtCustomizerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testJwtCustomizerRequest' is not null or undefined
            assertParamExists('testJwtCustomizer', 'testJwtCustomizerRequest', testJwtCustomizerRequest)
            const localVarPath = `/api/configs/jwt-customizer/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testJwtCustomizerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the global configuration object for Logto Console. This method performs a partial update.
         * @summary Update admin console config
         * @param {UpdateAdminConsoleConfigRequest} updateAdminConsoleConfigRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAdminConsoleConfig: async (updateAdminConsoleConfigRequest: UpdateAdminConsoleConfigRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateAdminConsoleConfigRequest' is not null or undefined
            assertParamExists('updateAdminConsoleConfig', 'updateAdminConsoleConfigRequest', updateAdminConsoleConfigRequest)
            const localVarPath = `/api/configs/admin-console`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAdminConsoleConfigRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the JWT customizer for the given token type.
         * @summary Update JWT customizer
         * @param {UpdateJwtCustomizerTokenTypePathEnum} tokenTypePath The token type to update a JWT customizer for.
         * @param {UpsertJwtCustomizerRequest} upsertJwtCustomizerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJwtCustomizer: async (tokenTypePath: UpdateJwtCustomizerTokenTypePathEnum, upsertJwtCustomizerRequest: UpsertJwtCustomizerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenTypePath' is not null or undefined
            assertParamExists('updateJwtCustomizer', 'tokenTypePath', tokenTypePath)
            // verify required parameter 'upsertJwtCustomizerRequest' is not null or undefined
            assertParamExists('updateJwtCustomizer', 'upsertJwtCustomizerRequest', upsertJwtCustomizerRequest)
            const localVarPath = `/api/configs/jwt-customizer/{tokenTypePath}`
                .replace(`{${"tokenTypePath"}}`, encodeURIComponent(String(tokenTypePath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upsertJwtCustomizerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update a JWT customizer for the given token type.
         * @summary Create or update JWT customizer
         * @param {UpsertJwtCustomizerTokenTypePathEnum} tokenTypePath The token type to create a JWT customizer for.
         * @param {UpsertJwtCustomizerRequest} upsertJwtCustomizerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertJwtCustomizer: async (tokenTypePath: UpsertJwtCustomizerTokenTypePathEnum, upsertJwtCustomizerRequest: UpsertJwtCustomizerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenTypePath' is not null or undefined
            assertParamExists('upsertJwtCustomizer', 'tokenTypePath', tokenTypePath)
            // verify required parameter 'upsertJwtCustomizerRequest' is not null or undefined
            assertParamExists('upsertJwtCustomizer', 'upsertJwtCustomizerRequest', upsertJwtCustomizerRequest)
            const localVarPath = `/api/configs/jwt-customizer/{tokenTypePath}`
                .replace(`{${"tokenTypePath"}}`, encodeURIComponent(String(tokenTypePath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upsertJwtCustomizerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigsApi - functional programming interface
 * @export
 */
export const ConfigsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConfigsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete the JWT customizer for the given token type.
         * @summary Delete JWT customizer
         * @param {DeleteJwtCustomizerTokenTypePathEnum} tokenTypePath The token type path to delete the JWT customizer for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteJwtCustomizer(tokenTypePath: DeleteJwtCustomizerTokenTypePathEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJwtCustomizer(tokenTypePath, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigsApi.deleteJwtCustomizer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an OIDC signing key by key type and key ID.
         * @summary Delete OIDC key
         * @param {DeleteOidcKeyKeyTypeEnum} keyType Private keys are used to sign OIDC JWTs. Cookie keys are used to sign OIDC cookies. For clients, they do not need to know private keys to verify OIDC JWTs; they can use public keys from the JWKS endpoint instead.
         * @param {string} keyId The unique identifier of the key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOidcKey(keyType: DeleteOidcKeyKeyTypeEnum, keyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOidcKey(keyType, keyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigsApi.deleteOidcKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the global configuration object for Logto Console.
         * @summary Get admin console config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdminConsoleConfig(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAdminConsoleConfig200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAdminConsoleConfig(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigsApi.getAdminConsoleConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the JWT customizer for the given token type.
         * @summary Get JWT customizer
         * @param {GetJwtCustomizerTokenTypePathEnum} tokenTypePath The token type to get the JWT customizer for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJwtCustomizer(tokenTypePath: GetJwtCustomizerTokenTypePathEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetJwtCustomizer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJwtCustomizer(tokenTypePath, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigsApi.getJwtCustomizer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get OIDC signing keys by key type. The actual key will be redacted from the result.
         * @summary Get OIDC keys
         * @param {GetOidcKeysKeyTypeEnum} keyType Private keys are used to sign OIDC JWTs. Cookie keys are used to sign OIDC cookies. For clients, they do not need to know private keys to verify OIDC JWTs; they can use public keys from the JWKS endpoint instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOidcKeys(keyType: GetOidcKeysKeyTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOidcKeys200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOidcKeys(keyType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigsApi.getOidcKeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all JWT customizers for the tenant.
         * @summary Get all JWT customizers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listJwtCustomizers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListJwtCustomizers200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listJwtCustomizers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigsApi.listJwtCustomizers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A new key will be generated and prepend to the list of keys.  Only two recent keys will be kept. The oldest key will be automatically removed if there are more than two keys.
         * @summary Rotate OIDC keys
         * @param {RotateOidcKeysKeyTypeEnum} keyType Private keys are used to sign OIDC JWTs. Cookie keys are used to sign OIDC cookies. For clients, they do not need to know private keys to verify OIDC JWTs; they can use public keys from the JWKS endpoint instead.
         * @param {RotateOidcKeysRequest} rotateOidcKeysRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rotateOidcKeys(keyType: RotateOidcKeysKeyTypeEnum, rotateOidcKeysRequest: RotateOidcKeysRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOidcKeys200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rotateOidcKeys(keyType, rotateOidcKeysRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigsApi.rotateOidcKeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test the JWT customizer script with the given sample context and sample token payload.
         * @summary Test JWT customizer
         * @param {TestJwtCustomizerRequest} testJwtCustomizerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testJwtCustomizer(testJwtCustomizerRequest: TestJwtCustomizerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testJwtCustomizer(testJwtCustomizerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigsApi.testJwtCustomizer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the global configuration object for Logto Console. This method performs a partial update.
         * @summary Update admin console config
         * @param {UpdateAdminConsoleConfigRequest} updateAdminConsoleConfigRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAdminConsoleConfig(updateAdminConsoleConfigRequest: UpdateAdminConsoleConfigRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAdminConsoleConfig200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAdminConsoleConfig(updateAdminConsoleConfigRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigsApi.updateAdminConsoleConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the JWT customizer for the given token type.
         * @summary Update JWT customizer
         * @param {UpdateJwtCustomizerTokenTypePathEnum} tokenTypePath The token type to update a JWT customizer for.
         * @param {UpsertJwtCustomizerRequest} upsertJwtCustomizerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateJwtCustomizer(tokenTypePath: UpdateJwtCustomizerTokenTypePathEnum, upsertJwtCustomizerRequest: UpsertJwtCustomizerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetJwtCustomizer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateJwtCustomizer(tokenTypePath, upsertJwtCustomizerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigsApi.updateJwtCustomizer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or update a JWT customizer for the given token type.
         * @summary Create or update JWT customizer
         * @param {UpsertJwtCustomizerTokenTypePathEnum} tokenTypePath The token type to create a JWT customizer for.
         * @param {UpsertJwtCustomizerRequest} upsertJwtCustomizerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsertJwtCustomizer(tokenTypePath: UpsertJwtCustomizerTokenTypePathEnum, upsertJwtCustomizerRequest: UpsertJwtCustomizerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetJwtCustomizer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upsertJwtCustomizer(tokenTypePath, upsertJwtCustomizerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConfigsApi.upsertJwtCustomizer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConfigsApi - factory interface
 * @export
 */
export const ConfigsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConfigsApiFp(configuration)
    return {
        /**
         * Delete the JWT customizer for the given token type.
         * @summary Delete JWT customizer
         * @param {DeleteJwtCustomizerTokenTypePathEnum} tokenTypePath The token type path to delete the JWT customizer for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJwtCustomizer(tokenTypePath: DeleteJwtCustomizerTokenTypePathEnum, options?: any): AxiosPromise<void> {
            return localVarFp.deleteJwtCustomizer(tokenTypePath, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an OIDC signing key by key type and key ID.
         * @summary Delete OIDC key
         * @param {DeleteOidcKeyKeyTypeEnum} keyType Private keys are used to sign OIDC JWTs. Cookie keys are used to sign OIDC cookies. For clients, they do not need to know private keys to verify OIDC JWTs; they can use public keys from the JWKS endpoint instead.
         * @param {string} keyId The unique identifier of the key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOidcKey(keyType: DeleteOidcKeyKeyTypeEnum, keyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOidcKey(keyType, keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the global configuration object for Logto Console.
         * @summary Get admin console config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdminConsoleConfig(options?: any): AxiosPromise<GetAdminConsoleConfig200Response> {
            return localVarFp.getAdminConsoleConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the JWT customizer for the given token type.
         * @summary Get JWT customizer
         * @param {GetJwtCustomizerTokenTypePathEnum} tokenTypePath The token type to get the JWT customizer for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJwtCustomizer(tokenTypePath: GetJwtCustomizerTokenTypePathEnum, options?: any): AxiosPromise<GetJwtCustomizer200Response> {
            return localVarFp.getJwtCustomizer(tokenTypePath, options).then((request) => request(axios, basePath));
        },
        /**
         * Get OIDC signing keys by key type. The actual key will be redacted from the result.
         * @summary Get OIDC keys
         * @param {GetOidcKeysKeyTypeEnum} keyType Private keys are used to sign OIDC JWTs. Cookie keys are used to sign OIDC cookies. For clients, they do not need to know private keys to verify OIDC JWTs; they can use public keys from the JWKS endpoint instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOidcKeys(keyType: GetOidcKeysKeyTypeEnum, options?: any): AxiosPromise<Array<GetOidcKeys200ResponseInner>> {
            return localVarFp.getOidcKeys(keyType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all JWT customizers for the tenant.
         * @summary Get all JWT customizers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJwtCustomizers(options?: any): AxiosPromise<Array<ListJwtCustomizers200ResponseInner>> {
            return localVarFp.listJwtCustomizers(options).then((request) => request(axios, basePath));
        },
        /**
         * A new key will be generated and prepend to the list of keys.  Only two recent keys will be kept. The oldest key will be automatically removed if there are more than two keys.
         * @summary Rotate OIDC keys
         * @param {RotateOidcKeysKeyTypeEnum} keyType Private keys are used to sign OIDC JWTs. Cookie keys are used to sign OIDC cookies. For clients, they do not need to know private keys to verify OIDC JWTs; they can use public keys from the JWKS endpoint instead.
         * @param {RotateOidcKeysRequest} rotateOidcKeysRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rotateOidcKeys(keyType: RotateOidcKeysKeyTypeEnum, rotateOidcKeysRequest: RotateOidcKeysRequest, options?: any): AxiosPromise<Array<GetOidcKeys200ResponseInner>> {
            return localVarFp.rotateOidcKeys(keyType, rotateOidcKeysRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Test the JWT customizer script with the given sample context and sample token payload.
         * @summary Test JWT customizer
         * @param {TestJwtCustomizerRequest} testJwtCustomizerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testJwtCustomizer(testJwtCustomizerRequest: TestJwtCustomizerRequest, options?: any): AxiosPromise<object> {
            return localVarFp.testJwtCustomizer(testJwtCustomizerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the global configuration object for Logto Console. This method performs a partial update.
         * @summary Update admin console config
         * @param {UpdateAdminConsoleConfigRequest} updateAdminConsoleConfigRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAdminConsoleConfig(updateAdminConsoleConfigRequest: UpdateAdminConsoleConfigRequest, options?: any): AxiosPromise<GetAdminConsoleConfig200Response> {
            return localVarFp.updateAdminConsoleConfig(updateAdminConsoleConfigRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the JWT customizer for the given token type.
         * @summary Update JWT customizer
         * @param {UpdateJwtCustomizerTokenTypePathEnum} tokenTypePath The token type to update a JWT customizer for.
         * @param {UpsertJwtCustomizerRequest} upsertJwtCustomizerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateJwtCustomizer(tokenTypePath: UpdateJwtCustomizerTokenTypePathEnum, upsertJwtCustomizerRequest: UpsertJwtCustomizerRequest, options?: any): AxiosPromise<GetJwtCustomizer200Response> {
            return localVarFp.updateJwtCustomizer(tokenTypePath, upsertJwtCustomizerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update a JWT customizer for the given token type.
         * @summary Create or update JWT customizer
         * @param {UpsertJwtCustomizerTokenTypePathEnum} tokenTypePath The token type to create a JWT customizer for.
         * @param {UpsertJwtCustomizerRequest} upsertJwtCustomizerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertJwtCustomizer(tokenTypePath: UpsertJwtCustomizerTokenTypePathEnum, upsertJwtCustomizerRequest: UpsertJwtCustomizerRequest, options?: any): AxiosPromise<GetJwtCustomizer200Response> {
            return localVarFp.upsertJwtCustomizer(tokenTypePath, upsertJwtCustomizerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConfigsApi - object-oriented interface
 * @export
 * @class ConfigsApi
 * @extends {BaseAPI}
 */
export class ConfigsApi extends BaseAPI {
    /**
     * Delete the JWT customizer for the given token type.
     * @summary Delete JWT customizer
     * @param {DeleteJwtCustomizerTokenTypePathEnum} tokenTypePath The token type path to delete the JWT customizer for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public deleteJwtCustomizer(tokenTypePath: DeleteJwtCustomizerTokenTypePathEnum, options?: RawAxiosRequestConfig) {
        return ConfigsApiFp(this.configuration).deleteJwtCustomizer(tokenTypePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an OIDC signing key by key type and key ID.
     * @summary Delete OIDC key
     * @param {DeleteOidcKeyKeyTypeEnum} keyType Private keys are used to sign OIDC JWTs. Cookie keys are used to sign OIDC cookies. For clients, they do not need to know private keys to verify OIDC JWTs; they can use public keys from the JWKS endpoint instead.
     * @param {string} keyId The unique identifier of the key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public deleteOidcKey(keyType: DeleteOidcKeyKeyTypeEnum, keyId: string, options?: RawAxiosRequestConfig) {
        return ConfigsApiFp(this.configuration).deleteOidcKey(keyType, keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the global configuration object for Logto Console.
     * @summary Get admin console config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public getAdminConsoleConfig(options?: RawAxiosRequestConfig) {
        return ConfigsApiFp(this.configuration).getAdminConsoleConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the JWT customizer for the given token type.
     * @summary Get JWT customizer
     * @param {GetJwtCustomizerTokenTypePathEnum} tokenTypePath The token type to get the JWT customizer for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public getJwtCustomizer(tokenTypePath: GetJwtCustomizerTokenTypePathEnum, options?: RawAxiosRequestConfig) {
        return ConfigsApiFp(this.configuration).getJwtCustomizer(tokenTypePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get OIDC signing keys by key type. The actual key will be redacted from the result.
     * @summary Get OIDC keys
     * @param {GetOidcKeysKeyTypeEnum} keyType Private keys are used to sign OIDC JWTs. Cookie keys are used to sign OIDC cookies. For clients, they do not need to know private keys to verify OIDC JWTs; they can use public keys from the JWKS endpoint instead.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public getOidcKeys(keyType: GetOidcKeysKeyTypeEnum, options?: RawAxiosRequestConfig) {
        return ConfigsApiFp(this.configuration).getOidcKeys(keyType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all JWT customizers for the tenant.
     * @summary Get all JWT customizers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public listJwtCustomizers(options?: RawAxiosRequestConfig) {
        return ConfigsApiFp(this.configuration).listJwtCustomizers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A new key will be generated and prepend to the list of keys.  Only two recent keys will be kept. The oldest key will be automatically removed if there are more than two keys.
     * @summary Rotate OIDC keys
     * @param {RotateOidcKeysKeyTypeEnum} keyType Private keys are used to sign OIDC JWTs. Cookie keys are used to sign OIDC cookies. For clients, they do not need to know private keys to verify OIDC JWTs; they can use public keys from the JWKS endpoint instead.
     * @param {RotateOidcKeysRequest} rotateOidcKeysRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public rotateOidcKeys(keyType: RotateOidcKeysKeyTypeEnum, rotateOidcKeysRequest: RotateOidcKeysRequest, options?: RawAxiosRequestConfig) {
        return ConfigsApiFp(this.configuration).rotateOidcKeys(keyType, rotateOidcKeysRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test the JWT customizer script with the given sample context and sample token payload.
     * @summary Test JWT customizer
     * @param {TestJwtCustomizerRequest} testJwtCustomizerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public testJwtCustomizer(testJwtCustomizerRequest: TestJwtCustomizerRequest, options?: RawAxiosRequestConfig) {
        return ConfigsApiFp(this.configuration).testJwtCustomizer(testJwtCustomizerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the global configuration object for Logto Console. This method performs a partial update.
     * @summary Update admin console config
     * @param {UpdateAdminConsoleConfigRequest} updateAdminConsoleConfigRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public updateAdminConsoleConfig(updateAdminConsoleConfigRequest: UpdateAdminConsoleConfigRequest, options?: RawAxiosRequestConfig) {
        return ConfigsApiFp(this.configuration).updateAdminConsoleConfig(updateAdminConsoleConfigRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the JWT customizer for the given token type.
     * @summary Update JWT customizer
     * @param {UpdateJwtCustomizerTokenTypePathEnum} tokenTypePath The token type to update a JWT customizer for.
     * @param {UpsertJwtCustomizerRequest} upsertJwtCustomizerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public updateJwtCustomizer(tokenTypePath: UpdateJwtCustomizerTokenTypePathEnum, upsertJwtCustomizerRequest: UpsertJwtCustomizerRequest, options?: RawAxiosRequestConfig) {
        return ConfigsApiFp(this.configuration).updateJwtCustomizer(tokenTypePath, upsertJwtCustomizerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update a JWT customizer for the given token type.
     * @summary Create or update JWT customizer
     * @param {UpsertJwtCustomizerTokenTypePathEnum} tokenTypePath The token type to create a JWT customizer for.
     * @param {UpsertJwtCustomizerRequest} upsertJwtCustomizerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigsApi
     */
    public upsertJwtCustomizer(tokenTypePath: UpsertJwtCustomizerTokenTypePathEnum, upsertJwtCustomizerRequest: UpsertJwtCustomizerRequest, options?: RawAxiosRequestConfig) {
        return ConfigsApiFp(this.configuration).upsertJwtCustomizer(tokenTypePath, upsertJwtCustomizerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeleteJwtCustomizerTokenTypePathEnum = {
    AccessToken: 'access-token',
    ClientCredentials: 'client-credentials'
} as const;
export type DeleteJwtCustomizerTokenTypePathEnum = typeof DeleteJwtCustomizerTokenTypePathEnum[keyof typeof DeleteJwtCustomizerTokenTypePathEnum];
/**
 * @export
 */
export const DeleteOidcKeyKeyTypeEnum = {
    PrivateKeys: 'private-keys',
    CookieKeys: 'cookie-keys'
} as const;
export type DeleteOidcKeyKeyTypeEnum = typeof DeleteOidcKeyKeyTypeEnum[keyof typeof DeleteOidcKeyKeyTypeEnum];
/**
 * @export
 */
export const GetJwtCustomizerTokenTypePathEnum = {
    AccessToken: 'access-token',
    ClientCredentials: 'client-credentials'
} as const;
export type GetJwtCustomizerTokenTypePathEnum = typeof GetJwtCustomizerTokenTypePathEnum[keyof typeof GetJwtCustomizerTokenTypePathEnum];
/**
 * @export
 */
export const GetOidcKeysKeyTypeEnum = {
    PrivateKeys: 'private-keys',
    CookieKeys: 'cookie-keys'
} as const;
export type GetOidcKeysKeyTypeEnum = typeof GetOidcKeysKeyTypeEnum[keyof typeof GetOidcKeysKeyTypeEnum];
/**
 * @export
 */
export const RotateOidcKeysKeyTypeEnum = {
    PrivateKeys: 'private-keys',
    CookieKeys: 'cookie-keys'
} as const;
export type RotateOidcKeysKeyTypeEnum = typeof RotateOidcKeysKeyTypeEnum[keyof typeof RotateOidcKeysKeyTypeEnum];
/**
 * @export
 */
export const UpdateJwtCustomizerTokenTypePathEnum = {
    AccessToken: 'access-token',
    ClientCredentials: 'client-credentials'
} as const;
export type UpdateJwtCustomizerTokenTypePathEnum = typeof UpdateJwtCustomizerTokenTypePathEnum[keyof typeof UpdateJwtCustomizerTokenTypePathEnum];
/**
 * @export
 */
export const UpsertJwtCustomizerTokenTypePathEnum = {
    AccessToken: 'access-token',
    ClientCredentials: 'client-credentials'
} as const;
export type UpsertJwtCustomizerTokenTypePathEnum = typeof UpsertJwtCustomizerTokenTypePathEnum[keyof typeof UpsertJwtCustomizerTokenTypePathEnum];


/**
 * ConnectorFactoriesApi - axios parameter creator
 * @export
 */
export const ConnectorFactoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get connector factory by the given ID.
         * @summary Get connector factory
         * @param {string} id The unique identifier of the connector factory.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorFactory: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getConnectorFactory', 'id', id)
            const localVarPath = `/api/connector-factories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all connector factories data available in Logto.
         * @summary Get connector factories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectorFactories: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/connector-factories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectorFactoriesApi - functional programming interface
 * @export
 */
export const ConnectorFactoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectorFactoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get connector factory by the given ID.
         * @summary Get connector factory
         * @param {string} id The unique identifier of the connector factory.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectorFactory(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListConnectorFactories200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectorFactory(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorFactoriesApi.getConnectorFactory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all connector factories data available in Logto.
         * @summary Get connector factories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConnectorFactories(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListConnectorFactories200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConnectorFactories(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorFactoriesApi.listConnectorFactories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConnectorFactoriesApi - factory interface
 * @export
 */
export const ConnectorFactoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectorFactoriesApiFp(configuration)
    return {
        /**
         * Get connector factory by the given ID.
         * @summary Get connector factory
         * @param {string} id The unique identifier of the connector factory.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorFactory(id: string, options?: any): AxiosPromise<ListConnectorFactories200ResponseInner> {
            return localVarFp.getConnectorFactory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all connector factories data available in Logto.
         * @summary Get connector factories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectorFactories(options?: any): AxiosPromise<Array<ListConnectorFactories200ResponseInner>> {
            return localVarFp.listConnectorFactories(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConnectorFactoriesApi - object-oriented interface
 * @export
 * @class ConnectorFactoriesApi
 * @extends {BaseAPI}
 */
export class ConnectorFactoriesApi extends BaseAPI {
    /**
     * Get connector factory by the given ID.
     * @summary Get connector factory
     * @param {string} id The unique identifier of the connector factory.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorFactoriesApi
     */
    public getConnectorFactory(id: string, options?: RawAxiosRequestConfig) {
        return ConnectorFactoriesApiFp(this.configuration).getConnectorFactory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all connector factories data available in Logto.
     * @summary Get connector factories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorFactoriesApi
     */
    public listConnectorFactories(options?: RawAxiosRequestConfig) {
        return ConnectorFactoriesApiFp(this.configuration).listConnectorFactories(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConnectorsApi - axios parameter creator
 * @export
 */
export const ConnectorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a connector with the given data.
         * @summary Create connector
         * @param {CreateConnectorRequest} createConnectorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnector: async (createConnectorRequest: CreateConnectorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createConnectorRequest' is not null or undefined
            assertParamExists('createConnector', 'createConnectorRequest', createConnectorRequest)
            const localVarPath = `/api/connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createConnectorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get authorization URI for specified connector by providing redirect URI and randomly generated state.
         * @summary Get connector\'s authorization URI
         * @param {string} connectorId The unique identifier of the connector.
         * @param {CreateConnectorAuthorizationUriRequest} createConnectorAuthorizationUriRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnectorAuthorizationUri: async (connectorId: string, createConnectorAuthorizationUriRequest: CreateConnectorAuthorizationUriRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('createConnectorAuthorizationUri', 'connectorId', connectorId)
            // verify required parameter 'createConnectorAuthorizationUriRequest' is not null or undefined
            assertParamExists('createConnectorAuthorizationUri', 'createConnectorAuthorizationUriRequest', createConnectorAuthorizationUriRequest)
            const localVarPath = `/api/connectors/{connectorId}/authorization-uri`
                .replace(`{${"connectorId"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createConnectorAuthorizationUriRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test a passwordless (email or SMS) connector by sending a test message to the given phone number or email address.
         * @summary Test passwordless connector
         * @param {string} factoryId The unique identifier of the factory.
         * @param {CreateConnectorTestRequest} createConnectorTestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnectorTest: async (factoryId: string, createConnectorTestRequest: CreateConnectorTestRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'factoryId' is not null or undefined
            assertParamExists('createConnectorTest', 'factoryId', factoryId)
            // verify required parameter 'createConnectorTestRequest' is not null or undefined
            assertParamExists('createConnectorTest', 'createConnectorTestRequest', createConnectorTestRequest)
            const localVarPath = `/api/connectors/{factoryId}/test`
                .replace(`{${"factoryId"}}`, encodeURIComponent(String(factoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createConnectorTestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete connector by ID.
         * @summary Delete connector
         * @param {string} id The unique identifier of the connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnector: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteConnector', 'id', id)
            const localVarPath = `/api/connectors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get connector data by ID
         * @summary Get connector
         * @param {string} id The unique identifier of the connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnector: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getConnector', 'id', id)
            const localVarPath = `/api/connectors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all connectors in the current tenant.
         * @summary Get connectors
         * @param {string} [target] Filter connectors by target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectors: async (target?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (target !== undefined) {
                localVarQueryParameter['target'] = target;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update connector by ID with the given data. This methods performs a partial update.
         * @summary Update connector
         * @param {string} id The unique identifier of the connector.
         * @param {UpdateConnectorRequest} updateConnectorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnector: async (id: string, updateConnectorRequest: UpdateConnectorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateConnector', 'id', id)
            // verify required parameter 'updateConnectorRequest' is not null or undefined
            assertParamExists('updateConnector', 'updateConnectorRequest', updateConnectorRequest)
            const localVarPath = `/api/connectors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateConnectorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectorsApi - functional programming interface
 * @export
 */
export const ConnectorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectorsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a connector with the given data.
         * @summary Create connector
         * @param {CreateConnectorRequest} createConnectorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConnector(createConnectorRequest: CreateConnectorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListConnectors200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConnector(createConnectorRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.createConnector']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get authorization URI for specified connector by providing redirect URI and randomly generated state.
         * @summary Get connector\'s authorization URI
         * @param {string} connectorId The unique identifier of the connector.
         * @param {CreateConnectorAuthorizationUriRequest} createConnectorAuthorizationUriRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConnectorAuthorizationUri(connectorId: string, createConnectorAuthorizationUriRequest: CreateConnectorAuthorizationUriRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateConnectorAuthorizationUri200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConnectorAuthorizationUri(connectorId, createConnectorAuthorizationUriRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.createConnectorAuthorizationUri']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test a passwordless (email or SMS) connector by sending a test message to the given phone number or email address.
         * @summary Test passwordless connector
         * @param {string} factoryId The unique identifier of the factory.
         * @param {CreateConnectorTestRequest} createConnectorTestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConnectorTest(factoryId: string, createConnectorTestRequest: CreateConnectorTestRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConnectorTest(factoryId, createConnectorTestRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.createConnectorTest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete connector by ID.
         * @summary Delete connector
         * @param {string} id The unique identifier of the connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConnector(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConnector(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.deleteConnector']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get connector data by ID
         * @summary Get connector
         * @param {string} id The unique identifier of the connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnector(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListConnectors200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnector(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.getConnector']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all connectors in the current tenant.
         * @summary Get connectors
         * @param {string} [target] Filter connectors by target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConnectors(target?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListConnectors200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConnectors(target, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.listConnectors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update connector by ID with the given data. This methods performs a partial update.
         * @summary Update connector
         * @param {string} id The unique identifier of the connector.
         * @param {UpdateConnectorRequest} updateConnectorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConnector(id: string, updateConnectorRequest: UpdateConnectorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListConnectors200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConnector(id, updateConnectorRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorsApi.updateConnector']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConnectorsApi - factory interface
 * @export
 */
export const ConnectorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectorsApiFp(configuration)
    return {
        /**
         * Create a connector with the given data.
         * @summary Create connector
         * @param {CreateConnectorRequest} createConnectorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnector(createConnectorRequest: CreateConnectorRequest, options?: any): AxiosPromise<ListConnectors200ResponseInner> {
            return localVarFp.createConnector(createConnectorRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get authorization URI for specified connector by providing redirect URI and randomly generated state.
         * @summary Get connector\'s authorization URI
         * @param {string} connectorId The unique identifier of the connector.
         * @param {CreateConnectorAuthorizationUriRequest} createConnectorAuthorizationUriRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnectorAuthorizationUri(connectorId: string, createConnectorAuthorizationUriRequest: CreateConnectorAuthorizationUriRequest, options?: any): AxiosPromise<CreateConnectorAuthorizationUri200Response> {
            return localVarFp.createConnectorAuthorizationUri(connectorId, createConnectorAuthorizationUriRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Test a passwordless (email or SMS) connector by sending a test message to the given phone number or email address.
         * @summary Test passwordless connector
         * @param {string} factoryId The unique identifier of the factory.
         * @param {CreateConnectorTestRequest} createConnectorTestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnectorTest(factoryId: string, createConnectorTestRequest: CreateConnectorTestRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createConnectorTest(factoryId, createConnectorTestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete connector by ID.
         * @summary Delete connector
         * @param {string} id The unique identifier of the connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnector(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteConnector(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get connector data by ID
         * @summary Get connector
         * @param {string} id The unique identifier of the connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnector(id: string, options?: any): AxiosPromise<ListConnectors200ResponseInner> {
            return localVarFp.getConnector(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all connectors in the current tenant.
         * @summary Get connectors
         * @param {string} [target] Filter connectors by target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectors(target?: string, options?: any): AxiosPromise<Array<ListConnectors200ResponseInner>> {
            return localVarFp.listConnectors(target, options).then((request) => request(axios, basePath));
        },
        /**
         * Update connector by ID with the given data. This methods performs a partial update.
         * @summary Update connector
         * @param {string} id The unique identifier of the connector.
         * @param {UpdateConnectorRequest} updateConnectorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnector(id: string, updateConnectorRequest: UpdateConnectorRequest, options?: any): AxiosPromise<ListConnectors200ResponseInner> {
            return localVarFp.updateConnector(id, updateConnectorRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConnectorsApi - object-oriented interface
 * @export
 * @class ConnectorsApi
 * @extends {BaseAPI}
 */
export class ConnectorsApi extends BaseAPI {
    /**
     * Create a connector with the given data.
     * @summary Create connector
     * @param {CreateConnectorRequest} createConnectorRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public createConnector(createConnectorRequest: CreateConnectorRequest, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).createConnector(createConnectorRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get authorization URI for specified connector by providing redirect URI and randomly generated state.
     * @summary Get connector\'s authorization URI
     * @param {string} connectorId The unique identifier of the connector.
     * @param {CreateConnectorAuthorizationUriRequest} createConnectorAuthorizationUriRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public createConnectorAuthorizationUri(connectorId: string, createConnectorAuthorizationUriRequest: CreateConnectorAuthorizationUriRequest, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).createConnectorAuthorizationUri(connectorId, createConnectorAuthorizationUriRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test a passwordless (email or SMS) connector by sending a test message to the given phone number or email address.
     * @summary Test passwordless connector
     * @param {string} factoryId The unique identifier of the factory.
     * @param {CreateConnectorTestRequest} createConnectorTestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public createConnectorTest(factoryId: string, createConnectorTestRequest: CreateConnectorTestRequest, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).createConnectorTest(factoryId, createConnectorTestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete connector by ID.
     * @summary Delete connector
     * @param {string} id The unique identifier of the connector.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public deleteConnector(id: string, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).deleteConnector(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get connector data by ID
     * @summary Get connector
     * @param {string} id The unique identifier of the connector.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public getConnector(id: string, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).getConnector(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all connectors in the current tenant.
     * @summary Get connectors
     * @param {string} [target] Filter connectors by target.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public listConnectors(target?: string, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).listConnectors(target, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update connector by ID with the given data. This methods performs a partial update.
     * @summary Update connector
     * @param {string} id The unique identifier of the connector.
     * @param {UpdateConnectorRequest} updateConnectorRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public updateConnector(id: string, updateConnectorRequest: UpdateConnectorRequest, options?: RawAxiosRequestConfig) {
        return ConnectorsApiFp(this.configuration).updateConnector(id, updateConnectorRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CustomPhrasesApi - axios parameter creator
 * @export
 */
export const CustomPhrasesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete custom phrases for the specified language tag.
         * @summary Delete custom phrase
         * @param {DeleteCustomPhraseLanguageTagEnum} languageTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomPhrase: async (languageTag: DeleteCustomPhraseLanguageTagEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'languageTag' is not null or undefined
            assertParamExists('deleteCustomPhrase', 'languageTag', languageTag)
            const localVarPath = `/api/custom-phrases/{languageTag}`
                .replace(`{${"languageTag"}}`, encodeURIComponent(String(languageTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get custom phrases for the specified language tag.
         * @summary Get custom phrases
         * @param {GetCustomPhraseLanguageTagEnum} languageTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomPhrase: async (languageTag: GetCustomPhraseLanguageTagEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'languageTag' is not null or undefined
            assertParamExists('getCustomPhrase', 'languageTag', languageTag)
            const localVarPath = `/api/custom-phrases/{languageTag}`
                .replace(`{${"languageTag"}}`, encodeURIComponent(String(languageTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all custom phrases for all languages.
         * @summary Get all custom phrases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomPhrases: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/custom-phrases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upsert custom phrases for the specified language tag. Upsert means that if the custom phrases already exist, they will be updated. Otherwise, they will be created.
         * @summary Upsert custom phrases
         * @param {ReplaceCustomPhraseLanguageTagEnum} languageTag 
         * @param {TranslationObject} translationObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceCustomPhrase: async (languageTag: ReplaceCustomPhraseLanguageTagEnum, translationObject: TranslationObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'languageTag' is not null or undefined
            assertParamExists('replaceCustomPhrase', 'languageTag', languageTag)
            // verify required parameter 'translationObject' is not null or undefined
            assertParamExists('replaceCustomPhrase', 'translationObject', translationObject)
            const localVarPath = `/api/custom-phrases/{languageTag}`
                .replace(`{${"languageTag"}}`, encodeURIComponent(String(languageTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(translationObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomPhrasesApi - functional programming interface
 * @export
 */
export const CustomPhrasesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomPhrasesApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete custom phrases for the specified language tag.
         * @summary Delete custom phrase
         * @param {DeleteCustomPhraseLanguageTagEnum} languageTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomPhrase(languageTag: DeleteCustomPhraseLanguageTagEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomPhrase(languageTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomPhrasesApi.deleteCustomPhrase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get custom phrases for the specified language tag.
         * @summary Get custom phrases
         * @param {GetCustomPhraseLanguageTagEnum} languageTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomPhrase(languageTag: GetCustomPhraseLanguageTagEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCustomPhrases200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomPhrase(languageTag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomPhrasesApi.getCustomPhrase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all custom phrases for all languages.
         * @summary Get all custom phrases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCustomPhrases(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListCustomPhrases200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCustomPhrases(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomPhrasesApi.listCustomPhrases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upsert custom phrases for the specified language tag. Upsert means that if the custom phrases already exist, they will be updated. Otherwise, they will be created.
         * @summary Upsert custom phrases
         * @param {ReplaceCustomPhraseLanguageTagEnum} languageTag 
         * @param {TranslationObject} translationObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaceCustomPhrase(languageTag: ReplaceCustomPhraseLanguageTagEnum, translationObject: TranslationObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceCustomPhrase(languageTag, translationObject, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomPhrasesApi.replaceCustomPhrase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CustomPhrasesApi - factory interface
 * @export
 */
export const CustomPhrasesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomPhrasesApiFp(configuration)
    return {
        /**
         * Delete custom phrases for the specified language tag.
         * @summary Delete custom phrase
         * @param {DeleteCustomPhraseLanguageTagEnum} languageTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomPhrase(languageTag: DeleteCustomPhraseLanguageTagEnum, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCustomPhrase(languageTag, options).then((request) => request(axios, basePath));
        },
        /**
         * Get custom phrases for the specified language tag.
         * @summary Get custom phrases
         * @param {GetCustomPhraseLanguageTagEnum} languageTag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomPhrase(languageTag: GetCustomPhraseLanguageTagEnum, options?: any): AxiosPromise<ListCustomPhrases200ResponseInner> {
            return localVarFp.getCustomPhrase(languageTag, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all custom phrases for all languages.
         * @summary Get all custom phrases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomPhrases(options?: any): AxiosPromise<Array<ListCustomPhrases200ResponseInner>> {
            return localVarFp.listCustomPhrases(options).then((request) => request(axios, basePath));
        },
        /**
         * Upsert custom phrases for the specified language tag. Upsert means that if the custom phrases already exist, they will be updated. Otherwise, they will be created.
         * @summary Upsert custom phrases
         * @param {ReplaceCustomPhraseLanguageTagEnum} languageTag 
         * @param {TranslationObject} translationObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceCustomPhrase(languageTag: ReplaceCustomPhraseLanguageTagEnum, translationObject: TranslationObject, options?: any): AxiosPromise<void> {
            return localVarFp.replaceCustomPhrase(languageTag, translationObject, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomPhrasesApi - object-oriented interface
 * @export
 * @class CustomPhrasesApi
 * @extends {BaseAPI}
 */
export class CustomPhrasesApi extends BaseAPI {
    /**
     * Delete custom phrases for the specified language tag.
     * @summary Delete custom phrase
     * @param {DeleteCustomPhraseLanguageTagEnum} languageTag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomPhrasesApi
     */
    public deleteCustomPhrase(languageTag: DeleteCustomPhraseLanguageTagEnum, options?: RawAxiosRequestConfig) {
        return CustomPhrasesApiFp(this.configuration).deleteCustomPhrase(languageTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get custom phrases for the specified language tag.
     * @summary Get custom phrases
     * @param {GetCustomPhraseLanguageTagEnum} languageTag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomPhrasesApi
     */
    public getCustomPhrase(languageTag: GetCustomPhraseLanguageTagEnum, options?: RawAxiosRequestConfig) {
        return CustomPhrasesApiFp(this.configuration).getCustomPhrase(languageTag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all custom phrases for all languages.
     * @summary Get all custom phrases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomPhrasesApi
     */
    public listCustomPhrases(options?: RawAxiosRequestConfig) {
        return CustomPhrasesApiFp(this.configuration).listCustomPhrases(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upsert custom phrases for the specified language tag. Upsert means that if the custom phrases already exist, they will be updated. Otherwise, they will be created.
     * @summary Upsert custom phrases
     * @param {ReplaceCustomPhraseLanguageTagEnum} languageTag 
     * @param {TranslationObject} translationObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomPhrasesApi
     */
    public replaceCustomPhrase(languageTag: ReplaceCustomPhraseLanguageTagEnum, translationObject: TranslationObject, options?: RawAxiosRequestConfig) {
        return CustomPhrasesApiFp(this.configuration).replaceCustomPhrase(languageTag, translationObject, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeleteCustomPhraseLanguageTagEnum = {
    AfZa: 'af-ZA',
    AmEt: 'am-ET',
    ArAr: 'ar-AR',
    AsIn: 'as-IN',
    AzAz: 'az-AZ',
    BeBy: 'be-BY',
    BgBg: 'bg-BG',
    BnIn: 'bn-IN',
    BrFr: 'br-FR',
    BsBa: 'bs-BA',
    CaEs: 'ca-ES',
    CbIq: 'cb-IQ',
    CoFr: 'co-FR',
    CsCz: 'cs-CZ',
    CxPh: 'cx-PH',
    CyGb: 'cy-GB',
    DaDk: 'da-DK',
    De: 'de',
    DeDe: 'de-DE',
    ElGr: 'el-GR',
    En: 'en',
    EnGb: 'en-GB',
    EnUs: 'en-US',
    EoEo: 'eo-EO',
    Es: 'es',
    EsEs: 'es-ES',
    Es419: 'es-419',
    EtEe: 'et-EE',
    EuEs: 'eu-ES',
    FaIr: 'fa-IR',
    FfNg: 'ff-NG',
    FiFi: 'fi-FI',
    FoFo: 'fo-FO',
    Fr: 'fr',
    FrCa: 'fr-CA',
    FrFr: 'fr-FR',
    FyNl: 'fy-NL',
    GaIe: 'ga-IE',
    GlEs: 'gl-ES',
    GnPy: 'gn-PY',
    GuIn: 'gu-IN',
    HaNg: 'ha-NG',
    HeIl: 'he-IL',
    HiIn: 'hi-IN',
    HrHr: 'hr-HR',
    HtHt: 'ht-HT',
    HuHu: 'hu-HU',
    HyAm: 'hy-AM',
    IdId: 'id-ID',
    IkUs: 'ik-US',
    IsIs: 'is-IS',
    It: 'it',
    ItIt: 'it-IT',
    IuCa: 'iu-CA',
    Ja: 'ja',
    JaJp: 'ja-JP',
    JaKs: 'ja-KS',
    JvId: 'jv-ID',
    KaGe: 'ka-GE',
    KkKz: 'kk-KZ',
    KmKh: 'km-KH',
    KnIn: 'kn-IN',
    Ko: 'ko',
    KoKr: 'ko-KR',
    KuTr: 'ku-TR',
    KyKg: 'ky-KG',
    LoLa: 'lo-LA',
    LtLt: 'lt-LT',
    LvLv: 'lv-LV',
    MgMg: 'mg-MG',
    MkMk: 'mk-MK',
    MlIn: 'ml-IN',
    MnMn: 'mn-MN',
    MrIn: 'mr-IN',
    MsMy: 'ms-MY',
    MtMt: 'mt-MT',
    MyMm: 'my-MM',
    NbNo: 'nb-NO',
    NeNp: 'ne-NP',
    NlBe: 'nl-BE',
    NlNl: 'nl-NL',
    NnNo: 'nn-NO',
    OrIn: 'or-IN',
    PaIn: 'pa-IN',
    PlPl: 'pl-PL',
    PsAf: 'ps-AF',
    Pt: 'pt',
    PtBr: 'pt-BR',
    PtPt: 'pt-PT',
    RoRo: 'ro-RO',
    Ru: 'ru',
    RuRu: 'ru-RU',
    RwRw: 'rw-RW',
    ScIt: 'sc-IT',
    SiLk: 'si-LK',
    SkSk: 'sk-SK',
    SlSi: 'sl-SI',
    SnZw: 'sn-ZW',
    SqAl: 'sq-AL',
    SrRs: 'sr-RS',
    SvSe: 'sv-SE',
    SwKe: 'sw-KE',
    SySy: 'sy-SY',
    SzPl: 'sz-PL',
    TaIn: 'ta-IN',
    TeIn: 'te-IN',
    TgTj: 'tg-TJ',
    ThTh: 'th-TH',
    TlPh: 'tl-PH',
    Tr: 'tr',
    TrTr: 'tr-TR',
    TtRu: 'tt-RU',
    TzMa: 'tz-MA',
    UkUa: 'uk-UA',
    UrPk: 'ur-PK',
    UzUz: 'uz-UZ',
    ViVn: 'vi-VN',
    Zh: 'zh',
    ZhCn: 'zh-CN',
    ZhHk: 'zh-HK',
    ZhMo: 'zh-MO',
    ZhTw: 'zh-TW',
    ZzTr: 'zz-TR'
} as const;
export type DeleteCustomPhraseLanguageTagEnum = typeof DeleteCustomPhraseLanguageTagEnum[keyof typeof DeleteCustomPhraseLanguageTagEnum];
/**
 * @export
 */
export const GetCustomPhraseLanguageTagEnum = {
    AfZa: 'af-ZA',
    AmEt: 'am-ET',
    ArAr: 'ar-AR',
    AsIn: 'as-IN',
    AzAz: 'az-AZ',
    BeBy: 'be-BY',
    BgBg: 'bg-BG',
    BnIn: 'bn-IN',
    BrFr: 'br-FR',
    BsBa: 'bs-BA',
    CaEs: 'ca-ES',
    CbIq: 'cb-IQ',
    CoFr: 'co-FR',
    CsCz: 'cs-CZ',
    CxPh: 'cx-PH',
    CyGb: 'cy-GB',
    DaDk: 'da-DK',
    De: 'de',
    DeDe: 'de-DE',
    ElGr: 'el-GR',
    En: 'en',
    EnGb: 'en-GB',
    EnUs: 'en-US',
    EoEo: 'eo-EO',
    Es: 'es',
    EsEs: 'es-ES',
    Es419: 'es-419',
    EtEe: 'et-EE',
    EuEs: 'eu-ES',
    FaIr: 'fa-IR',
    FfNg: 'ff-NG',
    FiFi: 'fi-FI',
    FoFo: 'fo-FO',
    Fr: 'fr',
    FrCa: 'fr-CA',
    FrFr: 'fr-FR',
    FyNl: 'fy-NL',
    GaIe: 'ga-IE',
    GlEs: 'gl-ES',
    GnPy: 'gn-PY',
    GuIn: 'gu-IN',
    HaNg: 'ha-NG',
    HeIl: 'he-IL',
    HiIn: 'hi-IN',
    HrHr: 'hr-HR',
    HtHt: 'ht-HT',
    HuHu: 'hu-HU',
    HyAm: 'hy-AM',
    IdId: 'id-ID',
    IkUs: 'ik-US',
    IsIs: 'is-IS',
    It: 'it',
    ItIt: 'it-IT',
    IuCa: 'iu-CA',
    Ja: 'ja',
    JaJp: 'ja-JP',
    JaKs: 'ja-KS',
    JvId: 'jv-ID',
    KaGe: 'ka-GE',
    KkKz: 'kk-KZ',
    KmKh: 'km-KH',
    KnIn: 'kn-IN',
    Ko: 'ko',
    KoKr: 'ko-KR',
    KuTr: 'ku-TR',
    KyKg: 'ky-KG',
    LoLa: 'lo-LA',
    LtLt: 'lt-LT',
    LvLv: 'lv-LV',
    MgMg: 'mg-MG',
    MkMk: 'mk-MK',
    MlIn: 'ml-IN',
    MnMn: 'mn-MN',
    MrIn: 'mr-IN',
    MsMy: 'ms-MY',
    MtMt: 'mt-MT',
    MyMm: 'my-MM',
    NbNo: 'nb-NO',
    NeNp: 'ne-NP',
    NlBe: 'nl-BE',
    NlNl: 'nl-NL',
    NnNo: 'nn-NO',
    OrIn: 'or-IN',
    PaIn: 'pa-IN',
    PlPl: 'pl-PL',
    PsAf: 'ps-AF',
    Pt: 'pt',
    PtBr: 'pt-BR',
    PtPt: 'pt-PT',
    RoRo: 'ro-RO',
    Ru: 'ru',
    RuRu: 'ru-RU',
    RwRw: 'rw-RW',
    ScIt: 'sc-IT',
    SiLk: 'si-LK',
    SkSk: 'sk-SK',
    SlSi: 'sl-SI',
    SnZw: 'sn-ZW',
    SqAl: 'sq-AL',
    SrRs: 'sr-RS',
    SvSe: 'sv-SE',
    SwKe: 'sw-KE',
    SySy: 'sy-SY',
    SzPl: 'sz-PL',
    TaIn: 'ta-IN',
    TeIn: 'te-IN',
    TgTj: 'tg-TJ',
    ThTh: 'th-TH',
    TlPh: 'tl-PH',
    Tr: 'tr',
    TrTr: 'tr-TR',
    TtRu: 'tt-RU',
    TzMa: 'tz-MA',
    UkUa: 'uk-UA',
    UrPk: 'ur-PK',
    UzUz: 'uz-UZ',
    ViVn: 'vi-VN',
    Zh: 'zh',
    ZhCn: 'zh-CN',
    ZhHk: 'zh-HK',
    ZhMo: 'zh-MO',
    ZhTw: 'zh-TW',
    ZzTr: 'zz-TR'
} as const;
export type GetCustomPhraseLanguageTagEnum = typeof GetCustomPhraseLanguageTagEnum[keyof typeof GetCustomPhraseLanguageTagEnum];
/**
 * @export
 */
export const ReplaceCustomPhraseLanguageTagEnum = {
    AfZa: 'af-ZA',
    AmEt: 'am-ET',
    ArAr: 'ar-AR',
    AsIn: 'as-IN',
    AzAz: 'az-AZ',
    BeBy: 'be-BY',
    BgBg: 'bg-BG',
    BnIn: 'bn-IN',
    BrFr: 'br-FR',
    BsBa: 'bs-BA',
    CaEs: 'ca-ES',
    CbIq: 'cb-IQ',
    CoFr: 'co-FR',
    CsCz: 'cs-CZ',
    CxPh: 'cx-PH',
    CyGb: 'cy-GB',
    DaDk: 'da-DK',
    De: 'de',
    DeDe: 'de-DE',
    ElGr: 'el-GR',
    En: 'en',
    EnGb: 'en-GB',
    EnUs: 'en-US',
    EoEo: 'eo-EO',
    Es: 'es',
    EsEs: 'es-ES',
    Es419: 'es-419',
    EtEe: 'et-EE',
    EuEs: 'eu-ES',
    FaIr: 'fa-IR',
    FfNg: 'ff-NG',
    FiFi: 'fi-FI',
    FoFo: 'fo-FO',
    Fr: 'fr',
    FrCa: 'fr-CA',
    FrFr: 'fr-FR',
    FyNl: 'fy-NL',
    GaIe: 'ga-IE',
    GlEs: 'gl-ES',
    GnPy: 'gn-PY',
    GuIn: 'gu-IN',
    HaNg: 'ha-NG',
    HeIl: 'he-IL',
    HiIn: 'hi-IN',
    HrHr: 'hr-HR',
    HtHt: 'ht-HT',
    HuHu: 'hu-HU',
    HyAm: 'hy-AM',
    IdId: 'id-ID',
    IkUs: 'ik-US',
    IsIs: 'is-IS',
    It: 'it',
    ItIt: 'it-IT',
    IuCa: 'iu-CA',
    Ja: 'ja',
    JaJp: 'ja-JP',
    JaKs: 'ja-KS',
    JvId: 'jv-ID',
    KaGe: 'ka-GE',
    KkKz: 'kk-KZ',
    KmKh: 'km-KH',
    KnIn: 'kn-IN',
    Ko: 'ko',
    KoKr: 'ko-KR',
    KuTr: 'ku-TR',
    KyKg: 'ky-KG',
    LoLa: 'lo-LA',
    LtLt: 'lt-LT',
    LvLv: 'lv-LV',
    MgMg: 'mg-MG',
    MkMk: 'mk-MK',
    MlIn: 'ml-IN',
    MnMn: 'mn-MN',
    MrIn: 'mr-IN',
    MsMy: 'ms-MY',
    MtMt: 'mt-MT',
    MyMm: 'my-MM',
    NbNo: 'nb-NO',
    NeNp: 'ne-NP',
    NlBe: 'nl-BE',
    NlNl: 'nl-NL',
    NnNo: 'nn-NO',
    OrIn: 'or-IN',
    PaIn: 'pa-IN',
    PlPl: 'pl-PL',
    PsAf: 'ps-AF',
    Pt: 'pt',
    PtBr: 'pt-BR',
    PtPt: 'pt-PT',
    RoRo: 'ro-RO',
    Ru: 'ru',
    RuRu: 'ru-RU',
    RwRw: 'rw-RW',
    ScIt: 'sc-IT',
    SiLk: 'si-LK',
    SkSk: 'sk-SK',
    SlSi: 'sl-SI',
    SnZw: 'sn-ZW',
    SqAl: 'sq-AL',
    SrRs: 'sr-RS',
    SvSe: 'sv-SE',
    SwKe: 'sw-KE',
    SySy: 'sy-SY',
    SzPl: 'sz-PL',
    TaIn: 'ta-IN',
    TeIn: 'te-IN',
    TgTj: 'tg-TJ',
    ThTh: 'th-TH',
    TlPh: 'tl-PH',
    Tr: 'tr',
    TrTr: 'tr-TR',
    TtRu: 'tt-RU',
    TzMa: 'tz-MA',
    UkUa: 'uk-UA',
    UrPk: 'ur-PK',
    UzUz: 'uz-UZ',
    ViVn: 'vi-VN',
    Zh: 'zh',
    ZhCn: 'zh-CN',
    ZhHk: 'zh-HK',
    ZhMo: 'zh-MO',
    ZhTw: 'zh-TW',
    ZzTr: 'zz-TR'
} as const;
export type ReplaceCustomPhraseLanguageTagEnum = typeof ReplaceCustomPhraseLanguageTagEnum[keyof typeof ReplaceCustomPhraseLanguageTagEnum];


/**
 * DashboardApi - axios parameter creator
 * @export
 */
export const DashboardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get active user data, including daily active user (DAU), weekly active user (WAU) and monthly active user (MAU). It also includes an array of DAU in the past 30 days.
         * @summary Get active user data
         * @param {string} [date] The date to get active user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveUserCounts: async (date?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/dashboard/users/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get new user count in the past 7 days.
         * @summary Get new user count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUserCounts: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/dashboard/users/new`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get total user count in the current tenant.
         * @summary Get total user count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalUserCount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/dashboard/users/total`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardApi - functional programming interface
 * @export
 */
export const DashboardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DashboardApiAxiosParamCreator(configuration)
    return {
        /**
         * Get active user data, including daily active user (DAU), weekly active user (WAU) and monthly active user (MAU). It also includes an array of DAU in the past 30 days.
         * @summary Get active user data
         * @param {string} [date] The date to get active user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveUserCounts(date?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetActiveUserCounts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveUserCounts(date, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getActiveUserCounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get new user count in the past 7 days.
         * @summary Get new user count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNewUserCounts(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetNewUserCounts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNewUserCounts(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getNewUserCounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get total user count in the current tenant.
         * @summary Get total user count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTotalUserCount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTotalUserCount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTotalUserCount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getTotalUserCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DashboardApi - factory interface
 * @export
 */
export const DashboardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DashboardApiFp(configuration)
    return {
        /**
         * Get active user data, including daily active user (DAU), weekly active user (WAU) and monthly active user (MAU). It also includes an array of DAU in the past 30 days.
         * @summary Get active user data
         * @param {string} [date] The date to get active user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveUserCounts(date?: string, options?: any): AxiosPromise<GetActiveUserCounts200Response> {
            return localVarFp.getActiveUserCounts(date, options).then((request) => request(axios, basePath));
        },
        /**
         * Get new user count in the past 7 days.
         * @summary Get new user count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNewUserCounts(options?: any): AxiosPromise<GetNewUserCounts200Response> {
            return localVarFp.getNewUserCounts(options).then((request) => request(axios, basePath));
        },
        /**
         * Get total user count in the current tenant.
         * @summary Get total user count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalUserCount(options?: any): AxiosPromise<GetTotalUserCount200Response> {
            return localVarFp.getTotalUserCount(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DashboardApi - object-oriented interface
 * @export
 * @class DashboardApi
 * @extends {BaseAPI}
 */
export class DashboardApi extends BaseAPI {
    /**
     * Get active user data, including daily active user (DAU), weekly active user (WAU) and monthly active user (MAU). It also includes an array of DAU in the past 30 days.
     * @summary Get active user data
     * @param {string} [date] The date to get active user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getActiveUserCounts(date?: string, options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getActiveUserCounts(date, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get new user count in the past 7 days.
     * @summary Get new user count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getNewUserCounts(options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getNewUserCounts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get total user count in the current tenant.
     * @summary Get total user count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getTotalUserCount(options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getTotalUserCount(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DomainsApi - axios parameter creator
 * @export
 */
export const DomainsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new domain with the given data. The maximum domain number is 1, once created, can not be modified, you\'ll have to delete and recreate one.
         * @summary Create domain
         * @param {CreateDomainRequest} createDomainRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomain: async (createDomainRequest: CreateDomainRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createDomainRequest' is not null or undefined
            assertParamExists('createDomain', 'createDomainRequest', createDomainRequest)
            const localVarPath = `/api/domains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDomainRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete domain by ID.
         * @summary Delete domain
         * @param {string} id The unique identifier of the domain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomain: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDomain', 'id', id)
            const localVarPath = `/api/domains/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get domain details by ID, by calling this API, the domain status will be synced from remote provider.
         * @summary Get domain
         * @param {string} id The unique identifier of the domain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomain: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDomain', 'id', id)
            const localVarPath = `/api/domains/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all of your custom domains.
         * @summary Get domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDomains: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/domains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DomainsApi - functional programming interface
 * @export
 */
export const DomainsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DomainsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new domain with the given data. The maximum domain number is 1, once created, can not be modified, you\'ll have to delete and recreate one.
         * @summary Create domain
         * @param {CreateDomainRequest} createDomainRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDomain(createDomainRequest: CreateDomainRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDomain(createDomainRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainsApi.createDomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete domain by ID.
         * @summary Delete domain
         * @param {string} id The unique identifier of the domain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDomain(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDomain(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainsApi.deleteDomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get domain details by ID, by calling this API, the domain status will be synced from remote provider.
         * @summary Get domain
         * @param {string} id The unique identifier of the domain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDomain(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDomains200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDomain(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainsApi.getDomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all of your custom domains.
         * @summary Get domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDomains(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListDomains200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDomains(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainsApi.listDomains']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DomainsApi - factory interface
 * @export
 */
export const DomainsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DomainsApiFp(configuration)
    return {
        /**
         * Create a new domain with the given data. The maximum domain number is 1, once created, can not be modified, you\'ll have to delete and recreate one.
         * @summary Create domain
         * @param {CreateDomainRequest} createDomainRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomain(createDomainRequest: CreateDomainRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createDomain(createDomainRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete domain by ID.
         * @summary Delete domain
         * @param {string} id The unique identifier of the domain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomain(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDomain(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get domain details by ID, by calling this API, the domain status will be synced from remote provider.
         * @summary Get domain
         * @param {string} id The unique identifier of the domain.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomain(id: string, options?: any): AxiosPromise<ListDomains200ResponseInner> {
            return localVarFp.getDomain(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all of your custom domains.
         * @summary Get domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDomains(options?: any): AxiosPromise<Array<ListDomains200ResponseInner>> {
            return localVarFp.listDomains(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DomainsApi - object-oriented interface
 * @export
 * @class DomainsApi
 * @extends {BaseAPI}
 */
export class DomainsApi extends BaseAPI {
    /**
     * Create a new domain with the given data. The maximum domain number is 1, once created, can not be modified, you\'ll have to delete and recreate one.
     * @summary Create domain
     * @param {CreateDomainRequest} createDomainRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApi
     */
    public createDomain(createDomainRequest: CreateDomainRequest, options?: RawAxiosRequestConfig) {
        return DomainsApiFp(this.configuration).createDomain(createDomainRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete domain by ID.
     * @summary Delete domain
     * @param {string} id The unique identifier of the domain.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApi
     */
    public deleteDomain(id: string, options?: RawAxiosRequestConfig) {
        return DomainsApiFp(this.configuration).deleteDomain(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get domain details by ID, by calling this API, the domain status will be synced from remote provider.
     * @summary Get domain
     * @param {string} id The unique identifier of the domain.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApi
     */
    public getDomain(id: string, options?: RawAxiosRequestConfig) {
        return DomainsApiFp(this.configuration).getDomain(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all of your custom domains.
     * @summary Get domains
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApi
     */
    public listDomains(options?: RawAxiosRequestConfig) {
        return DomainsApiFp(this.configuration).listDomains(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HooksApi - axios parameter creator
 * @export
 */
export const HooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new hook with the given data.
         * @summary Create a hook
         * @param {CreateHookRequest} createHookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHook: async (createHookRequest: CreateHookRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createHookRequest' is not null or undefined
            assertParamExists('createHook', 'createHookRequest', createHookRequest)
            const localVarPath = `/api/hooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createHookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test the specified hook with the given events and config.
         * @summary Test hook
         * @param {string} id The unique identifier of the hook.
         * @param {CreateHookTestRequest} createHookTestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHookTest: async (id: string, createHookTestRequest: CreateHookTestRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createHookTest', 'id', id)
            // verify required parameter 'createHookTestRequest' is not null or undefined
            assertParamExists('createHookTest', 'createHookTestRequest', createHookTestRequest)
            const localVarPath = `/api/hooks/{id}/test`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createHookTestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete hook by ID.
         * @summary Delete hook
         * @param {string} id The unique identifier of the hook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHook: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteHook', 'id', id)
            const localVarPath = `/api/hooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get hook details by ID.
         * @summary Get hook
         * @param {string} id The unique identifier of the hook.
         * @param {string} [includeExecutionStats] Whether to include execution stats in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHook: async (id: string, includeExecutionStats?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getHook', 'id', id)
            const localVarPath = `/api/hooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (includeExecutionStats !== undefined) {
                localVarQueryParameter['includeExecutionStats'] = includeExecutionStats;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recent logs that match the given query for the specified hook with pagination.
         * @summary Get recent logs for a hook
         * @param {string} id The unique identifier of the hook.
         * @param {string} [logKey] The log key to filter logs.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHookRecentLogs: async (id: string, logKey?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listHookRecentLogs', 'id', id)
            const localVarPath = `/api/hooks/{id}/recent-logs`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (logKey !== undefined) {
                localVarQueryParameter['logKey'] = logKey;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of hooks with optional pagination.
         * @summary Get hooks
         * @param {string} [includeExecutionStats] Whether to include execution stats in the response.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHooks: async (includeExecutionStats?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/hooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (includeExecutionStats !== undefined) {
                localVarQueryParameter['includeExecutionStats'] = includeExecutionStats;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update hook details by ID with the given data.
         * @summary Update hook
         * @param {string} id The unique identifier of the hook.
         * @param {UpdateHookRequest} updateHookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHook: async (id: string, updateHookRequest: UpdateHookRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateHook', 'id', id)
            // verify required parameter 'updateHookRequest' is not null or undefined
            assertParamExists('updateHook', 'updateHookRequest', updateHookRequest)
            const localVarPath = `/api/hooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateHookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the signing key for the specified hook.
         * @summary Update signing key for a hook
         * @param {string} id The unique identifier of the hook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHookSigningKey: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateHookSigningKey', 'id', id)
            const localVarPath = `/api/hooks/{id}/signing-key`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HooksApi - functional programming interface
 * @export
 */
export const HooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new hook with the given data.
         * @summary Create a hook
         * @param {CreateHookRequest} createHookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHook(createHookRequest: CreateHookRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createHook(createHookRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HooksApi.createHook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test the specified hook with the given events and config.
         * @summary Test hook
         * @param {string} id The unique identifier of the hook.
         * @param {CreateHookTestRequest} createHookTestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHookTest(id: string, createHookTestRequest: CreateHookTestRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createHookTest(id, createHookTestRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HooksApi.createHookTest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete hook by ID.
         * @summary Delete hook
         * @param {string} id The unique identifier of the hook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHook(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteHook(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HooksApi.deleteHook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get hook details by ID.
         * @summary Get hook
         * @param {string} id The unique identifier of the hook.
         * @param {string} [includeExecutionStats] Whether to include execution stats in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHook(id: string, includeExecutionStats?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListHooks200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHook(id, includeExecutionStats, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HooksApi.getHook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get recent logs that match the given query for the specified hook with pagination.
         * @summary Get recent logs for a hook
         * @param {string} id The unique identifier of the hook.
         * @param {string} [logKey] The log key to filter logs.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHookRecentLogs(id: string, logKey?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListHookRecentLogs200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listHookRecentLogs(id, logKey, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HooksApi.listHookRecentLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of hooks with optional pagination.
         * @summary Get hooks
         * @param {string} [includeExecutionStats] Whether to include execution stats in the response.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHooks(includeExecutionStats?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListHooks200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listHooks(includeExecutionStats, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HooksApi.listHooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update hook details by ID with the given data.
         * @summary Update hook
         * @param {string} id The unique identifier of the hook.
         * @param {UpdateHookRequest} updateHookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateHook(id: string, updateHookRequest: UpdateHookRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateHook200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateHook(id, updateHookRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HooksApi.updateHook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the signing key for the specified hook.
         * @summary Update signing key for a hook
         * @param {string} id The unique identifier of the hook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateHookSigningKey(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateHook200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateHookSigningKey(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HooksApi.updateHookSigningKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HooksApi - factory interface
 * @export
 */
export const HooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HooksApiFp(configuration)
    return {
        /**
         * Create a new hook with the given data.
         * @summary Create a hook
         * @param {CreateHookRequest} createHookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHook(createHookRequest: CreateHookRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createHook(createHookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Test the specified hook with the given events and config.
         * @summary Test hook
         * @param {string} id The unique identifier of the hook.
         * @param {CreateHookTestRequest} createHookTestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHookTest(id: string, createHookTestRequest: CreateHookTestRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createHookTest(id, createHookTestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete hook by ID.
         * @summary Delete hook
         * @param {string} id The unique identifier of the hook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHook(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteHook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get hook details by ID.
         * @summary Get hook
         * @param {string} id The unique identifier of the hook.
         * @param {string} [includeExecutionStats] Whether to include execution stats in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHook(id: string, includeExecutionStats?: string, options?: any): AxiosPromise<ListHooks200ResponseInner> {
            return localVarFp.getHook(id, includeExecutionStats, options).then((request) => request(axios, basePath));
        },
        /**
         * Get recent logs that match the given query for the specified hook with pagination.
         * @summary Get recent logs for a hook
         * @param {string} id The unique identifier of the hook.
         * @param {string} [logKey] The log key to filter logs.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHookRecentLogs(id: string, logKey?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ListHookRecentLogs200ResponseInner>> {
            return localVarFp.listHookRecentLogs(id, logKey, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of hooks with optional pagination.
         * @summary Get hooks
         * @param {string} [includeExecutionStats] Whether to include execution stats in the response.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHooks(includeExecutionStats?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ListHooks200ResponseInner>> {
            return localVarFp.listHooks(includeExecutionStats, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Update hook details by ID with the given data.
         * @summary Update hook
         * @param {string} id The unique identifier of the hook.
         * @param {UpdateHookRequest} updateHookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHook(id: string, updateHookRequest: UpdateHookRequest, options?: any): AxiosPromise<UpdateHook200Response> {
            return localVarFp.updateHook(id, updateHookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the signing key for the specified hook.
         * @summary Update signing key for a hook
         * @param {string} id The unique identifier of the hook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHookSigningKey(id: string, options?: any): AxiosPromise<UpdateHook200Response> {
            return localVarFp.updateHookSigningKey(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HooksApi - object-oriented interface
 * @export
 * @class HooksApi
 * @extends {BaseAPI}
 */
export class HooksApi extends BaseAPI {
    /**
     * Create a new hook with the given data.
     * @summary Create a hook
     * @param {CreateHookRequest} createHookRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HooksApi
     */
    public createHook(createHookRequest: CreateHookRequest, options?: RawAxiosRequestConfig) {
        return HooksApiFp(this.configuration).createHook(createHookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test the specified hook with the given events and config.
     * @summary Test hook
     * @param {string} id The unique identifier of the hook.
     * @param {CreateHookTestRequest} createHookTestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HooksApi
     */
    public createHookTest(id: string, createHookTestRequest: CreateHookTestRequest, options?: RawAxiosRequestConfig) {
        return HooksApiFp(this.configuration).createHookTest(id, createHookTestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete hook by ID.
     * @summary Delete hook
     * @param {string} id The unique identifier of the hook.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HooksApi
     */
    public deleteHook(id: string, options?: RawAxiosRequestConfig) {
        return HooksApiFp(this.configuration).deleteHook(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get hook details by ID.
     * @summary Get hook
     * @param {string} id The unique identifier of the hook.
     * @param {string} [includeExecutionStats] Whether to include execution stats in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HooksApi
     */
    public getHook(id: string, includeExecutionStats?: string, options?: RawAxiosRequestConfig) {
        return HooksApiFp(this.configuration).getHook(id, includeExecutionStats, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recent logs that match the given query for the specified hook with pagination.
     * @summary Get recent logs for a hook
     * @param {string} id The unique identifier of the hook.
     * @param {string} [logKey] The log key to filter logs.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HooksApi
     */
    public listHookRecentLogs(id: string, logKey?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return HooksApiFp(this.configuration).listHookRecentLogs(id, logKey, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of hooks with optional pagination.
     * @summary Get hooks
     * @param {string} [includeExecutionStats] Whether to include execution stats in the response.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HooksApi
     */
    public listHooks(includeExecutionStats?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return HooksApiFp(this.configuration).listHooks(includeExecutionStats, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update hook details by ID with the given data.
     * @summary Update hook
     * @param {string} id The unique identifier of the hook.
     * @param {UpdateHookRequest} updateHookRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HooksApi
     */
    public updateHook(id: string, updateHookRequest: UpdateHookRequest, options?: RawAxiosRequestConfig) {
        return HooksApiFp(this.configuration).updateHook(id, updateHookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the signing key for the specified hook.
     * @summary Update signing key for a hook
     * @param {string} id The unique identifier of the hook.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HooksApi
     */
    public updateHookSigningKey(id: string, options?: RawAxiosRequestConfig) {
        return HooksApiFp(this.configuration).updateHookSigningKey(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InteractionApi - axios parameter creator
 * @export
 */
export const InteractionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ApiInteractionBindMfaPostRequest} apiInteractionBindMfaPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionBindMfaPost: async (apiInteractionBindMfaPostRequest: ApiInteractionBindMfaPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiInteractionBindMfaPostRequest' is not null or undefined
            assertParamExists('apiInteractionBindMfaPost', 'apiInteractionBindMfaPostRequest', apiInteractionBindMfaPostRequest)
            const localVarPath = `/api/interaction/bind-mfa`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiInteractionBindMfaPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionConsentGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/interaction/consent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiInteractionConsentPostRequest} apiInteractionConsentPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionConsentPost: async (apiInteractionConsentPostRequest: ApiInteractionConsentPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiInteractionConsentPostRequest' is not null or undefined
            assertParamExists('apiInteractionConsentPost', 'apiInteractionConsentPostRequest', apiInteractionConsentPostRequest)
            const localVarPath = `/api/interaction/consent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiInteractionConsentPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionDelete: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/interaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiInteractionEventPutRequest} apiInteractionEventPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionEventPut: async (apiInteractionEventPutRequest: ApiInteractionEventPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiInteractionEventPutRequest' is not null or undefined
            assertParamExists('apiInteractionEventPut', 'apiInteractionEventPutRequest', apiInteractionEventPutRequest)
            const localVarPath = `/api/interaction/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiInteractionEventPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiInteractionPutRequestIdentifier} apiInteractionPutRequestIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionIdentifiersPatch: async (apiInteractionPutRequestIdentifier: ApiInteractionPutRequestIdentifier, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiInteractionPutRequestIdentifier' is not null or undefined
            assertParamExists('apiInteractionIdentifiersPatch', 'apiInteractionPutRequestIdentifier', apiInteractionPutRequestIdentifier)
            const localVarPath = `/api/interaction/identifiers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiInteractionPutRequestIdentifier, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiInteractionMfaPutRequest} apiInteractionMfaPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionMfaPut: async (apiInteractionMfaPutRequest: ApiInteractionMfaPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiInteractionMfaPutRequest' is not null or undefined
            assertParamExists('apiInteractionMfaPut', 'apiInteractionMfaPutRequest', apiInteractionMfaPutRequest)
            const localVarPath = `/api/interaction/mfa`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiInteractionMfaPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiInteractionMfaSkippedPutRequest} apiInteractionMfaSkippedPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionMfaSkippedPut: async (apiInteractionMfaSkippedPutRequest: ApiInteractionMfaSkippedPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiInteractionMfaSkippedPutRequest' is not null or undefined
            assertParamExists('apiInteractionMfaSkippedPut', 'apiInteractionMfaSkippedPutRequest', apiInteractionMfaSkippedPutRequest)
            const localVarPath = `/api/interaction/mfa-skipped`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiInteractionMfaSkippedPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionProfileDelete: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/interaction/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiInteractionPutRequestProfile} apiInteractionPutRequestProfile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionProfilePatch: async (apiInteractionPutRequestProfile: ApiInteractionPutRequestProfile, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiInteractionPutRequestProfile' is not null or undefined
            assertParamExists('apiInteractionProfilePatch', 'apiInteractionPutRequestProfile', apiInteractionPutRequestProfile)
            const localVarPath = `/api/interaction/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiInteractionPutRequestProfile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiInteractionPutRequestProfile} apiInteractionPutRequestProfile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionProfilePut: async (apiInteractionPutRequestProfile: ApiInteractionPutRequestProfile, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiInteractionPutRequestProfile' is not null or undefined
            assertParamExists('apiInteractionProfilePut', 'apiInteractionPutRequestProfile', apiInteractionPutRequestProfile)
            const localVarPath = `/api/interaction/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiInteractionPutRequestProfile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiInteractionPutRequest} apiInteractionPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionPut: async (apiInteractionPutRequest: ApiInteractionPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiInteractionPutRequest' is not null or undefined
            assertParamExists('apiInteractionPut', 'apiInteractionPutRequest', apiInteractionPutRequest)
            const localVarPath = `/api/interaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiInteractionPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} connectorId The unique identifier of the connector.
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionSingleSignOnConnectorIdAuthenticationPost: async (connectorId: string, requestBody: { [key: string]: any; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('apiInteractionSingleSignOnConnectorIdAuthenticationPost', 'connectorId', connectorId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('apiInteractionSingleSignOnConnectorIdAuthenticationPost', 'requestBody', requestBody)
            const localVarPath = `/api/interaction/single-sign-on/{connectorId}/authentication`
                .replace(`{${"connectorId"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} connectorId The unique identifier of the connector.
         * @param {ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest} apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionSingleSignOnConnectorIdAuthorizationUrlPost: async (connectorId: string, apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest: ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('apiInteractionSingleSignOnConnectorIdAuthorizationUrlPost', 'connectorId', connectorId)
            // verify required parameter 'apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest' is not null or undefined
            assertParamExists('apiInteractionSingleSignOnConnectorIdAuthorizationUrlPost', 'apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest', apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest)
            const localVarPath = `/api/interaction/single-sign-on/{connectorId}/authorization-url`
                .replace(`{${"connectorId"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} connectorId The unique identifier of the connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionSingleSignOnConnectorIdRegistrationPost: async (connectorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('apiInteractionSingleSignOnConnectorIdRegistrationPost', 'connectorId', connectorId)
            const localVarPath = `/api/interaction/single-sign-on/{connectorId}/registration`
                .replace(`{${"connectorId"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionSingleSignOnConnectorsGet: async (email: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('apiInteractionSingleSignOnConnectorsGet', 'email', email)
            const localVarPath = `/api/interaction/single-sign-on/connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionSubmitPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/interaction/submit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiInteractionVerificationSocialAuthorizationUriPostRequest} apiInteractionVerificationSocialAuthorizationUriPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionVerificationSocialAuthorizationUriPost: async (apiInteractionVerificationSocialAuthorizationUriPostRequest: ApiInteractionVerificationSocialAuthorizationUriPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiInteractionVerificationSocialAuthorizationUriPostRequest' is not null or undefined
            assertParamExists('apiInteractionVerificationSocialAuthorizationUriPost', 'apiInteractionVerificationSocialAuthorizationUriPostRequest', apiInteractionVerificationSocialAuthorizationUriPostRequest)
            const localVarPath = `/api/interaction/verification/social-authorization-uri`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiInteractionVerificationSocialAuthorizationUriPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionVerificationTotpPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/interaction/verification/totp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApiInteractionVerificationVerificationCodePostRequest} apiInteractionVerificationVerificationCodePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionVerificationVerificationCodePost: async (apiInteractionVerificationVerificationCodePostRequest: ApiInteractionVerificationVerificationCodePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiInteractionVerificationVerificationCodePostRequest' is not null or undefined
            assertParamExists('apiInteractionVerificationVerificationCodePost', 'apiInteractionVerificationVerificationCodePostRequest', apiInteractionVerificationVerificationCodePostRequest)
            const localVarPath = `/api/interaction/verification/verification-code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiInteractionVerificationVerificationCodePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionVerificationWebauthnAuthenticationPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/interaction/verification/webauthn-authentication`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionVerificationWebauthnRegistrationPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/interaction/verification/webauthn-registration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InteractionApi - functional programming interface
 * @export
 */
export const InteractionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InteractionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ApiInteractionBindMfaPostRequest} apiInteractionBindMfaPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionBindMfaPost(apiInteractionBindMfaPostRequest: ApiInteractionBindMfaPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionBindMfaPost(apiInteractionBindMfaPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionBindMfaPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionConsentGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiInteractionConsentGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionConsentGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionConsentGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiInteractionConsentPostRequest} apiInteractionConsentPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionConsentPost(apiInteractionConsentPostRequest: ApiInteractionConsentPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionConsentPost(apiInteractionConsentPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionConsentPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionDelete(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionDelete(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiInteractionEventPutRequest} apiInteractionEventPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionEventPut(apiInteractionEventPutRequest: ApiInteractionEventPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionEventPut(apiInteractionEventPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionEventPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiInteractionPutRequestIdentifier} apiInteractionPutRequestIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionIdentifiersPatch(apiInteractionPutRequestIdentifier: ApiInteractionPutRequestIdentifier, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionIdentifiersPatch(apiInteractionPutRequestIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionIdentifiersPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiInteractionMfaPutRequest} apiInteractionMfaPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionMfaPut(apiInteractionMfaPutRequest: ApiInteractionMfaPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionMfaPut(apiInteractionMfaPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionMfaPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiInteractionMfaSkippedPutRequest} apiInteractionMfaSkippedPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionMfaSkippedPut(apiInteractionMfaSkippedPutRequest: ApiInteractionMfaSkippedPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionMfaSkippedPut(apiInteractionMfaSkippedPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionMfaSkippedPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionProfileDelete(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionProfileDelete(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionProfileDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiInteractionPutRequestProfile} apiInteractionPutRequestProfile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionProfilePatch(apiInteractionPutRequestProfile: ApiInteractionPutRequestProfile, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionProfilePatch(apiInteractionPutRequestProfile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionProfilePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiInteractionPutRequestProfile} apiInteractionPutRequestProfile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionProfilePut(apiInteractionPutRequestProfile: ApiInteractionPutRequestProfile, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionProfilePut(apiInteractionPutRequestProfile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionProfilePut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiInteractionPutRequest} apiInteractionPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionPut(apiInteractionPutRequest: ApiInteractionPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionPut(apiInteractionPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} connectorId The unique identifier of the connector.
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionSingleSignOnConnectorIdAuthenticationPost(connectorId: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiInteractionSubmitPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionSingleSignOnConnectorIdAuthenticationPost(connectorId, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionSingleSignOnConnectorIdAuthenticationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} connectorId The unique identifier of the connector.
         * @param {ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest} apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionSingleSignOnConnectorIdAuthorizationUrlPost(connectorId: string, apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest: ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiInteractionSubmitPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionSingleSignOnConnectorIdAuthorizationUrlPost(connectorId, apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionSingleSignOnConnectorIdAuthorizationUrlPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} connectorId The unique identifier of the connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionSingleSignOnConnectorIdRegistrationPost(connectorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiInteractionSubmitPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionSingleSignOnConnectorIdRegistrationPost(connectorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionSingleSignOnConnectorIdRegistrationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionSingleSignOnConnectorsGet(email: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionSingleSignOnConnectorsGet(email, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionSingleSignOnConnectorsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionSubmitPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiInteractionSubmitPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionSubmitPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionSubmitPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiInteractionVerificationSocialAuthorizationUriPostRequest} apiInteractionVerificationSocialAuthorizationUriPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionVerificationSocialAuthorizationUriPost(apiInteractionVerificationSocialAuthorizationUriPostRequest: ApiInteractionVerificationSocialAuthorizationUriPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiInteractionSubmitPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionVerificationSocialAuthorizationUriPost(apiInteractionVerificationSocialAuthorizationUriPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionVerificationSocialAuthorizationUriPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionVerificationTotpPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiInteractionVerificationTotpPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionVerificationTotpPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionVerificationTotpPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ApiInteractionVerificationVerificationCodePostRequest} apiInteractionVerificationVerificationCodePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionVerificationVerificationCodePost(apiInteractionVerificationVerificationCodePostRequest: ApiInteractionVerificationVerificationCodePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionVerificationVerificationCodePost(apiInteractionVerificationVerificationCodePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionVerificationVerificationCodePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionVerificationWebauthnAuthenticationPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiInteractionVerificationWebauthnAuthenticationPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionVerificationWebauthnAuthenticationPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionVerificationWebauthnAuthenticationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInteractionVerificationWebauthnRegistrationPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiInteractionVerificationWebauthnRegistrationPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInteractionVerificationWebauthnRegistrationPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InteractionApi.apiInteractionVerificationWebauthnRegistrationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InteractionApi - factory interface
 * @export
 */
export const InteractionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InteractionApiFp(configuration)
    return {
        /**
         * 
         * @param {ApiInteractionBindMfaPostRequest} apiInteractionBindMfaPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionBindMfaPost(apiInteractionBindMfaPostRequest: ApiInteractionBindMfaPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiInteractionBindMfaPost(apiInteractionBindMfaPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionConsentGet(options?: any): AxiosPromise<ApiInteractionConsentGet200Response> {
            return localVarFp.apiInteractionConsentGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiInteractionConsentPostRequest} apiInteractionConsentPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionConsentPost(apiInteractionConsentPostRequest: ApiInteractionConsentPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiInteractionConsentPost(apiInteractionConsentPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionDelete(options?: any): AxiosPromise<void> {
            return localVarFp.apiInteractionDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiInteractionEventPutRequest} apiInteractionEventPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionEventPut(apiInteractionEventPutRequest: ApiInteractionEventPutRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiInteractionEventPut(apiInteractionEventPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiInteractionPutRequestIdentifier} apiInteractionPutRequestIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionIdentifiersPatch(apiInteractionPutRequestIdentifier: ApiInteractionPutRequestIdentifier, options?: any): AxiosPromise<void> {
            return localVarFp.apiInteractionIdentifiersPatch(apiInteractionPutRequestIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiInteractionMfaPutRequest} apiInteractionMfaPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionMfaPut(apiInteractionMfaPutRequest: ApiInteractionMfaPutRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiInteractionMfaPut(apiInteractionMfaPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiInteractionMfaSkippedPutRequest} apiInteractionMfaSkippedPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionMfaSkippedPut(apiInteractionMfaSkippedPutRequest: ApiInteractionMfaSkippedPutRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiInteractionMfaSkippedPut(apiInteractionMfaSkippedPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionProfileDelete(options?: any): AxiosPromise<void> {
            return localVarFp.apiInteractionProfileDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiInteractionPutRequestProfile} apiInteractionPutRequestProfile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionProfilePatch(apiInteractionPutRequestProfile: ApiInteractionPutRequestProfile, options?: any): AxiosPromise<void> {
            return localVarFp.apiInteractionProfilePatch(apiInteractionPutRequestProfile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiInteractionPutRequestProfile} apiInteractionPutRequestProfile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionProfilePut(apiInteractionPutRequestProfile: ApiInteractionPutRequestProfile, options?: any): AxiosPromise<void> {
            return localVarFp.apiInteractionProfilePut(apiInteractionPutRequestProfile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiInteractionPutRequest} apiInteractionPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionPut(apiInteractionPutRequest: ApiInteractionPutRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiInteractionPut(apiInteractionPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} connectorId The unique identifier of the connector.
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionSingleSignOnConnectorIdAuthenticationPost(connectorId: string, requestBody: { [key: string]: any; }, options?: any): AxiosPromise<ApiInteractionSubmitPost200Response> {
            return localVarFp.apiInteractionSingleSignOnConnectorIdAuthenticationPost(connectorId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} connectorId The unique identifier of the connector.
         * @param {ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest} apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionSingleSignOnConnectorIdAuthorizationUrlPost(connectorId: string, apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest: ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest, options?: any): AxiosPromise<ApiInteractionSubmitPost200Response> {
            return localVarFp.apiInteractionSingleSignOnConnectorIdAuthorizationUrlPost(connectorId, apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} connectorId The unique identifier of the connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionSingleSignOnConnectorIdRegistrationPost(connectorId: string, options?: any): AxiosPromise<ApiInteractionSubmitPost200Response> {
            return localVarFp.apiInteractionSingleSignOnConnectorIdRegistrationPost(connectorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionSingleSignOnConnectorsGet(email: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.apiInteractionSingleSignOnConnectorsGet(email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionSubmitPost(options?: any): AxiosPromise<ApiInteractionSubmitPost200Response> {
            return localVarFp.apiInteractionSubmitPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiInteractionVerificationSocialAuthorizationUriPostRequest} apiInteractionVerificationSocialAuthorizationUriPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionVerificationSocialAuthorizationUriPost(apiInteractionVerificationSocialAuthorizationUriPostRequest: ApiInteractionVerificationSocialAuthorizationUriPostRequest, options?: any): AxiosPromise<ApiInteractionSubmitPost200Response> {
            return localVarFp.apiInteractionVerificationSocialAuthorizationUriPost(apiInteractionVerificationSocialAuthorizationUriPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionVerificationTotpPost(options?: any): AxiosPromise<ApiInteractionVerificationTotpPost200Response> {
            return localVarFp.apiInteractionVerificationTotpPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ApiInteractionVerificationVerificationCodePostRequest} apiInteractionVerificationVerificationCodePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionVerificationVerificationCodePost(apiInteractionVerificationVerificationCodePostRequest: ApiInteractionVerificationVerificationCodePostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiInteractionVerificationVerificationCodePost(apiInteractionVerificationVerificationCodePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionVerificationWebauthnAuthenticationPost(options?: any): AxiosPromise<ApiInteractionVerificationWebauthnAuthenticationPost200Response> {
            return localVarFp.apiInteractionVerificationWebauthnAuthenticationPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInteractionVerificationWebauthnRegistrationPost(options?: any): AxiosPromise<ApiInteractionVerificationWebauthnRegistrationPost200Response> {
            return localVarFp.apiInteractionVerificationWebauthnRegistrationPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InteractionApi - object-oriented interface
 * @export
 * @class InteractionApi
 * @extends {BaseAPI}
 */
export class InteractionApi extends BaseAPI {
    /**
     * 
     * @param {ApiInteractionBindMfaPostRequest} apiInteractionBindMfaPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionBindMfaPost(apiInteractionBindMfaPostRequest: ApiInteractionBindMfaPostRequest, options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionBindMfaPost(apiInteractionBindMfaPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionConsentGet(options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionConsentGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiInteractionConsentPostRequest} apiInteractionConsentPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionConsentPost(apiInteractionConsentPostRequest: ApiInteractionConsentPostRequest, options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionConsentPost(apiInteractionConsentPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionDelete(options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiInteractionEventPutRequest} apiInteractionEventPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionEventPut(apiInteractionEventPutRequest: ApiInteractionEventPutRequest, options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionEventPut(apiInteractionEventPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiInteractionPutRequestIdentifier} apiInteractionPutRequestIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionIdentifiersPatch(apiInteractionPutRequestIdentifier: ApiInteractionPutRequestIdentifier, options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionIdentifiersPatch(apiInteractionPutRequestIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiInteractionMfaPutRequest} apiInteractionMfaPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionMfaPut(apiInteractionMfaPutRequest: ApiInteractionMfaPutRequest, options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionMfaPut(apiInteractionMfaPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiInteractionMfaSkippedPutRequest} apiInteractionMfaSkippedPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionMfaSkippedPut(apiInteractionMfaSkippedPutRequest: ApiInteractionMfaSkippedPutRequest, options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionMfaSkippedPut(apiInteractionMfaSkippedPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionProfileDelete(options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionProfileDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiInteractionPutRequestProfile} apiInteractionPutRequestProfile 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionProfilePatch(apiInteractionPutRequestProfile: ApiInteractionPutRequestProfile, options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionProfilePatch(apiInteractionPutRequestProfile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiInteractionPutRequestProfile} apiInteractionPutRequestProfile 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionProfilePut(apiInteractionPutRequestProfile: ApiInteractionPutRequestProfile, options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionProfilePut(apiInteractionPutRequestProfile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiInteractionPutRequest} apiInteractionPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionPut(apiInteractionPutRequest: ApiInteractionPutRequest, options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionPut(apiInteractionPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} connectorId The unique identifier of the connector.
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionSingleSignOnConnectorIdAuthenticationPost(connectorId: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionSingleSignOnConnectorIdAuthenticationPost(connectorId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} connectorId The unique identifier of the connector.
     * @param {ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest} apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionSingleSignOnConnectorIdAuthorizationUrlPost(connectorId: string, apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest: ApiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest, options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionSingleSignOnConnectorIdAuthorizationUrlPost(connectorId, apiInteractionSingleSignOnConnectorIdAuthorizationUrlPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} connectorId The unique identifier of the connector.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionSingleSignOnConnectorIdRegistrationPost(connectorId: string, options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionSingleSignOnConnectorIdRegistrationPost(connectorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionSingleSignOnConnectorsGet(email: string, options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionSingleSignOnConnectorsGet(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionSubmitPost(options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionSubmitPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiInteractionVerificationSocialAuthorizationUriPostRequest} apiInteractionVerificationSocialAuthorizationUriPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionVerificationSocialAuthorizationUriPost(apiInteractionVerificationSocialAuthorizationUriPostRequest: ApiInteractionVerificationSocialAuthorizationUriPostRequest, options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionVerificationSocialAuthorizationUriPost(apiInteractionVerificationSocialAuthorizationUriPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionVerificationTotpPost(options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionVerificationTotpPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiInteractionVerificationVerificationCodePostRequest} apiInteractionVerificationVerificationCodePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionVerificationVerificationCodePost(apiInteractionVerificationVerificationCodePostRequest: ApiInteractionVerificationVerificationCodePostRequest, options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionVerificationVerificationCodePost(apiInteractionVerificationVerificationCodePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionVerificationWebauthnAuthenticationPost(options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionVerificationWebauthnAuthenticationPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionApi
     */
    public apiInteractionVerificationWebauthnRegistrationPost(options?: RawAxiosRequestConfig) {
        return InteractionApiFp(this.configuration).apiInteractionVerificationWebauthnRegistrationPost(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationInvitationsApi - axios parameter creator
 * @export
 */
export const OrganizationInvitationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an organization invitation and optionally send it via email. The tenant should have an email connector configured if you want to send the invitation via email at this point.
         * @summary Create organization invitation
         * @param {CreateOrganizationInvitationRequest} createOrganizationInvitationRequest The organization invitation to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationInvitation: async (createOrganizationInvitationRequest: CreateOrganizationInvitationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrganizationInvitationRequest' is not null or undefined
            assertParamExists('createOrganizationInvitation', 'createOrganizationInvitationRequest', createOrganizationInvitationRequest)
            const localVarPath = `/api/organization-invitations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrganizationInvitationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resend the invitation message to the invitee.
         * @summary Resend invitation message
         * @param {string} id The unique identifier of the organization invitation.
         * @param {CreateOrganizationInvitationRequestMessagePayloadOneOf} createOrganizationInvitationRequestMessagePayloadOneOf The message payload for the \&quot;OrganizationInvitation\&quot; template to use when sending the invitation via email.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationInvitationMessage: async (id: string, createOrganizationInvitationRequestMessagePayloadOneOf: CreateOrganizationInvitationRequestMessagePayloadOneOf, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createOrganizationInvitationMessage', 'id', id)
            // verify required parameter 'createOrganizationInvitationRequestMessagePayloadOneOf' is not null or undefined
            assertParamExists('createOrganizationInvitationMessage', 'createOrganizationInvitationRequestMessagePayloadOneOf', createOrganizationInvitationRequestMessagePayloadOneOf)
            const localVarPath = `/api/organization-invitations/{id}/message`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrganizationInvitationRequestMessagePayloadOneOf, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an organization invitation by ID.
         * @summary Delete organization invitation
         * @param {string} id The unique identifier of the organization invitation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationInvitation: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOrganizationInvitation', 'id', id)
            const localVarPath = `/api/organization-invitations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an organization invitation by ID.
         * @summary Get organization invitation
         * @param {string} id The unique identifier of the organization invitation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInvitation: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrganizationInvitation', 'id', id)
            const localVarPath = `/api/organization-invitations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get organization invitations.
         * @summary Get organization invitations
         * @param {string} [organizationId] 
         * @param {string} [inviterId] 
         * @param {string} [invitee] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationInvitations: async (organizationId?: string, inviterId?: string, invitee?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/organization-invitations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (inviterId !== undefined) {
                localVarQueryParameter['inviterId'] = inviterId;
            }

            if (invitee !== undefined) {
                localVarQueryParameter['invitee'] = invitee;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the status of an organization invitation by ID.
         * @summary Update organization invitation status
         * @param {string} id The unique identifier of the organization invitation.
         * @param {ReplaceOrganizationInvitationStatusRequest} replaceOrganizationInvitationStatusRequest The organization invitation status to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceOrganizationInvitationStatus: async (id: string, replaceOrganizationInvitationStatusRequest: ReplaceOrganizationInvitationStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('replaceOrganizationInvitationStatus', 'id', id)
            // verify required parameter 'replaceOrganizationInvitationStatusRequest' is not null or undefined
            assertParamExists('replaceOrganizationInvitationStatus', 'replaceOrganizationInvitationStatusRequest', replaceOrganizationInvitationStatusRequest)
            const localVarPath = `/api/organization-invitations/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(replaceOrganizationInvitationStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationInvitationsApi - functional programming interface
 * @export
 */
export const OrganizationInvitationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationInvitationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an organization invitation and optionally send it via email. The tenant should have an email connector configured if you want to send the invitation via email at this point.
         * @summary Create organization invitation
         * @param {CreateOrganizationInvitationRequest} createOrganizationInvitationRequest The organization invitation to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationInvitation(createOrganizationInvitationRequest: CreateOrganizationInvitationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationInvitation(createOrganizationInvitationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationInvitationsApi.createOrganizationInvitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resend the invitation message to the invitee.
         * @summary Resend invitation message
         * @param {string} id The unique identifier of the organization invitation.
         * @param {CreateOrganizationInvitationRequestMessagePayloadOneOf} createOrganizationInvitationRequestMessagePayloadOneOf The message payload for the \&quot;OrganizationInvitation\&quot; template to use when sending the invitation via email.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationInvitationMessage(id: string, createOrganizationInvitationRequestMessagePayloadOneOf: CreateOrganizationInvitationRequestMessagePayloadOneOf, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationInvitationMessage(id, createOrganizationInvitationRequestMessagePayloadOneOf, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationInvitationsApi.createOrganizationInvitationMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an organization invitation by ID.
         * @summary Delete organization invitation
         * @param {string} id The unique identifier of the organization invitation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationInvitation(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationInvitation(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationInvitationsApi.deleteOrganizationInvitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an organization invitation by ID.
         * @summary Get organization invitation
         * @param {string} id The unique identifier of the organization invitation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationInvitation(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrganizationInvitation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationInvitation(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationInvitationsApi.getOrganizationInvitation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get organization invitations.
         * @summary Get organization invitations
         * @param {string} [organizationId] 
         * @param {string} [inviterId] 
         * @param {string} [invitee] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationInvitations(organizationId?: string, inviterId?: string, invitee?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOrganizationInvitation200Response>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationInvitations(organizationId, inviterId, invitee, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationInvitationsApi.listOrganizationInvitations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the status of an organization invitation by ID.
         * @summary Update organization invitation status
         * @param {string} id The unique identifier of the organization invitation.
         * @param {ReplaceOrganizationInvitationStatusRequest} replaceOrganizationInvitationStatusRequest The organization invitation status to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaceOrganizationInvitationStatus(id: string, replaceOrganizationInvitationStatusRequest: ReplaceOrganizationInvitationStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrganizationInvitation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceOrganizationInvitationStatus(id, replaceOrganizationInvitationStatusRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationInvitationsApi.replaceOrganizationInvitationStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationInvitationsApi - factory interface
 * @export
 */
export const OrganizationInvitationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationInvitationsApiFp(configuration)
    return {
        /**
         * Create an organization invitation and optionally send it via email. The tenant should have an email connector configured if you want to send the invitation via email at this point.
         * @summary Create organization invitation
         * @param {CreateOrganizationInvitationRequest} createOrganizationInvitationRequest The organization invitation to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationInvitation(createOrganizationInvitationRequest: CreateOrganizationInvitationRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createOrganizationInvitation(createOrganizationInvitationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Resend the invitation message to the invitee.
         * @summary Resend invitation message
         * @param {string} id The unique identifier of the organization invitation.
         * @param {CreateOrganizationInvitationRequestMessagePayloadOneOf} createOrganizationInvitationRequestMessagePayloadOneOf The message payload for the \&quot;OrganizationInvitation\&quot; template to use when sending the invitation via email.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationInvitationMessage(id: string, createOrganizationInvitationRequestMessagePayloadOneOf: CreateOrganizationInvitationRequestMessagePayloadOneOf, options?: any): AxiosPromise<void> {
            return localVarFp.createOrganizationInvitationMessage(id, createOrganizationInvitationRequestMessagePayloadOneOf, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an organization invitation by ID.
         * @summary Delete organization invitation
         * @param {string} id The unique identifier of the organization invitation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationInvitation(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganizationInvitation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an organization invitation by ID.
         * @summary Get organization invitation
         * @param {string} id The unique identifier of the organization invitation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInvitation(id: string, options?: any): AxiosPromise<GetOrganizationInvitation200Response> {
            return localVarFp.getOrganizationInvitation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organization invitations.
         * @summary Get organization invitations
         * @param {string} [organizationId] 
         * @param {string} [inviterId] 
         * @param {string} [invitee] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationInvitations(organizationId?: string, inviterId?: string, invitee?: string, options?: any): AxiosPromise<Array<GetOrganizationInvitation200Response>> {
            return localVarFp.listOrganizationInvitations(organizationId, inviterId, invitee, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the status of an organization invitation by ID.
         * @summary Update organization invitation status
         * @param {string} id The unique identifier of the organization invitation.
         * @param {ReplaceOrganizationInvitationStatusRequest} replaceOrganizationInvitationStatusRequest The organization invitation status to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceOrganizationInvitationStatus(id: string, replaceOrganizationInvitationStatusRequest: ReplaceOrganizationInvitationStatusRequest, options?: any): AxiosPromise<GetOrganizationInvitation200Response> {
            return localVarFp.replaceOrganizationInvitationStatus(id, replaceOrganizationInvitationStatusRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationInvitationsApi - object-oriented interface
 * @export
 * @class OrganizationInvitationsApi
 * @extends {BaseAPI}
 */
export class OrganizationInvitationsApi extends BaseAPI {
    /**
     * Create an organization invitation and optionally send it via email. The tenant should have an email connector configured if you want to send the invitation via email at this point.
     * @summary Create organization invitation
     * @param {CreateOrganizationInvitationRequest} createOrganizationInvitationRequest The organization invitation to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationInvitationsApi
     */
    public createOrganizationInvitation(createOrganizationInvitationRequest: CreateOrganizationInvitationRequest, options?: RawAxiosRequestConfig) {
        return OrganizationInvitationsApiFp(this.configuration).createOrganizationInvitation(createOrganizationInvitationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resend the invitation message to the invitee.
     * @summary Resend invitation message
     * @param {string} id The unique identifier of the organization invitation.
     * @param {CreateOrganizationInvitationRequestMessagePayloadOneOf} createOrganizationInvitationRequestMessagePayloadOneOf The message payload for the \&quot;OrganizationInvitation\&quot; template to use when sending the invitation via email.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationInvitationsApi
     */
    public createOrganizationInvitationMessage(id: string, createOrganizationInvitationRequestMessagePayloadOneOf: CreateOrganizationInvitationRequestMessagePayloadOneOf, options?: RawAxiosRequestConfig) {
        return OrganizationInvitationsApiFp(this.configuration).createOrganizationInvitationMessage(id, createOrganizationInvitationRequestMessagePayloadOneOf, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an organization invitation by ID.
     * @summary Delete organization invitation
     * @param {string} id The unique identifier of the organization invitation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationInvitationsApi
     */
    public deleteOrganizationInvitation(id: string, options?: RawAxiosRequestConfig) {
        return OrganizationInvitationsApiFp(this.configuration).deleteOrganizationInvitation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an organization invitation by ID.
     * @summary Get organization invitation
     * @param {string} id The unique identifier of the organization invitation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationInvitationsApi
     */
    public getOrganizationInvitation(id: string, options?: RawAxiosRequestConfig) {
        return OrganizationInvitationsApiFp(this.configuration).getOrganizationInvitation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get organization invitations.
     * @summary Get organization invitations
     * @param {string} [organizationId] 
     * @param {string} [inviterId] 
     * @param {string} [invitee] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationInvitationsApi
     */
    public listOrganizationInvitations(organizationId?: string, inviterId?: string, invitee?: string, options?: RawAxiosRequestConfig) {
        return OrganizationInvitationsApiFp(this.configuration).listOrganizationInvitations(organizationId, inviterId, invitee, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the status of an organization invitation by ID.
     * @summary Update organization invitation status
     * @param {string} id The unique identifier of the organization invitation.
     * @param {ReplaceOrganizationInvitationStatusRequest} replaceOrganizationInvitationStatusRequest The organization invitation status to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationInvitationsApi
     */
    public replaceOrganizationInvitationStatus(id: string, replaceOrganizationInvitationStatusRequest: ReplaceOrganizationInvitationStatusRequest, options?: RawAxiosRequestConfig) {
        return OrganizationInvitationsApiFp(this.configuration).replaceOrganizationInvitationStatus(id, replaceOrganizationInvitationStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationRolesApi - axios parameter creator
 * @export
 */
export const OrganizationRolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new organization role with the given data.
         * @summary Create an organization role
         * @param {CreateOrganizationRoleRequest} createOrganizationRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationRole: async (createOrganizationRoleRequest: CreateOrganizationRoleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrganizationRoleRequest' is not null or undefined
            assertParamExists('createOrganizationRole', 'createOrganizationRoleRequest', createOrganizationRoleRequest)
            const localVarPath = `/api/organization-roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrganizationRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign resource scopes to the specified organization role
         * @summary Assign resource scopes to organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {CreateOrganizationRoleResourceScopeRequest} createOrganizationRoleResourceScopeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationRoleResourceScope: async (id: string, createOrganizationRoleResourceScopeRequest: CreateOrganizationRoleResourceScopeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createOrganizationRoleResourceScope', 'id', id)
            // verify required parameter 'createOrganizationRoleResourceScopeRequest' is not null or undefined
            assertParamExists('createOrganizationRoleResourceScope', 'createOrganizationRoleResourceScopeRequest', createOrganizationRoleResourceScopeRequest)
            const localVarPath = `/api/organization-roles/{id}/resource-scopes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrganizationRoleResourceScopeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign organization scopes to the specified organization role
         * @summary Assign organization scopes to organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {CreateOrganizationRoleScopeRequest} createOrganizationRoleScopeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationRoleScope: async (id: string, createOrganizationRoleScopeRequest: CreateOrganizationRoleScopeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createOrganizationRoleScope', 'id', id)
            // verify required parameter 'createOrganizationRoleScopeRequest' is not null or undefined
            assertParamExists('createOrganizationRoleScope', 'createOrganizationRoleScopeRequest', createOrganizationRoleScopeRequest)
            const localVarPath = `/api/organization-roles/{id}/scopes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrganizationRoleScopeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete organization role by ID.
         * @summary Delete organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationRole: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOrganizationRole', 'id', id)
            const localVarPath = `/api/organization-roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a resource scope assignment from the specified organization role.
         * @summary Remove resource scope
         * @param {string} id The unique identifier of the organization role.
         * @param {string} scopeId The unique identifier of the scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationRoleResourceScope: async (id: string, scopeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOrganizationRoleResourceScope', 'id', id)
            // verify required parameter 'scopeId' is not null or undefined
            assertParamExists('deleteOrganizationRoleResourceScope', 'scopeId', scopeId)
            const localVarPath = `/api/organization-roles/{id}/resource-scopes/{scopeId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"scopeId"}}`, encodeURIComponent(String(scopeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a organization scope assignment from the specified organization role.
         * @summary Remove organization scope
         * @param {string} id The unique identifier of the organization role.
         * @param {string} organizationScopeId The unique identifier of the organization scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationRoleScope: async (id: string, organizationScopeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOrganizationRoleScope', 'id', id)
            // verify required parameter 'organizationScopeId' is not null or undefined
            assertParamExists('deleteOrganizationRoleScope', 'organizationScopeId', organizationScopeId)
            const localVarPath = `/api/organization-roles/{id}/scopes/{organizationScopeId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"organizationScopeId"}}`, encodeURIComponent(String(organizationScopeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get organization role details by ID.
         * @summary Get organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationRole: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrganizationRole', 'id', id)
            const localVarPath = `/api/organization-roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all resource scopes that are assigned to the specified organization role.
         * @summary Get organization role resource scopes
         * @param {string} id The unique identifier of the organization role.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationRoleResourceScopes: async (id: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listOrganizationRoleResourceScopes', 'id', id)
            const localVarPath = `/api/organization-roles/{id}/resource-scopes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all organization scopes that are assigned to the specified organization role.
         * @summary Get organization role scopes
         * @param {string} id The unique identifier of the organization role.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationRoleScopes: async (id: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listOrganizationRoleScopes', 'id', id)
            const localVarPath = `/api/organization-roles/{id}/scopes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get organization roles with pagination.
         * @summary Get organization roles
         * @param {string} [q] 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationRoles: async (q?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/organization-roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace all resource scopes that are assigned to the specified organization role with the given resource scopes. This effectively removes all existing organization scope assignments and replaces them with the new ones.
         * @summary Replace resource scopes for organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {ReplaceOrganizationRoleResourceScopesRequest} replaceOrganizationRoleResourceScopesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceOrganizationRoleResourceScopes: async (id: string, replaceOrganizationRoleResourceScopesRequest: ReplaceOrganizationRoleResourceScopesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('replaceOrganizationRoleResourceScopes', 'id', id)
            // verify required parameter 'replaceOrganizationRoleResourceScopesRequest' is not null or undefined
            assertParamExists('replaceOrganizationRoleResourceScopes', 'replaceOrganizationRoleResourceScopesRequest', replaceOrganizationRoleResourceScopesRequest)
            const localVarPath = `/api/organization-roles/{id}/resource-scopes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(replaceOrganizationRoleResourceScopesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace all organization scopes that are assigned to the specified organization role with the given organization scopes. This effectively removes all existing organization scope assignments and replaces them with the new ones.
         * @summary Replace organization scopes for organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {ReplaceOrganizationRoleScopesRequest} replaceOrganizationRoleScopesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceOrganizationRoleScopes: async (id: string, replaceOrganizationRoleScopesRequest: ReplaceOrganizationRoleScopesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('replaceOrganizationRoleScopes', 'id', id)
            // verify required parameter 'replaceOrganizationRoleScopesRequest' is not null or undefined
            assertParamExists('replaceOrganizationRoleScopes', 'replaceOrganizationRoleScopesRequest', replaceOrganizationRoleScopesRequest)
            const localVarPath = `/api/organization-roles/{id}/scopes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(replaceOrganizationRoleScopesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update organization role details by ID with the given data.
         * @summary Update organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {UpdateOrganizationRoleRequest} updateOrganizationRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationRole: async (id: string, updateOrganizationRoleRequest: UpdateOrganizationRoleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateOrganizationRole', 'id', id)
            // verify required parameter 'updateOrganizationRoleRequest' is not null or undefined
            assertParamExists('updateOrganizationRole', 'updateOrganizationRoleRequest', updateOrganizationRoleRequest)
            const localVarPath = `/api/organization-roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrganizationRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationRolesApi - functional programming interface
 * @export
 */
export const OrganizationRolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationRolesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new organization role with the given data.
         * @summary Create an organization role
         * @param {CreateOrganizationRoleRequest} createOrganizationRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationRole(createOrganizationRoleRequest: CreateOrganizationRoleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationRole(createOrganizationRoleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationRolesApi.createOrganizationRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Assign resource scopes to the specified organization role
         * @summary Assign resource scopes to organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {CreateOrganizationRoleResourceScopeRequest} createOrganizationRoleResourceScopeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationRoleResourceScope(id: string, createOrganizationRoleResourceScopeRequest: CreateOrganizationRoleResourceScopeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationRoleResourceScope(id, createOrganizationRoleResourceScopeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationRolesApi.createOrganizationRoleResourceScope']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Assign organization scopes to the specified organization role
         * @summary Assign organization scopes to organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {CreateOrganizationRoleScopeRequest} createOrganizationRoleScopeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationRoleScope(id: string, createOrganizationRoleScopeRequest: CreateOrganizationRoleScopeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationRoleScope(id, createOrganizationRoleScopeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationRolesApi.createOrganizationRoleScope']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete organization role by ID.
         * @summary Delete organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationRole(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationRole(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationRolesApi.deleteOrganizationRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a resource scope assignment from the specified organization role.
         * @summary Remove resource scope
         * @param {string} id The unique identifier of the organization role.
         * @param {string} scopeId The unique identifier of the scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationRoleResourceScope(id: string, scopeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationRoleResourceScope(id, scopeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationRolesApi.deleteOrganizationRoleResourceScope']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a organization scope assignment from the specified organization role.
         * @summary Remove organization scope
         * @param {string} id The unique identifier of the organization role.
         * @param {string} organizationScopeId The unique identifier of the organization scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationRoleScope(id: string, organizationScopeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationRoleScope(id, organizationScopeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationRolesApi.deleteOrganizationRoleScope']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get organization role details by ID.
         * @summary Get organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationRole(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrganizationRole200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationRole(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationRolesApi.getOrganizationRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all resource scopes that are assigned to the specified organization role.
         * @summary Get organization role resource scopes
         * @param {string} id The unique identifier of the organization role.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationRoleResourceScopes(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListResources200ResponseInnerScopesInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationRoleResourceScopes(id, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationRolesApi.listOrganizationRoleResourceScopes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all organization scopes that are assigned to the specified organization role.
         * @summary Get organization role scopes
         * @param {string} id The unique identifier of the organization role.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationRoleScopes(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListOrganizationRoleScopes200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationRoleScopes(id, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationRolesApi.listOrganizationRoleScopes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get organization roles with pagination.
         * @summary Get organization roles
         * @param {string} [q] 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationRoles(q?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListOrganizationRoles200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationRoles(q, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationRolesApi.listOrganizationRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replace all resource scopes that are assigned to the specified organization role with the given resource scopes. This effectively removes all existing organization scope assignments and replaces them with the new ones.
         * @summary Replace resource scopes for organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {ReplaceOrganizationRoleResourceScopesRequest} replaceOrganizationRoleResourceScopesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaceOrganizationRoleResourceScopes(id: string, replaceOrganizationRoleResourceScopesRequest: ReplaceOrganizationRoleResourceScopesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceOrganizationRoleResourceScopes(id, replaceOrganizationRoleResourceScopesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationRolesApi.replaceOrganizationRoleResourceScopes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replace all organization scopes that are assigned to the specified organization role with the given organization scopes. This effectively removes all existing organization scope assignments and replaces them with the new ones.
         * @summary Replace organization scopes for organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {ReplaceOrganizationRoleScopesRequest} replaceOrganizationRoleScopesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaceOrganizationRoleScopes(id: string, replaceOrganizationRoleScopesRequest: ReplaceOrganizationRoleScopesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceOrganizationRoleScopes(id, replaceOrganizationRoleScopesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationRolesApi.replaceOrganizationRoleScopes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update organization role details by ID with the given data.
         * @summary Update organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {UpdateOrganizationRoleRequest} updateOrganizationRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganizationRole(id: string, updateOrganizationRoleRequest: UpdateOrganizationRoleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrganizationRole200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganizationRole(id, updateOrganizationRoleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationRolesApi.updateOrganizationRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationRolesApi - factory interface
 * @export
 */
export const OrganizationRolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationRolesApiFp(configuration)
    return {
        /**
         * Create a new organization role with the given data.
         * @summary Create an organization role
         * @param {CreateOrganizationRoleRequest} createOrganizationRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationRole(createOrganizationRoleRequest: CreateOrganizationRoleRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createOrganizationRole(createOrganizationRoleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign resource scopes to the specified organization role
         * @summary Assign resource scopes to organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {CreateOrganizationRoleResourceScopeRequest} createOrganizationRoleResourceScopeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationRoleResourceScope(id: string, createOrganizationRoleResourceScopeRequest: CreateOrganizationRoleResourceScopeRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createOrganizationRoleResourceScope(id, createOrganizationRoleResourceScopeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign organization scopes to the specified organization role
         * @summary Assign organization scopes to organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {CreateOrganizationRoleScopeRequest} createOrganizationRoleScopeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationRoleScope(id: string, createOrganizationRoleScopeRequest: CreateOrganizationRoleScopeRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createOrganizationRoleScope(id, createOrganizationRoleScopeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete organization role by ID.
         * @summary Delete organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationRole(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganizationRole(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a resource scope assignment from the specified organization role.
         * @summary Remove resource scope
         * @param {string} id The unique identifier of the organization role.
         * @param {string} scopeId The unique identifier of the scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationRoleResourceScope(id: string, scopeId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganizationRoleResourceScope(id, scopeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a organization scope assignment from the specified organization role.
         * @summary Remove organization scope
         * @param {string} id The unique identifier of the organization role.
         * @param {string} organizationScopeId The unique identifier of the organization scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationRoleScope(id: string, organizationScopeId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganizationRoleScope(id, organizationScopeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organization role details by ID.
         * @summary Get organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationRole(id: string, options?: any): AxiosPromise<GetOrganizationRole200Response> {
            return localVarFp.getOrganizationRole(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all resource scopes that are assigned to the specified organization role.
         * @summary Get organization role resource scopes
         * @param {string} id The unique identifier of the organization role.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationRoleResourceScopes(id: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ListResources200ResponseInnerScopesInner>> {
            return localVarFp.listOrganizationRoleResourceScopes(id, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all organization scopes that are assigned to the specified organization role.
         * @summary Get organization role scopes
         * @param {string} id The unique identifier of the organization role.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationRoleScopes(id: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ListOrganizationRoleScopes200ResponseInner>> {
            return localVarFp.listOrganizationRoleScopes(id, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organization roles with pagination.
         * @summary Get organization roles
         * @param {string} [q] 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationRoles(q?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ListOrganizationRoles200ResponseInner>> {
            return localVarFp.listOrganizationRoles(q, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace all resource scopes that are assigned to the specified organization role with the given resource scopes. This effectively removes all existing organization scope assignments and replaces them with the new ones.
         * @summary Replace resource scopes for organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {ReplaceOrganizationRoleResourceScopesRequest} replaceOrganizationRoleResourceScopesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceOrganizationRoleResourceScopes(id: string, replaceOrganizationRoleResourceScopesRequest: ReplaceOrganizationRoleResourceScopesRequest, options?: any): AxiosPromise<void> {
            return localVarFp.replaceOrganizationRoleResourceScopes(id, replaceOrganizationRoleResourceScopesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace all organization scopes that are assigned to the specified organization role with the given organization scopes. This effectively removes all existing organization scope assignments and replaces them with the new ones.
         * @summary Replace organization scopes for organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {ReplaceOrganizationRoleScopesRequest} replaceOrganizationRoleScopesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceOrganizationRoleScopes(id: string, replaceOrganizationRoleScopesRequest: ReplaceOrganizationRoleScopesRequest, options?: any): AxiosPromise<void> {
            return localVarFp.replaceOrganizationRoleScopes(id, replaceOrganizationRoleScopesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update organization role details by ID with the given data.
         * @summary Update organization role
         * @param {string} id The unique identifier of the organization role.
         * @param {UpdateOrganizationRoleRequest} updateOrganizationRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationRole(id: string, updateOrganizationRoleRequest: UpdateOrganizationRoleRequest, options?: any): AxiosPromise<GetOrganizationRole200Response> {
            return localVarFp.updateOrganizationRole(id, updateOrganizationRoleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationRolesApi - object-oriented interface
 * @export
 * @class OrganizationRolesApi
 * @extends {BaseAPI}
 */
export class OrganizationRolesApi extends BaseAPI {
    /**
     * Create a new organization role with the given data.
     * @summary Create an organization role
     * @param {CreateOrganizationRoleRequest} createOrganizationRoleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRolesApi
     */
    public createOrganizationRole(createOrganizationRoleRequest: CreateOrganizationRoleRequest, options?: RawAxiosRequestConfig) {
        return OrganizationRolesApiFp(this.configuration).createOrganizationRole(createOrganizationRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assign resource scopes to the specified organization role
     * @summary Assign resource scopes to organization role
     * @param {string} id The unique identifier of the organization role.
     * @param {CreateOrganizationRoleResourceScopeRequest} createOrganizationRoleResourceScopeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRolesApi
     */
    public createOrganizationRoleResourceScope(id: string, createOrganizationRoleResourceScopeRequest: CreateOrganizationRoleResourceScopeRequest, options?: RawAxiosRequestConfig) {
        return OrganizationRolesApiFp(this.configuration).createOrganizationRoleResourceScope(id, createOrganizationRoleResourceScopeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assign organization scopes to the specified organization role
     * @summary Assign organization scopes to organization role
     * @param {string} id The unique identifier of the organization role.
     * @param {CreateOrganizationRoleScopeRequest} createOrganizationRoleScopeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRolesApi
     */
    public createOrganizationRoleScope(id: string, createOrganizationRoleScopeRequest: CreateOrganizationRoleScopeRequest, options?: RawAxiosRequestConfig) {
        return OrganizationRolesApiFp(this.configuration).createOrganizationRoleScope(id, createOrganizationRoleScopeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete organization role by ID.
     * @summary Delete organization role
     * @param {string} id The unique identifier of the organization role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRolesApi
     */
    public deleteOrganizationRole(id: string, options?: RawAxiosRequestConfig) {
        return OrganizationRolesApiFp(this.configuration).deleteOrganizationRole(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a resource scope assignment from the specified organization role.
     * @summary Remove resource scope
     * @param {string} id The unique identifier of the organization role.
     * @param {string} scopeId The unique identifier of the scope.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRolesApi
     */
    public deleteOrganizationRoleResourceScope(id: string, scopeId: string, options?: RawAxiosRequestConfig) {
        return OrganizationRolesApiFp(this.configuration).deleteOrganizationRoleResourceScope(id, scopeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a organization scope assignment from the specified organization role.
     * @summary Remove organization scope
     * @param {string} id The unique identifier of the organization role.
     * @param {string} organizationScopeId The unique identifier of the organization scope.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRolesApi
     */
    public deleteOrganizationRoleScope(id: string, organizationScopeId: string, options?: RawAxiosRequestConfig) {
        return OrganizationRolesApiFp(this.configuration).deleteOrganizationRoleScope(id, organizationScopeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get organization role details by ID.
     * @summary Get organization role
     * @param {string} id The unique identifier of the organization role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRolesApi
     */
    public getOrganizationRole(id: string, options?: RawAxiosRequestConfig) {
        return OrganizationRolesApiFp(this.configuration).getOrganizationRole(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all resource scopes that are assigned to the specified organization role.
     * @summary Get organization role resource scopes
     * @param {string} id The unique identifier of the organization role.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRolesApi
     */
    public listOrganizationRoleResourceScopes(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return OrganizationRolesApiFp(this.configuration).listOrganizationRoleResourceScopes(id, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all organization scopes that are assigned to the specified organization role.
     * @summary Get organization role scopes
     * @param {string} id The unique identifier of the organization role.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRolesApi
     */
    public listOrganizationRoleScopes(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return OrganizationRolesApiFp(this.configuration).listOrganizationRoleScopes(id, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get organization roles with pagination.
     * @summary Get organization roles
     * @param {string} [q] 
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRolesApi
     */
    public listOrganizationRoles(q?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return OrganizationRolesApiFp(this.configuration).listOrganizationRoles(q, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace all resource scopes that are assigned to the specified organization role with the given resource scopes. This effectively removes all existing organization scope assignments and replaces them with the new ones.
     * @summary Replace resource scopes for organization role
     * @param {string} id The unique identifier of the organization role.
     * @param {ReplaceOrganizationRoleResourceScopesRequest} replaceOrganizationRoleResourceScopesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRolesApi
     */
    public replaceOrganizationRoleResourceScopes(id: string, replaceOrganizationRoleResourceScopesRequest: ReplaceOrganizationRoleResourceScopesRequest, options?: RawAxiosRequestConfig) {
        return OrganizationRolesApiFp(this.configuration).replaceOrganizationRoleResourceScopes(id, replaceOrganizationRoleResourceScopesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace all organization scopes that are assigned to the specified organization role with the given organization scopes. This effectively removes all existing organization scope assignments and replaces them with the new ones.
     * @summary Replace organization scopes for organization role
     * @param {string} id The unique identifier of the organization role.
     * @param {ReplaceOrganizationRoleScopesRequest} replaceOrganizationRoleScopesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRolesApi
     */
    public replaceOrganizationRoleScopes(id: string, replaceOrganizationRoleScopesRequest: ReplaceOrganizationRoleScopesRequest, options?: RawAxiosRequestConfig) {
        return OrganizationRolesApiFp(this.configuration).replaceOrganizationRoleScopes(id, replaceOrganizationRoleScopesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update organization role details by ID with the given data.
     * @summary Update organization role
     * @param {string} id The unique identifier of the organization role.
     * @param {UpdateOrganizationRoleRequest} updateOrganizationRoleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationRolesApi
     */
    public updateOrganizationRole(id: string, updateOrganizationRoleRequest: UpdateOrganizationRoleRequest, options?: RawAxiosRequestConfig) {
        return OrganizationRolesApiFp(this.configuration).updateOrganizationRole(id, updateOrganizationRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationScopesApi - axios parameter creator
 * @export
 */
export const OrganizationScopesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new organization scope with the given data.
         * @summary Create an organization scope
         * @param {CreateOrganizationScopeRequest} createOrganizationScopeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationScope: async (createOrganizationScopeRequest: CreateOrganizationScopeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrganizationScopeRequest' is not null or undefined
            assertParamExists('createOrganizationScope', 'createOrganizationScopeRequest', createOrganizationScopeRequest)
            const localVarPath = `/api/organization-scopes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrganizationScopeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete organization scope by ID.
         * @summary Delete organization scope
         * @param {string} id The unique identifier of the organization scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationScope: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOrganizationScope', 'id', id)
            const localVarPath = `/api/organization-scopes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get organization scope details by ID.
         * @summary Get organization scope
         * @param {string} id The unique identifier of the organization scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationScope: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrganizationScope', 'id', id)
            const localVarPath = `/api/organization-scopes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get organization scopes that match with pagination.
         * @summary Get organization scopes
         * @param {string} [q] 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationScopes: async (q?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/organization-scopes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update organization scope details by ID with the given data.
         * @summary Update organization scope
         * @param {string} id The unique identifier of the organization scope.
         * @param {UpdateOrganizationScopeRequest} updateOrganizationScopeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationScope: async (id: string, updateOrganizationScopeRequest: UpdateOrganizationScopeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateOrganizationScope', 'id', id)
            // verify required parameter 'updateOrganizationScopeRequest' is not null or undefined
            assertParamExists('updateOrganizationScope', 'updateOrganizationScopeRequest', updateOrganizationScopeRequest)
            const localVarPath = `/api/organization-scopes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrganizationScopeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationScopesApi - functional programming interface
 * @export
 */
export const OrganizationScopesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationScopesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new organization scope with the given data.
         * @summary Create an organization scope
         * @param {CreateOrganizationScopeRequest} createOrganizationScopeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationScope(createOrganizationScopeRequest: CreateOrganizationScopeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationScope(createOrganizationScopeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationScopesApi.createOrganizationScope']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete organization scope by ID.
         * @summary Delete organization scope
         * @param {string} id The unique identifier of the organization scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationScope(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationScope(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationScopesApi.deleteOrganizationScope']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get organization scope details by ID.
         * @summary Get organization scope
         * @param {string} id The unique identifier of the organization scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationScope(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOrganizationRoleScopes200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationScope(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationScopesApi.getOrganizationScope']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get organization scopes that match with pagination.
         * @summary Get organization scopes
         * @param {string} [q] 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationScopes(q?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListOrganizationRoleScopes200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationScopes(q, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationScopesApi.listOrganizationScopes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update organization scope details by ID with the given data.
         * @summary Update organization scope
         * @param {string} id The unique identifier of the organization scope.
         * @param {UpdateOrganizationScopeRequest} updateOrganizationScopeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganizationScope(id: string, updateOrganizationScopeRequest: UpdateOrganizationScopeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOrganizationRoleScopes200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganizationScope(id, updateOrganizationScopeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationScopesApi.updateOrganizationScope']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationScopesApi - factory interface
 * @export
 */
export const OrganizationScopesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationScopesApiFp(configuration)
    return {
        /**
         * Create a new organization scope with the given data.
         * @summary Create an organization scope
         * @param {CreateOrganizationScopeRequest} createOrganizationScopeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationScope(createOrganizationScopeRequest: CreateOrganizationScopeRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createOrganizationScope(createOrganizationScopeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete organization scope by ID.
         * @summary Delete organization scope
         * @param {string} id The unique identifier of the organization scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationScope(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganizationScope(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organization scope details by ID.
         * @summary Get organization scope
         * @param {string} id The unique identifier of the organization scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationScope(id: string, options?: any): AxiosPromise<ListOrganizationRoleScopes200ResponseInner> {
            return localVarFp.getOrganizationScope(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organization scopes that match with pagination.
         * @summary Get organization scopes
         * @param {string} [q] 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationScopes(q?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ListOrganizationRoleScopes200ResponseInner>> {
            return localVarFp.listOrganizationScopes(q, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Update organization scope details by ID with the given data.
         * @summary Update organization scope
         * @param {string} id The unique identifier of the organization scope.
         * @param {UpdateOrganizationScopeRequest} updateOrganizationScopeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationScope(id: string, updateOrganizationScopeRequest: UpdateOrganizationScopeRequest, options?: any): AxiosPromise<ListOrganizationRoleScopes200ResponseInner> {
            return localVarFp.updateOrganizationScope(id, updateOrganizationScopeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationScopesApi - object-oriented interface
 * @export
 * @class OrganizationScopesApi
 * @extends {BaseAPI}
 */
export class OrganizationScopesApi extends BaseAPI {
    /**
     * Create a new organization scope with the given data.
     * @summary Create an organization scope
     * @param {CreateOrganizationScopeRequest} createOrganizationScopeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationScopesApi
     */
    public createOrganizationScope(createOrganizationScopeRequest: CreateOrganizationScopeRequest, options?: RawAxiosRequestConfig) {
        return OrganizationScopesApiFp(this.configuration).createOrganizationScope(createOrganizationScopeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete organization scope by ID.
     * @summary Delete organization scope
     * @param {string} id The unique identifier of the organization scope.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationScopesApi
     */
    public deleteOrganizationScope(id: string, options?: RawAxiosRequestConfig) {
        return OrganizationScopesApiFp(this.configuration).deleteOrganizationScope(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get organization scope details by ID.
     * @summary Get organization scope
     * @param {string} id The unique identifier of the organization scope.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationScopesApi
     */
    public getOrganizationScope(id: string, options?: RawAxiosRequestConfig) {
        return OrganizationScopesApiFp(this.configuration).getOrganizationScope(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get organization scopes that match with pagination.
     * @summary Get organization scopes
     * @param {string} [q] 
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationScopesApi
     */
    public listOrganizationScopes(q?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return OrganizationScopesApiFp(this.configuration).listOrganizationScopes(q, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update organization scope details by ID with the given data.
     * @summary Update organization scope
     * @param {string} id The unique identifier of the organization scope.
     * @param {UpdateOrganizationScopeRequest} updateOrganizationScopeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationScopesApi
     */
    public updateOrganizationScope(id: string, updateOrganizationScopeRequest: UpdateOrganizationScopeRequest, options?: RawAxiosRequestConfig) {
        return OrganizationScopesApiFp(this.configuration).updateOrganizationScope(id, updateOrganizationScopeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationsApi - axios parameter creator
 * @export
 */
export const OrganizationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add an application to the organization.
         * @summary Add organization application
         * @param {string} id The unique identifier of the organization.
         * @param {AddOrganizationApplicationsRequest} addOrganizationApplicationsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganizationApplications: async (id: string, addOrganizationApplicationsRequest: AddOrganizationApplicationsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addOrganizationApplications', 'id', id)
            // verify required parameter 'addOrganizationApplicationsRequest' is not null or undefined
            assertParamExists('addOrganizationApplications', 'addOrganizationApplicationsRequest', addOrganizationApplicationsRequest)
            const localVarPath = `/api/organizations/{id}/applications`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addOrganizationApplicationsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add users as members to the specified organization with the given user IDs.
         * @summary Add user members to organization
         * @param {string} id The unique identifier of the organization.
         * @param {AddOrganizationUsersRequest} addOrganizationUsersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganizationUsers: async (id: string, addOrganizationUsersRequest: AddOrganizationUsersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addOrganizationUsers', 'id', id)
            // verify required parameter 'addOrganizationUsersRequest' is not null or undefined
            assertParamExists('addOrganizationUsers', 'addOrganizationUsersRequest', addOrganizationUsersRequest)
            const localVarPath = `/api/organizations/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addOrganizationUsersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a role to the application in the organization.
         * @summary Add organization application role
         * @param {string} id The unique identifier of the organization.
         * @param {string} applicationId The unique identifier of the application.
         * @param {AssignOrganizationRolesToApplicationRequest} assignOrganizationRolesToApplicationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignOrganizationRolesToApplication: async (id: string, applicationId: string, assignOrganizationRolesToApplicationRequest: AssignOrganizationRolesToApplicationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('assignOrganizationRolesToApplication', 'id', id)
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('assignOrganizationRolesToApplication', 'applicationId', applicationId)
            // verify required parameter 'assignOrganizationRolesToApplicationRequest' is not null or undefined
            assertParamExists('assignOrganizationRolesToApplication', 'assignOrganizationRolesToApplicationRequest', assignOrganizationRolesToApplicationRequest)
            const localVarPath = `/api/organizations/{id}/applications/{applicationId}/roles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignOrganizationRolesToApplicationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign roles to applications in the specified organization.
         * @summary Assign roles to applications in an organization
         * @param {string} id The unique identifier of the organization.
         * @param {AssignOrganizationRolesToApplicationsRequest} assignOrganizationRolesToApplicationsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignOrganizationRolesToApplications: async (id: string, assignOrganizationRolesToApplicationsRequest: AssignOrganizationRolesToApplicationsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('assignOrganizationRolesToApplications', 'id', id)
            // verify required parameter 'assignOrganizationRolesToApplicationsRequest' is not null or undefined
            assertParamExists('assignOrganizationRolesToApplications', 'assignOrganizationRolesToApplicationsRequest', assignOrganizationRolesToApplicationsRequest)
            const localVarPath = `/api/organizations/{id}/applications/roles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignOrganizationRolesToApplicationsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign roles to a user in the specified organization with the provided data.
         * @summary Assign roles to a user in an organization
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {AssignOrganizationRolesToUserRequest} assignOrganizationRolesToUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignOrganizationRolesToUser: async (id: string, userId: string, assignOrganizationRolesToUserRequest: AssignOrganizationRolesToUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('assignOrganizationRolesToUser', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('assignOrganizationRolesToUser', 'userId', userId)
            // verify required parameter 'assignOrganizationRolesToUserRequest' is not null or undefined
            assertParamExists('assignOrganizationRolesToUser', 'assignOrganizationRolesToUserRequest', assignOrganizationRolesToUserRequest)
            const localVarPath = `/api/organizations/{id}/users/{userId}/roles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignOrganizationRolesToUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign roles to user members of the specified organization.
         * @summary Assign roles to organization user members
         * @param {string} id The unique identifier of the organization.
         * @param {AssignOrganizationRolesToUsersRequest} assignOrganizationRolesToUsersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignOrganizationRolesToUsers: async (id: string, assignOrganizationRolesToUsersRequest: AssignOrganizationRolesToUsersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('assignOrganizationRolesToUsers', 'id', id)
            // verify required parameter 'assignOrganizationRolesToUsersRequest' is not null or undefined
            assertParamExists('assignOrganizationRolesToUsers', 'assignOrganizationRolesToUsersRequest', assignOrganizationRolesToUsersRequest)
            const localVarPath = `/api/organizations/{id}/users/roles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignOrganizationRolesToUsersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new organization with the given data.
         * @summary Create an organization
         * @param {CreateOrganizationRequest} createOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization: async (createOrganizationRequest: CreateOrganizationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrganizationRequest' is not null or undefined
            assertParamExists('createOrganization', 'createOrganizationRequest', createOrganizationRequest)
            const localVarPath = `/api/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrganizationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new email domain for just-in-time provisioning of users in the organization.
         * @summary Add organization JIT email domain
         * @param {string} id The unique identifier of the organization.
         * @param {CreateOrganizationJitEmailDomainRequest} createOrganizationJitEmailDomainRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationJitEmailDomain: async (id: string, createOrganizationJitEmailDomainRequest: CreateOrganizationJitEmailDomainRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createOrganizationJitEmailDomain', 'id', id)
            // verify required parameter 'createOrganizationJitEmailDomainRequest' is not null or undefined
            assertParamExists('createOrganizationJitEmailDomain', 'createOrganizationJitEmailDomainRequest', createOrganizationJitEmailDomainRequest)
            const localVarPath = `/api/organizations/{id}/jit/email-domains`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrganizationJitEmailDomainRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add new organization roles that will be assigned to users during just-in-time provisioning.
         * @summary Add organization JIT default roles
         * @param {string} id The unique identifier of the organization.
         * @param {CreateOrganizationJitRoleRequest} createOrganizationJitRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationJitRole: async (id: string, createOrganizationJitRoleRequest: CreateOrganizationJitRoleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createOrganizationJitRole', 'id', id)
            // verify required parameter 'createOrganizationJitRoleRequest' is not null or undefined
            assertParamExists('createOrganizationJitRole', 'createOrganizationJitRoleRequest', createOrganizationJitRoleRequest)
            const localVarPath = `/api/organizations/{id}/jit/roles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrganizationJitRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add new enterprise SSO connectors for just-in-time provisioning of users in the organization.
         * @summary Add organization JIT SSO connectors
         * @param {string} id The unique identifier of the organization.
         * @param {CreateOrganizationJitSsoConnectorRequest} createOrganizationJitSsoConnectorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationJitSsoConnector: async (id: string, createOrganizationJitSsoConnectorRequest: CreateOrganizationJitSsoConnectorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createOrganizationJitSsoConnector', 'id', id)
            // verify required parameter 'createOrganizationJitSsoConnectorRequest' is not null or undefined
            assertParamExists('createOrganizationJitSsoConnector', 'createOrganizationJitSsoConnectorRequest', createOrganizationJitSsoConnectorRequest)
            const localVarPath = `/api/organizations/{id}/jit/sso-connectors`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrganizationJitSsoConnectorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete organization by ID.
         * @summary Delete organization
         * @param {string} id The unique identifier of the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOrganization', 'id', id)
            const localVarPath = `/api/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an application from the organization.
         * @summary Remove organization application
         * @param {string} id The unique identifier of the organization.
         * @param {string} applicationId The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationApplication: async (id: string, applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOrganizationApplication', 'id', id)
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteOrganizationApplication', 'applicationId', applicationId)
            const localVarPath = `/api/organizations/{id}/applications/{applicationId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a role from the application in the organization.
         * @summary Remove organization application role
         * @param {string} id The unique identifier of the organization.
         * @param {string} applicationId The unique identifier of the application.
         * @param {string} organizationRoleId The unique identifier of the organization role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationApplicationRole: async (id: string, applicationId: string, organizationRoleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOrganizationApplicationRole', 'id', id)
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteOrganizationApplicationRole', 'applicationId', applicationId)
            // verify required parameter 'organizationRoleId' is not null or undefined
            assertParamExists('deleteOrganizationApplicationRole', 'organizationRoleId', organizationRoleId)
            const localVarPath = `/api/organizations/{id}/applications/{applicationId}/roles/{organizationRoleId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"organizationRoleId"}}`, encodeURIComponent(String(organizationRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an email domain for just-in-time provisioning of users in the organization.
         * @summary Remove organization JIT email domain
         * @param {string} id The unique identifier of the organization.
         * @param {string} emailDomain The email domain to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationJitEmailDomain: async (id: string, emailDomain: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOrganizationJitEmailDomain', 'id', id)
            // verify required parameter 'emailDomain' is not null or undefined
            assertParamExists('deleteOrganizationJitEmailDomain', 'emailDomain', emailDomain)
            const localVarPath = `/api/organizations/{id}/jit/email-domains/{emailDomain}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"emailDomain"}}`, encodeURIComponent(String(emailDomain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an organization role that will be assigned to users during just-in-time provisioning.
         * @summary Remove organization JIT default role
         * @param {string} id The unique identifier of the organization.
         * @param {string} organizationRoleId The unique identifier of the organization role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationJitRole: async (id: string, organizationRoleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOrganizationJitRole', 'id', id)
            // verify required parameter 'organizationRoleId' is not null or undefined
            assertParamExists('deleteOrganizationJitRole', 'organizationRoleId', organizationRoleId)
            const localVarPath = `/api/organizations/{id}/jit/roles/{organizationRoleId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"organizationRoleId"}}`, encodeURIComponent(String(organizationRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an enterprise SSO connector for just-in-time provisioning of users in the organization.
         * @summary Remove organization JIT SSO connector
         * @param {string} id The unique identifier of the organization.
         * @param {string} ssoConnectorId The unique identifier of the sso connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationJitSsoConnector: async (id: string, ssoConnectorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOrganizationJitSsoConnector', 'id', id)
            // verify required parameter 'ssoConnectorId' is not null or undefined
            assertParamExists('deleteOrganizationJitSsoConnector', 'ssoConnectorId', ssoConnectorId)
            const localVarPath = `/api/organizations/{id}/jit/sso-connectors/{ssoConnectorId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"ssoConnectorId"}}`, encodeURIComponent(String(ssoConnectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a user\'s membership from the specified organization.
         * @summary Remove user member from organization
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationUser: async (id: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOrganizationUser', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteOrganizationUser', 'userId', userId)
            const localVarPath = `/api/organizations/{id}/users/{userId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a role assignment from a user in the specified organization.
         * @summary Remove a role from a user in an organization
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {string} organizationRoleId The unique identifier of the organization role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationUserRole: async (id: string, userId: string, organizationRoleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOrganizationUserRole', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteOrganizationUserRole', 'userId', userId)
            // verify required parameter 'organizationRoleId' is not null or undefined
            assertParamExists('deleteOrganizationUserRole', 'organizationRoleId', organizationRoleId)
            const localVarPath = `/api/organizations/{id}/users/{userId}/roles/{organizationRoleId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"organizationRoleId"}}`, encodeURIComponent(String(organizationRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get organization details by ID.
         * @summary Get organization
         * @param {string} id The unique identifier of the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrganization', 'id', id)
            const localVarPath = `/api/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get roles associated with the application in the organization.
         * @summary Get organization application roles
         * @param {string} id The unique identifier of the organization.
         * @param {string} applicationId The unique identifier of the application.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationApplicationRoles: async (id: string, applicationId: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listOrganizationApplicationRoles', 'id', id)
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('listOrganizationApplicationRoles', 'applicationId', applicationId)
            const localVarPath = `/api/organizations/{id}/applications/{applicationId}/roles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get applications associated with the organization.
         * @summary Get organization applications
         * @param {string} id The unique identifier of the organization.
         * @param {string} [q] 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationApplications: async (id: string, q?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listOrganizationApplications', 'id', id)
            const localVarPath = `/api/organizations/{id}/applications`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get email domains for just-in-time provisioning of users in the organization.
         * @summary Get organization JIT email domains
         * @param {string} id The unique identifier of the organization.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationJitEmailDomains: async (id: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listOrganizationJitEmailDomains', 'id', id)
            const localVarPath = `/api/organizations/{id}/jit/email-domains`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get organization roles that will be assigned to users during just-in-time provisioning.
         * @summary Get organization JIT default roles
         * @param {string} id The unique identifier of the organization.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationJitRoles: async (id: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listOrganizationJitRoles', 'id', id)
            const localVarPath = `/api/organizations/{id}/jit/roles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get enterprise SSO connectors for just-in-time provisioning of users in the organization.
         * @summary Get organization JIT SSO connectors
         * @param {string} id The unique identifier of the organization.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationJitSsoConnectors: async (id: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listOrganizationJitSsoConnectors', 'id', id)
            const localVarPath = `/api/organizations/{id}/jit/sso-connectors`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get roles assigned to a user in the specified organization with pagination.
         * @summary Get roles for a user in an organization
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationUserRoles: async (id: string, userId: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listOrganizationUserRoles', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listOrganizationUserRoles', 'userId', userId)
            const localVarPath = `/api/organizations/{id}/users/{userId}/roles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get scopes assigned to a user in the specified organization tailored by the organization roles. The scopes are derived from the organization roles assigned to the user.
         * @summary Get scopes for a user in an organization tailored by the organization roles
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationUserScopes: async (id: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listOrganizationUserScopes', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listOrganizationUserScopes', 'userId', userId)
            const localVarPath = `/api/organizations/{id}/users/{userId}/scopes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get users that are members of the specified organization for the given query with pagination.
         * @summary Get organization user members
         * @param {string} id The unique identifier of the organization.
         * @param {string} [q] The query to filter users. It will match multiple fields of users, including ID, name, username, email, and phone number.  If not provided, all users will be returned.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationUsers: async (id: string, q?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listOrganizationUsers', 'id', id)
            const localVarPath = `/api/organizations/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get organizations that match the given query with pagination.
         * @summary Get organizations
         * @param {string} [q] The query to filter organizations. It can be a partial ID or name.  If not provided, all organizations will be returned.
         * @param {string} [showFeatured] Whether to show featured users in the organization. Featured users are randomly selected from the organization members.  If not provided, &#x60;featuredUsers&#x60; will not be included in the response.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizations: async (q?: string, showFeatured?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (showFeatured !== undefined) {
                localVarQueryParameter['showFeatured'] = showFeatured;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace all roles associated with the application in the organization with the given data.
         * @summary Replace organization application roles
         * @param {string} id The unique identifier of the organization.
         * @param {string} applicationId The unique identifier of the application.
         * @param {ReplaceOrganizationApplicationRolesRequest} replaceOrganizationApplicationRolesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceOrganizationApplicationRoles: async (id: string, applicationId: string, replaceOrganizationApplicationRolesRequest: ReplaceOrganizationApplicationRolesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('replaceOrganizationApplicationRoles', 'id', id)
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('replaceOrganizationApplicationRoles', 'applicationId', applicationId)
            // verify required parameter 'replaceOrganizationApplicationRolesRequest' is not null or undefined
            assertParamExists('replaceOrganizationApplicationRoles', 'replaceOrganizationApplicationRolesRequest', replaceOrganizationApplicationRolesRequest)
            const localVarPath = `/api/organizations/{id}/applications/{applicationId}/roles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(replaceOrganizationApplicationRolesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace all applications associated with the organization with the given data.
         * @summary Replace organization applications
         * @param {string} id The unique identifier of the organization.
         * @param {ReplaceOrganizationApplicationsRequest} replaceOrganizationApplicationsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceOrganizationApplications: async (id: string, replaceOrganizationApplicationsRequest: ReplaceOrganizationApplicationsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('replaceOrganizationApplications', 'id', id)
            // verify required parameter 'replaceOrganizationApplicationsRequest' is not null or undefined
            assertParamExists('replaceOrganizationApplications', 'replaceOrganizationApplicationsRequest', replaceOrganizationApplicationsRequest)
            const localVarPath = `/api/organizations/{id}/applications`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(replaceOrganizationApplicationsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace all just-in-time provisioning email domains for the organization with the given data.
         * @summary Replace organization JIT email domains
         * @param {string} id The unique identifier of the organization.
         * @param {ReplaceOrganizationJitEmailDomainsRequest} replaceOrganizationJitEmailDomainsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceOrganizationJitEmailDomains: async (id: string, replaceOrganizationJitEmailDomainsRequest: ReplaceOrganizationJitEmailDomainsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('replaceOrganizationJitEmailDomains', 'id', id)
            // verify required parameter 'replaceOrganizationJitEmailDomainsRequest' is not null or undefined
            assertParamExists('replaceOrganizationJitEmailDomains', 'replaceOrganizationJitEmailDomainsRequest', replaceOrganizationJitEmailDomainsRequest)
            const localVarPath = `/api/organizations/{id}/jit/email-domains`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(replaceOrganizationJitEmailDomainsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace all organization roles that will be assigned to users during just-in-time provisioning with the given data.
         * @summary Replace organization JIT default roles
         * @param {string} id The unique identifier of the organization.
         * @param {ReplaceOrganizationJitRolesRequest} replaceOrganizationJitRolesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceOrganizationJitRoles: async (id: string, replaceOrganizationJitRolesRequest: ReplaceOrganizationJitRolesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('replaceOrganizationJitRoles', 'id', id)
            // verify required parameter 'replaceOrganizationJitRolesRequest' is not null or undefined
            assertParamExists('replaceOrganizationJitRoles', 'replaceOrganizationJitRolesRequest', replaceOrganizationJitRolesRequest)
            const localVarPath = `/api/organizations/{id}/jit/roles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(replaceOrganizationJitRolesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace all enterprise SSO connectors for just-in-time provisioning of users in the organization with the given data.
         * @summary Replace organization JIT SSO connectors
         * @param {string} id The unique identifier of the organization.
         * @param {ReplaceOrganizationJitSsoConnectorsRequest} replaceOrganizationJitSsoConnectorsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceOrganizationJitSsoConnectors: async (id: string, replaceOrganizationJitSsoConnectorsRequest: ReplaceOrganizationJitSsoConnectorsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('replaceOrganizationJitSsoConnectors', 'id', id)
            // verify required parameter 'replaceOrganizationJitSsoConnectorsRequest' is not null or undefined
            assertParamExists('replaceOrganizationJitSsoConnectors', 'replaceOrganizationJitSsoConnectorsRequest', replaceOrganizationJitSsoConnectorsRequest)
            const localVarPath = `/api/organizations/{id}/jit/sso-connectors`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(replaceOrganizationJitSsoConnectorsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update roles assigned to a user in the specified organization with the provided data.
         * @summary Update roles for a user in an organization
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {ReplaceOrganizationUserRolesRequest} replaceOrganizationUserRolesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceOrganizationUserRoles: async (id: string, userId: string, replaceOrganizationUserRolesRequest: ReplaceOrganizationUserRolesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('replaceOrganizationUserRoles', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('replaceOrganizationUserRoles', 'userId', userId)
            // verify required parameter 'replaceOrganizationUserRolesRequest' is not null or undefined
            assertParamExists('replaceOrganizationUserRoles', 'replaceOrganizationUserRolesRequest', replaceOrganizationUserRolesRequest)
            const localVarPath = `/api/organizations/{id}/users/{userId}/roles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(replaceOrganizationUserRolesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace all user members for the specified organization with the given users. This effectively removing all existing user memberships in the organization and adding the new users as members.
         * @summary Replace organization user members
         * @param {string} id The unique identifier of the organization.
         * @param {ReplaceOrganizationUsersRequest} replaceOrganizationUsersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceOrganizationUsers: async (id: string, replaceOrganizationUsersRequest: ReplaceOrganizationUsersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('replaceOrganizationUsers', 'id', id)
            // verify required parameter 'replaceOrganizationUsersRequest' is not null or undefined
            assertParamExists('replaceOrganizationUsers', 'replaceOrganizationUsersRequest', replaceOrganizationUsersRequest)
            const localVarPath = `/api/organizations/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(replaceOrganizationUsersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update organization details by ID with the given data.
         * @summary Update organization
         * @param {string} id The unique identifier of the organization.
         * @param {UpdateOrganizationRequest} updateOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization: async (id: string, updateOrganizationRequest: UpdateOrganizationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateOrganization', 'id', id)
            // verify required parameter 'updateOrganizationRequest' is not null or undefined
            assertParamExists('updateOrganization', 'updateOrganizationRequest', updateOrganizationRequest)
            const localVarPath = `/api/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrganizationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationsApi - functional programming interface
 * @export
 */
export const OrganizationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add an application to the organization.
         * @summary Add organization application
         * @param {string} id The unique identifier of the organization.
         * @param {AddOrganizationApplicationsRequest} addOrganizationApplicationsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrganizationApplications(id: string, addOrganizationApplicationsRequest: AddOrganizationApplicationsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrganizationApplications(id, addOrganizationApplicationsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.addOrganizationApplications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add users as members to the specified organization with the given user IDs.
         * @summary Add user members to organization
         * @param {string} id The unique identifier of the organization.
         * @param {AddOrganizationUsersRequest} addOrganizationUsersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrganizationUsers(id: string, addOrganizationUsersRequest: AddOrganizationUsersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrganizationUsers(id, addOrganizationUsersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.addOrganizationUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a role to the application in the organization.
         * @summary Add organization application role
         * @param {string} id The unique identifier of the organization.
         * @param {string} applicationId The unique identifier of the application.
         * @param {AssignOrganizationRolesToApplicationRequest} assignOrganizationRolesToApplicationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignOrganizationRolesToApplication(id: string, applicationId: string, assignOrganizationRolesToApplicationRequest: AssignOrganizationRolesToApplicationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignOrganizationRolesToApplication(id, applicationId, assignOrganizationRolesToApplicationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.assignOrganizationRolesToApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Assign roles to applications in the specified organization.
         * @summary Assign roles to applications in an organization
         * @param {string} id The unique identifier of the organization.
         * @param {AssignOrganizationRolesToApplicationsRequest} assignOrganizationRolesToApplicationsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignOrganizationRolesToApplications(id: string, assignOrganizationRolesToApplicationsRequest: AssignOrganizationRolesToApplicationsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignOrganizationRolesToApplications(id, assignOrganizationRolesToApplicationsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.assignOrganizationRolesToApplications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Assign roles to a user in the specified organization with the provided data.
         * @summary Assign roles to a user in an organization
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {AssignOrganizationRolesToUserRequest} assignOrganizationRolesToUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignOrganizationRolesToUser(id: string, userId: string, assignOrganizationRolesToUserRequest: AssignOrganizationRolesToUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignOrganizationRolesToUser(id, userId, assignOrganizationRolesToUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.assignOrganizationRolesToUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Assign roles to user members of the specified organization.
         * @summary Assign roles to organization user members
         * @param {string} id The unique identifier of the organization.
         * @param {AssignOrganizationRolesToUsersRequest} assignOrganizationRolesToUsersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignOrganizationRolesToUsers(id: string, assignOrganizationRolesToUsersRequest: AssignOrganizationRolesToUsersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignOrganizationRolesToUsers(id, assignOrganizationRolesToUsersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.assignOrganizationRolesToUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new organization with the given data.
         * @summary Create an organization
         * @param {CreateOrganizationRequest} createOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganization(createOrganizationRequest: CreateOrganizationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganization(createOrganizationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.createOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a new email domain for just-in-time provisioning of users in the organization.
         * @summary Add organization JIT email domain
         * @param {string} id The unique identifier of the organization.
         * @param {CreateOrganizationJitEmailDomainRequest} createOrganizationJitEmailDomainRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationJitEmailDomain(id: string, createOrganizationJitEmailDomainRequest: CreateOrganizationJitEmailDomainRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationJitEmailDomain(id, createOrganizationJitEmailDomainRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.createOrganizationJitEmailDomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add new organization roles that will be assigned to users during just-in-time provisioning.
         * @summary Add organization JIT default roles
         * @param {string} id The unique identifier of the organization.
         * @param {CreateOrganizationJitRoleRequest} createOrganizationJitRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationJitRole(id: string, createOrganizationJitRoleRequest: CreateOrganizationJitRoleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationJitRole(id, createOrganizationJitRoleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.createOrganizationJitRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add new enterprise SSO connectors for just-in-time provisioning of users in the organization.
         * @summary Add organization JIT SSO connectors
         * @param {string} id The unique identifier of the organization.
         * @param {CreateOrganizationJitSsoConnectorRequest} createOrganizationJitSsoConnectorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationJitSsoConnector(id: string, createOrganizationJitSsoConnectorRequest: CreateOrganizationJitSsoConnectorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationJitSsoConnector(id, createOrganizationJitSsoConnectorRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.createOrganizationJitSsoConnector']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete organization by ID.
         * @summary Delete organization
         * @param {string} id The unique identifier of the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganization(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganization(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.deleteOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove an application from the organization.
         * @summary Remove organization application
         * @param {string} id The unique identifier of the organization.
         * @param {string} applicationId The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationApplication(id: string, applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationApplication(id, applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.deleteOrganizationApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a role from the application in the organization.
         * @summary Remove organization application role
         * @param {string} id The unique identifier of the organization.
         * @param {string} applicationId The unique identifier of the application.
         * @param {string} organizationRoleId The unique identifier of the organization role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationApplicationRole(id: string, applicationId: string, organizationRoleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationApplicationRole(id, applicationId, organizationRoleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.deleteOrganizationApplicationRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove an email domain for just-in-time provisioning of users in the organization.
         * @summary Remove organization JIT email domain
         * @param {string} id The unique identifier of the organization.
         * @param {string} emailDomain The email domain to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationJitEmailDomain(id: string, emailDomain: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationJitEmailDomain(id, emailDomain, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.deleteOrganizationJitEmailDomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove an organization role that will be assigned to users during just-in-time provisioning.
         * @summary Remove organization JIT default role
         * @param {string} id The unique identifier of the organization.
         * @param {string} organizationRoleId The unique identifier of the organization role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationJitRole(id: string, organizationRoleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationJitRole(id, organizationRoleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.deleteOrganizationJitRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove an enterprise SSO connector for just-in-time provisioning of users in the organization.
         * @summary Remove organization JIT SSO connector
         * @param {string} id The unique identifier of the organization.
         * @param {string} ssoConnectorId The unique identifier of the sso connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationJitSsoConnector(id: string, ssoConnectorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationJitSsoConnector(id, ssoConnectorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.deleteOrganizationJitSsoConnector']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a user\'s membership from the specified organization.
         * @summary Remove user member from organization
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationUser(id: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationUser(id, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.deleteOrganizationUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a role assignment from a user in the specified organization.
         * @summary Remove a role from a user in an organization
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {string} organizationRoleId The unique identifier of the organization role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationUserRole(id: string, userId: string, organizationRoleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationUserRole(id, userId, organizationRoleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.deleteOrganizationUserRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get organization details by ID.
         * @summary Get organization
         * @param {string} id The unique identifier of the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganization(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListApplicationUserConsentOrganizations200ResponseOrganizationsInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganization(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.getOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get roles associated with the application in the organization.
         * @summary Get organization application roles
         * @param {string} id The unique identifier of the organization.
         * @param {string} applicationId The unique identifier of the application.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationApplicationRoles(id: string, applicationId: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOrganizationRole200Response>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationApplicationRoles(id, applicationId, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.listOrganizationApplicationRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get applications associated with the organization.
         * @summary Get organization applications
         * @param {string} id The unique identifier of the organization.
         * @param {string} [q] 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationApplications(id: string, q?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListOrganizationApplications200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationApplications(id, q, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.listOrganizationApplications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get email domains for just-in-time provisioning of users in the organization.
         * @summary Get organization JIT email domains
         * @param {string} id The unique identifier of the organization.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationJitEmailDomains(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListOrganizationJitEmailDomains200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationJitEmailDomains(id, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.listOrganizationJitEmailDomains']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get organization roles that will be assigned to users during just-in-time provisioning.
         * @summary Get organization JIT default roles
         * @param {string} id The unique identifier of the organization.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationJitRoles(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOrganizationRole200Response>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationJitRoles(id, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.listOrganizationJitRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get enterprise SSO connectors for just-in-time provisioning of users in the organization.
         * @summary Get organization JIT SSO connectors
         * @param {string} id The unique identifier of the organization.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationJitSsoConnectors(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListOrganizationJitSsoConnectors200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationJitSsoConnectors(id, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.listOrganizationJitSsoConnectors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get roles assigned to a user in the specified organization with pagination.
         * @summary Get roles for a user in an organization
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationUserRoles(id: string, userId: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOrganizationRole200Response>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationUserRoles(id, userId, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.listOrganizationUserRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get scopes assigned to a user in the specified organization tailored by the organization roles. The scopes are derived from the organization roles assigned to the user.
         * @summary Get scopes for a user in an organization tailored by the organization roles
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationUserScopes(id: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListOrganizationRoleScopes200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationUserScopes(id, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.listOrganizationUserScopes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get users that are members of the specified organization for the given query with pagination.
         * @summary Get organization user members
         * @param {string} id The unique identifier of the organization.
         * @param {string} [q] The query to filter users. It will match multiple fields of users, including ID, name, username, email, and phone number.  If not provided, all users will be returned.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationUsers(id: string, q?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListOrganizationUsers200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationUsers(id, q, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.listOrganizationUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get organizations that match the given query with pagination.
         * @summary Get organizations
         * @param {string} [q] The query to filter organizations. It can be a partial ID or name.  If not provided, all organizations will be returned.
         * @param {string} [showFeatured] Whether to show featured users in the organization. Featured users are randomly selected from the organization members.  If not provided, &#x60;featuredUsers&#x60; will not be included in the response.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizations(q?: string, showFeatured?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListOrganizations200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizations(q, showFeatured, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.listOrganizations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replace all roles associated with the application in the organization with the given data.
         * @summary Replace organization application roles
         * @param {string} id The unique identifier of the organization.
         * @param {string} applicationId The unique identifier of the application.
         * @param {ReplaceOrganizationApplicationRolesRequest} replaceOrganizationApplicationRolesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaceOrganizationApplicationRoles(id: string, applicationId: string, replaceOrganizationApplicationRolesRequest: ReplaceOrganizationApplicationRolesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceOrganizationApplicationRoles(id, applicationId, replaceOrganizationApplicationRolesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.replaceOrganizationApplicationRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replace all applications associated with the organization with the given data.
         * @summary Replace organization applications
         * @param {string} id The unique identifier of the organization.
         * @param {ReplaceOrganizationApplicationsRequest} replaceOrganizationApplicationsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaceOrganizationApplications(id: string, replaceOrganizationApplicationsRequest: ReplaceOrganizationApplicationsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceOrganizationApplications(id, replaceOrganizationApplicationsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.replaceOrganizationApplications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replace all just-in-time provisioning email domains for the organization with the given data.
         * @summary Replace organization JIT email domains
         * @param {string} id The unique identifier of the organization.
         * @param {ReplaceOrganizationJitEmailDomainsRequest} replaceOrganizationJitEmailDomainsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaceOrganizationJitEmailDomains(id: string, replaceOrganizationJitEmailDomainsRequest: ReplaceOrganizationJitEmailDomainsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceOrganizationJitEmailDomains(id, replaceOrganizationJitEmailDomainsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.replaceOrganizationJitEmailDomains']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replace all organization roles that will be assigned to users during just-in-time provisioning with the given data.
         * @summary Replace organization JIT default roles
         * @param {string} id The unique identifier of the organization.
         * @param {ReplaceOrganizationJitRolesRequest} replaceOrganizationJitRolesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaceOrganizationJitRoles(id: string, replaceOrganizationJitRolesRequest: ReplaceOrganizationJitRolesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceOrganizationJitRoles(id, replaceOrganizationJitRolesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.replaceOrganizationJitRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replace all enterprise SSO connectors for just-in-time provisioning of users in the organization with the given data.
         * @summary Replace organization JIT SSO connectors
         * @param {string} id The unique identifier of the organization.
         * @param {ReplaceOrganizationJitSsoConnectorsRequest} replaceOrganizationJitSsoConnectorsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaceOrganizationJitSsoConnectors(id: string, replaceOrganizationJitSsoConnectorsRequest: ReplaceOrganizationJitSsoConnectorsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceOrganizationJitSsoConnectors(id, replaceOrganizationJitSsoConnectorsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.replaceOrganizationJitSsoConnectors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update roles assigned to a user in the specified organization with the provided data.
         * @summary Update roles for a user in an organization
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {ReplaceOrganizationUserRolesRequest} replaceOrganizationUserRolesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaceOrganizationUserRoles(id: string, userId: string, replaceOrganizationUserRolesRequest: ReplaceOrganizationUserRolesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceOrganizationUserRoles(id, userId, replaceOrganizationUserRolesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.replaceOrganizationUserRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replace all user members for the specified organization with the given users. This effectively removing all existing user memberships in the organization and adding the new users as members.
         * @summary Replace organization user members
         * @param {string} id The unique identifier of the organization.
         * @param {ReplaceOrganizationUsersRequest} replaceOrganizationUsersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaceOrganizationUsers(id: string, replaceOrganizationUsersRequest: ReplaceOrganizationUsersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceOrganizationUsers(id, replaceOrganizationUsersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.replaceOrganizationUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update organization details by ID with the given data.
         * @summary Update organization
         * @param {string} id The unique identifier of the organization.
         * @param {UpdateOrganizationRequest} updateOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganization(id: string, updateOrganizationRequest: UpdateOrganizationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListApplicationUserConsentOrganizations200ResponseOrganizationsInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganization(id, updateOrganizationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.updateOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationsApi - factory interface
 * @export
 */
export const OrganizationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationsApiFp(configuration)
    return {
        /**
         * Add an application to the organization.
         * @summary Add organization application
         * @param {string} id The unique identifier of the organization.
         * @param {AddOrganizationApplicationsRequest} addOrganizationApplicationsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganizationApplications(id: string, addOrganizationApplicationsRequest: AddOrganizationApplicationsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.addOrganizationApplications(id, addOrganizationApplicationsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add users as members to the specified organization with the given user IDs.
         * @summary Add user members to organization
         * @param {string} id The unique identifier of the organization.
         * @param {AddOrganizationUsersRequest} addOrganizationUsersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganizationUsers(id: string, addOrganizationUsersRequest: AddOrganizationUsersRequest, options?: any): AxiosPromise<void> {
            return localVarFp.addOrganizationUsers(id, addOrganizationUsersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a role to the application in the organization.
         * @summary Add organization application role
         * @param {string} id The unique identifier of the organization.
         * @param {string} applicationId The unique identifier of the application.
         * @param {AssignOrganizationRolesToApplicationRequest} assignOrganizationRolesToApplicationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignOrganizationRolesToApplication(id: string, applicationId: string, assignOrganizationRolesToApplicationRequest: AssignOrganizationRolesToApplicationRequest, options?: any): AxiosPromise<void> {
            return localVarFp.assignOrganizationRolesToApplication(id, applicationId, assignOrganizationRolesToApplicationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign roles to applications in the specified organization.
         * @summary Assign roles to applications in an organization
         * @param {string} id The unique identifier of the organization.
         * @param {AssignOrganizationRolesToApplicationsRequest} assignOrganizationRolesToApplicationsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignOrganizationRolesToApplications(id: string, assignOrganizationRolesToApplicationsRequest: AssignOrganizationRolesToApplicationsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.assignOrganizationRolesToApplications(id, assignOrganizationRolesToApplicationsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign roles to a user in the specified organization with the provided data.
         * @summary Assign roles to a user in an organization
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {AssignOrganizationRolesToUserRequest} assignOrganizationRolesToUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignOrganizationRolesToUser(id: string, userId: string, assignOrganizationRolesToUserRequest: AssignOrganizationRolesToUserRequest, options?: any): AxiosPromise<void> {
            return localVarFp.assignOrganizationRolesToUser(id, userId, assignOrganizationRolesToUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign roles to user members of the specified organization.
         * @summary Assign roles to organization user members
         * @param {string} id The unique identifier of the organization.
         * @param {AssignOrganizationRolesToUsersRequest} assignOrganizationRolesToUsersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignOrganizationRolesToUsers(id: string, assignOrganizationRolesToUsersRequest: AssignOrganizationRolesToUsersRequest, options?: any): AxiosPromise<void> {
            return localVarFp.assignOrganizationRolesToUsers(id, assignOrganizationRolesToUsersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new organization with the given data.
         * @summary Create an organization
         * @param {CreateOrganizationRequest} createOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(createOrganizationRequest: CreateOrganizationRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createOrganization(createOrganizationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new email domain for just-in-time provisioning of users in the organization.
         * @summary Add organization JIT email domain
         * @param {string} id The unique identifier of the organization.
         * @param {CreateOrganizationJitEmailDomainRequest} createOrganizationJitEmailDomainRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationJitEmailDomain(id: string, createOrganizationJitEmailDomainRequest: CreateOrganizationJitEmailDomainRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createOrganizationJitEmailDomain(id, createOrganizationJitEmailDomainRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add new organization roles that will be assigned to users during just-in-time provisioning.
         * @summary Add organization JIT default roles
         * @param {string} id The unique identifier of the organization.
         * @param {CreateOrganizationJitRoleRequest} createOrganizationJitRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationJitRole(id: string, createOrganizationJitRoleRequest: CreateOrganizationJitRoleRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createOrganizationJitRole(id, createOrganizationJitRoleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add new enterprise SSO connectors for just-in-time provisioning of users in the organization.
         * @summary Add organization JIT SSO connectors
         * @param {string} id The unique identifier of the organization.
         * @param {CreateOrganizationJitSsoConnectorRequest} createOrganizationJitSsoConnectorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationJitSsoConnector(id: string, createOrganizationJitSsoConnectorRequest: CreateOrganizationJitSsoConnectorRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createOrganizationJitSsoConnector(id, createOrganizationJitSsoConnectorRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete organization by ID.
         * @summary Delete organization
         * @param {string} id The unique identifier of the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganization(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove an application from the organization.
         * @summary Remove organization application
         * @param {string} id The unique identifier of the organization.
         * @param {string} applicationId The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationApplication(id: string, applicationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganizationApplication(id, applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a role from the application in the organization.
         * @summary Remove organization application role
         * @param {string} id The unique identifier of the organization.
         * @param {string} applicationId The unique identifier of the application.
         * @param {string} organizationRoleId The unique identifier of the organization role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationApplicationRole(id: string, applicationId: string, organizationRoleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganizationApplicationRole(id, applicationId, organizationRoleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove an email domain for just-in-time provisioning of users in the organization.
         * @summary Remove organization JIT email domain
         * @param {string} id The unique identifier of the organization.
         * @param {string} emailDomain The email domain to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationJitEmailDomain(id: string, emailDomain: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganizationJitEmailDomain(id, emailDomain, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove an organization role that will be assigned to users during just-in-time provisioning.
         * @summary Remove organization JIT default role
         * @param {string} id The unique identifier of the organization.
         * @param {string} organizationRoleId The unique identifier of the organization role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationJitRole(id: string, organizationRoleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganizationJitRole(id, organizationRoleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove an enterprise SSO connector for just-in-time provisioning of users in the organization.
         * @summary Remove organization JIT SSO connector
         * @param {string} id The unique identifier of the organization.
         * @param {string} ssoConnectorId The unique identifier of the sso connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationJitSsoConnector(id: string, ssoConnectorId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganizationJitSsoConnector(id, ssoConnectorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a user\'s membership from the specified organization.
         * @summary Remove user member from organization
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationUser(id: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganizationUser(id, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a role assignment from a user in the specified organization.
         * @summary Remove a role from a user in an organization
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {string} organizationRoleId The unique identifier of the organization role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationUserRole(id: string, userId: string, organizationRoleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganizationUserRole(id, userId, organizationRoleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organization details by ID.
         * @summary Get organization
         * @param {string} id The unique identifier of the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(id: string, options?: any): AxiosPromise<ListApplicationUserConsentOrganizations200ResponseOrganizationsInner> {
            return localVarFp.getOrganization(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get roles associated with the application in the organization.
         * @summary Get organization application roles
         * @param {string} id The unique identifier of the organization.
         * @param {string} applicationId The unique identifier of the application.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationApplicationRoles(id: string, applicationId: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<GetOrganizationRole200Response>> {
            return localVarFp.listOrganizationApplicationRoles(id, applicationId, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get applications associated with the organization.
         * @summary Get organization applications
         * @param {string} id The unique identifier of the organization.
         * @param {string} [q] 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationApplications(id: string, q?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ListOrganizationApplications200ResponseInner>> {
            return localVarFp.listOrganizationApplications(id, q, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get email domains for just-in-time provisioning of users in the organization.
         * @summary Get organization JIT email domains
         * @param {string} id The unique identifier of the organization.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationJitEmailDomains(id: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ListOrganizationJitEmailDomains200ResponseInner>> {
            return localVarFp.listOrganizationJitEmailDomains(id, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organization roles that will be assigned to users during just-in-time provisioning.
         * @summary Get organization JIT default roles
         * @param {string} id The unique identifier of the organization.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationJitRoles(id: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<GetOrganizationRole200Response>> {
            return localVarFp.listOrganizationJitRoles(id, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get enterprise SSO connectors for just-in-time provisioning of users in the organization.
         * @summary Get organization JIT SSO connectors
         * @param {string} id The unique identifier of the organization.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationJitSsoConnectors(id: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ListOrganizationJitSsoConnectors200ResponseInner>> {
            return localVarFp.listOrganizationJitSsoConnectors(id, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get roles assigned to a user in the specified organization with pagination.
         * @summary Get roles for a user in an organization
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationUserRoles(id: string, userId: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<GetOrganizationRole200Response>> {
            return localVarFp.listOrganizationUserRoles(id, userId, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get scopes assigned to a user in the specified organization tailored by the organization roles. The scopes are derived from the organization roles assigned to the user.
         * @summary Get scopes for a user in an organization tailored by the organization roles
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationUserScopes(id: string, userId: string, options?: any): AxiosPromise<Array<ListOrganizationRoleScopes200ResponseInner>> {
            return localVarFp.listOrganizationUserScopes(id, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get users that are members of the specified organization for the given query with pagination.
         * @summary Get organization user members
         * @param {string} id The unique identifier of the organization.
         * @param {string} [q] The query to filter users. It will match multiple fields of users, including ID, name, username, email, and phone number.  If not provided, all users will be returned.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationUsers(id: string, q?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ListOrganizationUsers200ResponseInner>> {
            return localVarFp.listOrganizationUsers(id, q, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organizations that match the given query with pagination.
         * @summary Get organizations
         * @param {string} [q] The query to filter organizations. It can be a partial ID or name.  If not provided, all organizations will be returned.
         * @param {string} [showFeatured] Whether to show featured users in the organization. Featured users are randomly selected from the organization members.  If not provided, &#x60;featuredUsers&#x60; will not be included in the response.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizations(q?: string, showFeatured?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ListOrganizations200ResponseInner>> {
            return localVarFp.listOrganizations(q, showFeatured, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace all roles associated with the application in the organization with the given data.
         * @summary Replace organization application roles
         * @param {string} id The unique identifier of the organization.
         * @param {string} applicationId The unique identifier of the application.
         * @param {ReplaceOrganizationApplicationRolesRequest} replaceOrganizationApplicationRolesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceOrganizationApplicationRoles(id: string, applicationId: string, replaceOrganizationApplicationRolesRequest: ReplaceOrganizationApplicationRolesRequest, options?: any): AxiosPromise<void> {
            return localVarFp.replaceOrganizationApplicationRoles(id, applicationId, replaceOrganizationApplicationRolesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace all applications associated with the organization with the given data.
         * @summary Replace organization applications
         * @param {string} id The unique identifier of the organization.
         * @param {ReplaceOrganizationApplicationsRequest} replaceOrganizationApplicationsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceOrganizationApplications(id: string, replaceOrganizationApplicationsRequest: ReplaceOrganizationApplicationsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.replaceOrganizationApplications(id, replaceOrganizationApplicationsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace all just-in-time provisioning email domains for the organization with the given data.
         * @summary Replace organization JIT email domains
         * @param {string} id The unique identifier of the organization.
         * @param {ReplaceOrganizationJitEmailDomainsRequest} replaceOrganizationJitEmailDomainsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceOrganizationJitEmailDomains(id: string, replaceOrganizationJitEmailDomainsRequest: ReplaceOrganizationJitEmailDomainsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.replaceOrganizationJitEmailDomains(id, replaceOrganizationJitEmailDomainsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace all organization roles that will be assigned to users during just-in-time provisioning with the given data.
         * @summary Replace organization JIT default roles
         * @param {string} id The unique identifier of the organization.
         * @param {ReplaceOrganizationJitRolesRequest} replaceOrganizationJitRolesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceOrganizationJitRoles(id: string, replaceOrganizationJitRolesRequest: ReplaceOrganizationJitRolesRequest, options?: any): AxiosPromise<void> {
            return localVarFp.replaceOrganizationJitRoles(id, replaceOrganizationJitRolesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace all enterprise SSO connectors for just-in-time provisioning of users in the organization with the given data.
         * @summary Replace organization JIT SSO connectors
         * @param {string} id The unique identifier of the organization.
         * @param {ReplaceOrganizationJitSsoConnectorsRequest} replaceOrganizationJitSsoConnectorsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceOrganizationJitSsoConnectors(id: string, replaceOrganizationJitSsoConnectorsRequest: ReplaceOrganizationJitSsoConnectorsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.replaceOrganizationJitSsoConnectors(id, replaceOrganizationJitSsoConnectorsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update roles assigned to a user in the specified organization with the provided data.
         * @summary Update roles for a user in an organization
         * @param {string} id The unique identifier of the organization.
         * @param {string} userId The unique identifier of the user.
         * @param {ReplaceOrganizationUserRolesRequest} replaceOrganizationUserRolesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceOrganizationUserRoles(id: string, userId: string, replaceOrganizationUserRolesRequest: ReplaceOrganizationUserRolesRequest, options?: any): AxiosPromise<void> {
            return localVarFp.replaceOrganizationUserRoles(id, userId, replaceOrganizationUserRolesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace all user members for the specified organization with the given users. This effectively removing all existing user memberships in the organization and adding the new users as members.
         * @summary Replace organization user members
         * @param {string} id The unique identifier of the organization.
         * @param {ReplaceOrganizationUsersRequest} replaceOrganizationUsersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceOrganizationUsers(id: string, replaceOrganizationUsersRequest: ReplaceOrganizationUsersRequest, options?: any): AxiosPromise<void> {
            return localVarFp.replaceOrganizationUsers(id, replaceOrganizationUsersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update organization details by ID with the given data.
         * @summary Update organization
         * @param {string} id The unique identifier of the organization.
         * @param {UpdateOrganizationRequest} updateOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(id: string, updateOrganizationRequest: UpdateOrganizationRequest, options?: any): AxiosPromise<ListApplicationUserConsentOrganizations200ResponseOrganizationsInner> {
            return localVarFp.updateOrganization(id, updateOrganizationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
export class OrganizationsApi extends BaseAPI {
    /**
     * Add an application to the organization.
     * @summary Add organization application
     * @param {string} id The unique identifier of the organization.
     * @param {AddOrganizationApplicationsRequest} addOrganizationApplicationsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public addOrganizationApplications(id: string, addOrganizationApplicationsRequest: AddOrganizationApplicationsRequest, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).addOrganizationApplications(id, addOrganizationApplicationsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add users as members to the specified organization with the given user IDs.
     * @summary Add user members to organization
     * @param {string} id The unique identifier of the organization.
     * @param {AddOrganizationUsersRequest} addOrganizationUsersRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public addOrganizationUsers(id: string, addOrganizationUsersRequest: AddOrganizationUsersRequest, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).addOrganizationUsers(id, addOrganizationUsersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a role to the application in the organization.
     * @summary Add organization application role
     * @param {string} id The unique identifier of the organization.
     * @param {string} applicationId The unique identifier of the application.
     * @param {AssignOrganizationRolesToApplicationRequest} assignOrganizationRolesToApplicationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public assignOrganizationRolesToApplication(id: string, applicationId: string, assignOrganizationRolesToApplicationRequest: AssignOrganizationRolesToApplicationRequest, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).assignOrganizationRolesToApplication(id, applicationId, assignOrganizationRolesToApplicationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assign roles to applications in the specified organization.
     * @summary Assign roles to applications in an organization
     * @param {string} id The unique identifier of the organization.
     * @param {AssignOrganizationRolesToApplicationsRequest} assignOrganizationRolesToApplicationsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public assignOrganizationRolesToApplications(id: string, assignOrganizationRolesToApplicationsRequest: AssignOrganizationRolesToApplicationsRequest, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).assignOrganizationRolesToApplications(id, assignOrganizationRolesToApplicationsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assign roles to a user in the specified organization with the provided data.
     * @summary Assign roles to a user in an organization
     * @param {string} id The unique identifier of the organization.
     * @param {string} userId The unique identifier of the user.
     * @param {AssignOrganizationRolesToUserRequest} assignOrganizationRolesToUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public assignOrganizationRolesToUser(id: string, userId: string, assignOrganizationRolesToUserRequest: AssignOrganizationRolesToUserRequest, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).assignOrganizationRolesToUser(id, userId, assignOrganizationRolesToUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assign roles to user members of the specified organization.
     * @summary Assign roles to organization user members
     * @param {string} id The unique identifier of the organization.
     * @param {AssignOrganizationRolesToUsersRequest} assignOrganizationRolesToUsersRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public assignOrganizationRolesToUsers(id: string, assignOrganizationRolesToUsersRequest: AssignOrganizationRolesToUsersRequest, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).assignOrganizationRolesToUsers(id, assignOrganizationRolesToUsersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new organization with the given data.
     * @summary Create an organization
     * @param {CreateOrganizationRequest} createOrganizationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public createOrganization(createOrganizationRequest: CreateOrganizationRequest, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).createOrganization(createOrganizationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new email domain for just-in-time provisioning of users in the organization.
     * @summary Add organization JIT email domain
     * @param {string} id The unique identifier of the organization.
     * @param {CreateOrganizationJitEmailDomainRequest} createOrganizationJitEmailDomainRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public createOrganizationJitEmailDomain(id: string, createOrganizationJitEmailDomainRequest: CreateOrganizationJitEmailDomainRequest, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).createOrganizationJitEmailDomain(id, createOrganizationJitEmailDomainRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add new organization roles that will be assigned to users during just-in-time provisioning.
     * @summary Add organization JIT default roles
     * @param {string} id The unique identifier of the organization.
     * @param {CreateOrganizationJitRoleRequest} createOrganizationJitRoleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public createOrganizationJitRole(id: string, createOrganizationJitRoleRequest: CreateOrganizationJitRoleRequest, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).createOrganizationJitRole(id, createOrganizationJitRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add new enterprise SSO connectors for just-in-time provisioning of users in the organization.
     * @summary Add organization JIT SSO connectors
     * @param {string} id The unique identifier of the organization.
     * @param {CreateOrganizationJitSsoConnectorRequest} createOrganizationJitSsoConnectorRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public createOrganizationJitSsoConnector(id: string, createOrganizationJitSsoConnectorRequest: CreateOrganizationJitSsoConnectorRequest, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).createOrganizationJitSsoConnector(id, createOrganizationJitSsoConnectorRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete organization by ID.
     * @summary Delete organization
     * @param {string} id The unique identifier of the organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public deleteOrganization(id: string, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).deleteOrganization(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove an application from the organization.
     * @summary Remove organization application
     * @param {string} id The unique identifier of the organization.
     * @param {string} applicationId The unique identifier of the application.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public deleteOrganizationApplication(id: string, applicationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).deleteOrganizationApplication(id, applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a role from the application in the organization.
     * @summary Remove organization application role
     * @param {string} id The unique identifier of the organization.
     * @param {string} applicationId The unique identifier of the application.
     * @param {string} organizationRoleId The unique identifier of the organization role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public deleteOrganizationApplicationRole(id: string, applicationId: string, organizationRoleId: string, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).deleteOrganizationApplicationRole(id, applicationId, organizationRoleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove an email domain for just-in-time provisioning of users in the organization.
     * @summary Remove organization JIT email domain
     * @param {string} id The unique identifier of the organization.
     * @param {string} emailDomain The email domain to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public deleteOrganizationJitEmailDomain(id: string, emailDomain: string, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).deleteOrganizationJitEmailDomain(id, emailDomain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove an organization role that will be assigned to users during just-in-time provisioning.
     * @summary Remove organization JIT default role
     * @param {string} id The unique identifier of the organization.
     * @param {string} organizationRoleId The unique identifier of the organization role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public deleteOrganizationJitRole(id: string, organizationRoleId: string, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).deleteOrganizationJitRole(id, organizationRoleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove an enterprise SSO connector for just-in-time provisioning of users in the organization.
     * @summary Remove organization JIT SSO connector
     * @param {string} id The unique identifier of the organization.
     * @param {string} ssoConnectorId The unique identifier of the sso connector.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public deleteOrganizationJitSsoConnector(id: string, ssoConnectorId: string, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).deleteOrganizationJitSsoConnector(id, ssoConnectorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a user\'s membership from the specified organization.
     * @summary Remove user member from organization
     * @param {string} id The unique identifier of the organization.
     * @param {string} userId The unique identifier of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public deleteOrganizationUser(id: string, userId: string, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).deleteOrganizationUser(id, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a role assignment from a user in the specified organization.
     * @summary Remove a role from a user in an organization
     * @param {string} id The unique identifier of the organization.
     * @param {string} userId The unique identifier of the user.
     * @param {string} organizationRoleId The unique identifier of the organization role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public deleteOrganizationUserRole(id: string, userId: string, organizationRoleId: string, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).deleteOrganizationUserRole(id, userId, organizationRoleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get organization details by ID.
     * @summary Get organization
     * @param {string} id The unique identifier of the organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public getOrganization(id: string, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).getOrganization(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get roles associated with the application in the organization.
     * @summary Get organization application roles
     * @param {string} id The unique identifier of the organization.
     * @param {string} applicationId The unique identifier of the application.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public listOrganizationApplicationRoles(id: string, applicationId: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).listOrganizationApplicationRoles(id, applicationId, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get applications associated with the organization.
     * @summary Get organization applications
     * @param {string} id The unique identifier of the organization.
     * @param {string} [q] 
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public listOrganizationApplications(id: string, q?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).listOrganizationApplications(id, q, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get email domains for just-in-time provisioning of users in the organization.
     * @summary Get organization JIT email domains
     * @param {string} id The unique identifier of the organization.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public listOrganizationJitEmailDomains(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).listOrganizationJitEmailDomains(id, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get organization roles that will be assigned to users during just-in-time provisioning.
     * @summary Get organization JIT default roles
     * @param {string} id The unique identifier of the organization.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public listOrganizationJitRoles(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).listOrganizationJitRoles(id, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get enterprise SSO connectors for just-in-time provisioning of users in the organization.
     * @summary Get organization JIT SSO connectors
     * @param {string} id The unique identifier of the organization.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public listOrganizationJitSsoConnectors(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).listOrganizationJitSsoConnectors(id, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get roles assigned to a user in the specified organization with pagination.
     * @summary Get roles for a user in an organization
     * @param {string} id The unique identifier of the organization.
     * @param {string} userId The unique identifier of the user.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public listOrganizationUserRoles(id: string, userId: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).listOrganizationUserRoles(id, userId, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get scopes assigned to a user in the specified organization tailored by the organization roles. The scopes are derived from the organization roles assigned to the user.
     * @summary Get scopes for a user in an organization tailored by the organization roles
     * @param {string} id The unique identifier of the organization.
     * @param {string} userId The unique identifier of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public listOrganizationUserScopes(id: string, userId: string, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).listOrganizationUserScopes(id, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get users that are members of the specified organization for the given query with pagination.
     * @summary Get organization user members
     * @param {string} id The unique identifier of the organization.
     * @param {string} [q] The query to filter users. It will match multiple fields of users, including ID, name, username, email, and phone number.  If not provided, all users will be returned.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public listOrganizationUsers(id: string, q?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).listOrganizationUsers(id, q, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get organizations that match the given query with pagination.
     * @summary Get organizations
     * @param {string} [q] The query to filter organizations. It can be a partial ID or name.  If not provided, all organizations will be returned.
     * @param {string} [showFeatured] Whether to show featured users in the organization. Featured users are randomly selected from the organization members.  If not provided, &#x60;featuredUsers&#x60; will not be included in the response.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public listOrganizations(q?: string, showFeatured?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).listOrganizations(q, showFeatured, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace all roles associated with the application in the organization with the given data.
     * @summary Replace organization application roles
     * @param {string} id The unique identifier of the organization.
     * @param {string} applicationId The unique identifier of the application.
     * @param {ReplaceOrganizationApplicationRolesRequest} replaceOrganizationApplicationRolesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public replaceOrganizationApplicationRoles(id: string, applicationId: string, replaceOrganizationApplicationRolesRequest: ReplaceOrganizationApplicationRolesRequest, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).replaceOrganizationApplicationRoles(id, applicationId, replaceOrganizationApplicationRolesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace all applications associated with the organization with the given data.
     * @summary Replace organization applications
     * @param {string} id The unique identifier of the organization.
     * @param {ReplaceOrganizationApplicationsRequest} replaceOrganizationApplicationsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public replaceOrganizationApplications(id: string, replaceOrganizationApplicationsRequest: ReplaceOrganizationApplicationsRequest, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).replaceOrganizationApplications(id, replaceOrganizationApplicationsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace all just-in-time provisioning email domains for the organization with the given data.
     * @summary Replace organization JIT email domains
     * @param {string} id The unique identifier of the organization.
     * @param {ReplaceOrganizationJitEmailDomainsRequest} replaceOrganizationJitEmailDomainsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public replaceOrganizationJitEmailDomains(id: string, replaceOrganizationJitEmailDomainsRequest: ReplaceOrganizationJitEmailDomainsRequest, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).replaceOrganizationJitEmailDomains(id, replaceOrganizationJitEmailDomainsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace all organization roles that will be assigned to users during just-in-time provisioning with the given data.
     * @summary Replace organization JIT default roles
     * @param {string} id The unique identifier of the organization.
     * @param {ReplaceOrganizationJitRolesRequest} replaceOrganizationJitRolesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public replaceOrganizationJitRoles(id: string, replaceOrganizationJitRolesRequest: ReplaceOrganizationJitRolesRequest, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).replaceOrganizationJitRoles(id, replaceOrganizationJitRolesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace all enterprise SSO connectors for just-in-time provisioning of users in the organization with the given data.
     * @summary Replace organization JIT SSO connectors
     * @param {string} id The unique identifier of the organization.
     * @param {ReplaceOrganizationJitSsoConnectorsRequest} replaceOrganizationJitSsoConnectorsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public replaceOrganizationJitSsoConnectors(id: string, replaceOrganizationJitSsoConnectorsRequest: ReplaceOrganizationJitSsoConnectorsRequest, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).replaceOrganizationJitSsoConnectors(id, replaceOrganizationJitSsoConnectorsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update roles assigned to a user in the specified organization with the provided data.
     * @summary Update roles for a user in an organization
     * @param {string} id The unique identifier of the organization.
     * @param {string} userId The unique identifier of the user.
     * @param {ReplaceOrganizationUserRolesRequest} replaceOrganizationUserRolesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public replaceOrganizationUserRoles(id: string, userId: string, replaceOrganizationUserRolesRequest: ReplaceOrganizationUserRolesRequest, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).replaceOrganizationUserRoles(id, userId, replaceOrganizationUserRolesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace all user members for the specified organization with the given users. This effectively removing all existing user memberships in the organization and adding the new users as members.
     * @summary Replace organization user members
     * @param {string} id The unique identifier of the organization.
     * @param {ReplaceOrganizationUsersRequest} replaceOrganizationUsersRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public replaceOrganizationUsers(id: string, replaceOrganizationUsersRequest: ReplaceOrganizationUsersRequest, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).replaceOrganizationUsers(id, replaceOrganizationUsersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update organization details by ID with the given data.
     * @summary Update organization
     * @param {string} id The unique identifier of the organization.
     * @param {UpdateOrganizationRequest} updateOrganizationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public updateOrganization(id: string, updateOrganizationRequest: UpdateOrganizationRequest, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).updateOrganization(id, updateOrganizationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResourcesApi - axios parameter creator
 * @export
 */
export const ResourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an API resource in the current tenant.
         * @summary Create an API resource
         * @param {CreateResourceRequest} createResourceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResource: async (createResourceRequest: CreateResourceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createResourceRequest' is not null or undefined
            assertParamExists('createResource', 'createResourceRequest', createResourceRequest)
            const localVarPath = `/api/resources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createResourceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new scope (permission) for an API resource.
         * @summary Create API resource scope
         * @param {string} resourceId The unique identifier of the resource.
         * @param {CreateResourceScopeRequest} createResourceScopeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourceScope: async (resourceId: string, createResourceScopeRequest: CreateResourceScopeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('createResourceScope', 'resourceId', resourceId)
            // verify required parameter 'createResourceScopeRequest' is not null or undefined
            assertParamExists('createResourceScope', 'createResourceScopeRequest', createResourceScopeRequest)
            const localVarPath = `/api/resources/{resourceId}/scopes`
                .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createResourceScopeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an API resource by ID.
         * @summary Delete API resource
         * @param {string} id The unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResource: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteResource', 'id', id)
            const localVarPath = `/api/resources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an API resource scope (permission) from the given resource.
         * @summary Delete API resource scope
         * @param {string} resourceId The unique identifier of the resource.
         * @param {string} scopeId The unique identifier of the scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourceScope: async (resourceId: string, scopeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('deleteResourceScope', 'resourceId', resourceId)
            // verify required parameter 'scopeId' is not null or undefined
            assertParamExists('deleteResourceScope', 'scopeId', scopeId)
            const localVarPath = `/api/resources/{resourceId}/scopes/{scopeId}`
                .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)))
                .replace(`{${"scopeId"}}`, encodeURIComponent(String(scopeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an API resource details by ID.
         * @summary Get API resource
         * @param {string} id The unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResource: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getResource', 'id', id)
            const localVarPath = `/api/resources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get scopes (permissions) defined for an API resource.
         * @summary Get API resource scopes
         * @param {string} resourceId The unique identifier of the resource.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResourceScopes: async (resourceId: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('listResourceScopes', 'resourceId', resourceId)
            const localVarPath = `/api/resources/{resourceId}/scopes`
                .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get API resources in the current tenant with pagination.
         * @summary Get API resources
         * @param {string} [includeScopes] If it\&#39;s provided with a truthy value (&#x60;true&#x60;, &#x60;1&#x60;, &#x60;yes&#x60;), the scopes of each resource will be included in the response.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResources: async (includeScopes?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/resources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (includeScopes !== undefined) {
                localVarQueryParameter['includeScopes'] = includeScopes;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an API resource details by ID with the given data. This method performs a partial update.
         * @summary Update API resource
         * @param {string} id The unique identifier of the resource.
         * @param {UpdateResourceRequest} updateResourceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResource: async (id: string, updateResourceRequest: UpdateResourceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateResource', 'id', id)
            // verify required parameter 'updateResourceRequest' is not null or undefined
            assertParamExists('updateResource', 'updateResourceRequest', updateResourceRequest)
            const localVarPath = `/api/resources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateResourceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set an API resource as the default resource for the current tenant.  Each tenant can have only one default API resource. If an API resource is set as default, the previously set default API resource will be set as non-default. See [this section](https://docs.logto.io/docs/references/resources/#default-api) for more information.
         * @summary Set API resource as default
         * @param {string} id The unique identifier of the resource.
         * @param {UpdateResourceIsDefaultRequest} updateResourceIsDefaultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourceIsDefault: async (id: string, updateResourceIsDefaultRequest: UpdateResourceIsDefaultRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateResourceIsDefault', 'id', id)
            // verify required parameter 'updateResourceIsDefaultRequest' is not null or undefined
            assertParamExists('updateResourceIsDefault', 'updateResourceIsDefaultRequest', updateResourceIsDefaultRequest)
            const localVarPath = `/api/resources/{id}/is-default`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateResourceIsDefaultRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an API resource scope (permission) for the given resource. This method performs a partial update.
         * @summary Update API resource scope
         * @param {string} resourceId The unique identifier of the resource.
         * @param {string} scopeId The unique identifier of the scope.
         * @param {UpdateResourceScopeRequest} updateResourceScopeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourceScope: async (resourceId: string, scopeId: string, updateResourceScopeRequest: UpdateResourceScopeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('updateResourceScope', 'resourceId', resourceId)
            // verify required parameter 'scopeId' is not null or undefined
            assertParamExists('updateResourceScope', 'scopeId', scopeId)
            // verify required parameter 'updateResourceScopeRequest' is not null or undefined
            assertParamExists('updateResourceScope', 'updateResourceScopeRequest', updateResourceScopeRequest)
            const localVarPath = `/api/resources/{resourceId}/scopes/{scopeId}`
                .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)))
                .replace(`{${"scopeId"}}`, encodeURIComponent(String(scopeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateResourceScopeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourcesApi - functional programming interface
 * @export
 */
export const ResourcesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an API resource in the current tenant.
         * @summary Create an API resource
         * @param {CreateResourceRequest} createResourceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createResource(createResourceRequest: CreateResourceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createResource(createResourceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.createResource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new scope (permission) for an API resource.
         * @summary Create API resource scope
         * @param {string} resourceId The unique identifier of the resource.
         * @param {CreateResourceScopeRequest} createResourceScopeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createResourceScope(resourceId: string, createResourceScopeRequest: CreateResourceScopeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceScope(resourceId, createResourceScopeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.createResourceScope']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an API resource by ID.
         * @summary Delete API resource
         * @param {string} id The unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResource(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResource(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.deleteResource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an API resource scope (permission) from the given resource.
         * @summary Delete API resource scope
         * @param {string} resourceId The unique identifier of the resource.
         * @param {string} scopeId The unique identifier of the scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResourceScope(resourceId: string, scopeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceScope(resourceId, scopeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.deleteResourceScope']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an API resource details by ID.
         * @summary Get API resource
         * @param {string} id The unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResource(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResource(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.getResource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get scopes (permissions) defined for an API resource.
         * @summary Get API resource scopes
         * @param {string} resourceId The unique identifier of the resource.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listResourceScopes(resourceId: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListResources200ResponseInnerScopesInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listResourceScopes(resourceId, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.listResourceScopes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get API resources in the current tenant with pagination.
         * @summary Get API resources
         * @param {string} [includeScopes] If it\&#39;s provided with a truthy value (&#x60;true&#x60;, &#x60;1&#x60;, &#x60;yes&#x60;), the scopes of each resource will be included in the response.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listResources(includeScopes?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListResources200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listResources(includeScopes, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.listResources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an API resource details by ID with the given data. This method performs a partial update.
         * @summary Update API resource
         * @param {string} id The unique identifier of the resource.
         * @param {UpdateResourceRequest} updateResourceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResource(id: string, updateResourceRequest: UpdateResourceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateResource(id, updateResourceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.updateResource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set an API resource as the default resource for the current tenant.  Each tenant can have only one default API resource. If an API resource is set as default, the previously set default API resource will be set as non-default. See [this section](https://docs.logto.io/docs/references/resources/#default-api) for more information.
         * @summary Set API resource as default
         * @param {string} id The unique identifier of the resource.
         * @param {UpdateResourceIsDefaultRequest} updateResourceIsDefaultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResourceIsDefault(id: string, updateResourceIsDefaultRequest: UpdateResourceIsDefaultRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateResourceIsDefault(id, updateResourceIsDefaultRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.updateResourceIsDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an API resource scope (permission) for the given resource. This method performs a partial update.
         * @summary Update API resource scope
         * @param {string} resourceId The unique identifier of the resource.
         * @param {string} scopeId The unique identifier of the scope.
         * @param {UpdateResourceScopeRequest} updateResourceScopeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResourceScope(resourceId: string, scopeId: string, updateResourceScopeRequest: UpdateResourceScopeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListResources200ResponseInnerScopesInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateResourceScope(resourceId, scopeId, updateResourceScopeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.updateResourceScope']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResourcesApi - factory interface
 * @export
 */
export const ResourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourcesApiFp(configuration)
    return {
        /**
         * Create an API resource in the current tenant.
         * @summary Create an API resource
         * @param {CreateResourceRequest} createResourceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResource(createResourceRequest: CreateResourceRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createResource(createResourceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new scope (permission) for an API resource.
         * @summary Create API resource scope
         * @param {string} resourceId The unique identifier of the resource.
         * @param {CreateResourceScopeRequest} createResourceScopeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourceScope(resourceId: string, createResourceScopeRequest: CreateResourceScopeRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createResourceScope(resourceId, createResourceScopeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an API resource by ID.
         * @summary Delete API resource
         * @param {string} id The unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResource(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteResource(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an API resource scope (permission) from the given resource.
         * @summary Delete API resource scope
         * @param {string} resourceId The unique identifier of the resource.
         * @param {string} scopeId The unique identifier of the scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourceScope(resourceId: string, scopeId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteResourceScope(resourceId, scopeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an API resource details by ID.
         * @summary Get API resource
         * @param {string} id The unique identifier of the resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResource(id: string, options?: any): AxiosPromise<GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource> {
            return localVarFp.getResource(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get scopes (permissions) defined for an API resource.
         * @summary Get API resource scopes
         * @param {string} resourceId The unique identifier of the resource.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResourceScopes(resourceId: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ListResources200ResponseInnerScopesInner>> {
            return localVarFp.listResourceScopes(resourceId, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get API resources in the current tenant with pagination.
         * @summary Get API resources
         * @param {string} [includeScopes] If it\&#39;s provided with a truthy value (&#x60;true&#x60;, &#x60;1&#x60;, &#x60;yes&#x60;), the scopes of each resource will be included in the response.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResources(includeScopes?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ListResources200ResponseInner>> {
            return localVarFp.listResources(includeScopes, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an API resource details by ID with the given data. This method performs a partial update.
         * @summary Update API resource
         * @param {string} id The unique identifier of the resource.
         * @param {UpdateResourceRequest} updateResourceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResource(id: string, updateResourceRequest: UpdateResourceRequest, options?: any): AxiosPromise<GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource> {
            return localVarFp.updateResource(id, updateResourceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Set an API resource as the default resource for the current tenant.  Each tenant can have only one default API resource. If an API resource is set as default, the previously set default API resource will be set as non-default. See [this section](https://docs.logto.io/docs/references/resources/#default-api) for more information.
         * @summary Set API resource as default
         * @param {string} id The unique identifier of the resource.
         * @param {UpdateResourceIsDefaultRequest} updateResourceIsDefaultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourceIsDefault(id: string, updateResourceIsDefaultRequest: UpdateResourceIsDefaultRequest, options?: any): AxiosPromise<GetJwtCustomizer200ResponseOneOfContextSampleUserRolesInnerScopesInnerResource> {
            return localVarFp.updateResourceIsDefault(id, updateResourceIsDefaultRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an API resource scope (permission) for the given resource. This method performs a partial update.
         * @summary Update API resource scope
         * @param {string} resourceId The unique identifier of the resource.
         * @param {string} scopeId The unique identifier of the scope.
         * @param {UpdateResourceScopeRequest} updateResourceScopeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourceScope(resourceId: string, scopeId: string, updateResourceScopeRequest: UpdateResourceScopeRequest, options?: any): AxiosPromise<ListResources200ResponseInnerScopesInner> {
            return localVarFp.updateResourceScope(resourceId, scopeId, updateResourceScopeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResourcesApi - object-oriented interface
 * @export
 * @class ResourcesApi
 * @extends {BaseAPI}
 */
export class ResourcesApi extends BaseAPI {
    /**
     * Create an API resource in the current tenant.
     * @summary Create an API resource
     * @param {CreateResourceRequest} createResourceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public createResource(createResourceRequest: CreateResourceRequest, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).createResource(createResourceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new scope (permission) for an API resource.
     * @summary Create API resource scope
     * @param {string} resourceId The unique identifier of the resource.
     * @param {CreateResourceScopeRequest} createResourceScopeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public createResourceScope(resourceId: string, createResourceScopeRequest: CreateResourceScopeRequest, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).createResourceScope(resourceId, createResourceScopeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an API resource by ID.
     * @summary Delete API resource
     * @param {string} id The unique identifier of the resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public deleteResource(id: string, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).deleteResource(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an API resource scope (permission) from the given resource.
     * @summary Delete API resource scope
     * @param {string} resourceId The unique identifier of the resource.
     * @param {string} scopeId The unique identifier of the scope.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public deleteResourceScope(resourceId: string, scopeId: string, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).deleteResourceScope(resourceId, scopeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an API resource details by ID.
     * @summary Get API resource
     * @param {string} id The unique identifier of the resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public getResource(id: string, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).getResource(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get scopes (permissions) defined for an API resource.
     * @summary Get API resource scopes
     * @param {string} resourceId The unique identifier of the resource.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public listResourceScopes(resourceId: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).listResourceScopes(resourceId, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get API resources in the current tenant with pagination.
     * @summary Get API resources
     * @param {string} [includeScopes] If it\&#39;s provided with a truthy value (&#x60;true&#x60;, &#x60;1&#x60;, &#x60;yes&#x60;), the scopes of each resource will be included in the response.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public listResources(includeScopes?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).listResources(includeScopes, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an API resource details by ID with the given data. This method performs a partial update.
     * @summary Update API resource
     * @param {string} id The unique identifier of the resource.
     * @param {UpdateResourceRequest} updateResourceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public updateResource(id: string, updateResourceRequest: UpdateResourceRequest, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).updateResource(id, updateResourceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set an API resource as the default resource for the current tenant.  Each tenant can have only one default API resource. If an API resource is set as default, the previously set default API resource will be set as non-default. See [this section](https://docs.logto.io/docs/references/resources/#default-api) for more information.
     * @summary Set API resource as default
     * @param {string} id The unique identifier of the resource.
     * @param {UpdateResourceIsDefaultRequest} updateResourceIsDefaultRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public updateResourceIsDefault(id: string, updateResourceIsDefaultRequest: UpdateResourceIsDefaultRequest, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).updateResourceIsDefault(id, updateResourceIsDefaultRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an API resource scope (permission) for the given resource. This method performs a partial update.
     * @summary Update API resource scope
     * @param {string} resourceId The unique identifier of the resource.
     * @param {string} scopeId The unique identifier of the scope.
     * @param {UpdateResourceScopeRequest} updateResourceScopeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public updateResourceScope(resourceId: string, scopeId: string, updateResourceScopeRequest: UpdateResourceScopeRequest, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).updateResourceScope(resourceId, scopeId, updateResourceScopeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RolesApi - axios parameter creator
 * @export
 */
export const RolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new role with the given data.
         * @summary Create a role
         * @param {CreateRoleRequest} createRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole: async (createRoleRequest: CreateRoleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRoleRequest' is not null or undefined
            assertParamExists('createRole', 'createRoleRequest', createRoleRequest)
            const localVarPath = `/api/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign a role to a list of applications. The role must have the type `Application`.
         * @summary Assign role to applications
         * @param {string} id The unique identifier of the role.
         * @param {CreateRoleApplicationRequest} createRoleApplicationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoleApplication: async (id: string, createRoleApplicationRequest: CreateRoleApplicationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createRoleApplication', 'id', id)
            // verify required parameter 'createRoleApplicationRequest' is not null or undefined
            assertParamExists('createRoleApplication', 'createRoleApplicationRequest', createRoleApplicationRequest)
            const localVarPath = `/api/roles/{id}/applications`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRoleApplicationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Link a list of API resource scopes (permissions) to a role. The original linked scopes will be kept.
         * @summary Link scopes to role
         * @param {string} id The unique identifier of the role.
         * @param {CreateRoleScopeRequest} createRoleScopeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoleScope: async (id: string, createRoleScopeRequest: CreateRoleScopeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createRoleScope', 'id', id)
            // verify required parameter 'createRoleScopeRequest' is not null or undefined
            assertParamExists('createRoleScope', 'createRoleScopeRequest', createRoleScopeRequest)
            const localVarPath = `/api/roles/{id}/scopes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRoleScopeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign a role to a list of users. The role must have the type `User`.
         * @summary Assign role to users
         * @param {string} id The unique identifier of the role.
         * @param {CreateRoleUserRequest} createRoleUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoleUser: async (id: string, createRoleUserRequest: CreateRoleUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createRoleUser', 'id', id)
            // verify required parameter 'createRoleUserRequest' is not null or undefined
            assertParamExists('createRoleUser', 'createRoleUserRequest', createRoleUserRequest)
            const localVarPath = `/api/roles/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRoleUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a role with the given ID.
         * @summary Delete role
         * @param {string} id The unique identifier of the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRole', 'id', id)
            const localVarPath = `/api/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove the role from an application with the given ID.
         * @summary Remove role from application
         * @param {string} id The unique identifier of the role.
         * @param {string} applicationId The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleApplication: async (id: string, applicationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRoleApplication', 'id', id)
            // verify required parameter 'applicationId' is not null or undefined
            assertParamExists('deleteRoleApplication', 'applicationId', applicationId)
            const localVarPath = `/api/roles/{id}/applications/{applicationId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unlink an API resource scope (permission) from a role with the given ID.
         * @summary Unlink scope from role
         * @param {string} id The unique identifier of the role.
         * @param {string} scopeId The unique identifier of the scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleScope: async (id: string, scopeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRoleScope', 'id', id)
            // verify required parameter 'scopeId' is not null or undefined
            assertParamExists('deleteRoleScope', 'scopeId', scopeId)
            const localVarPath = `/api/roles/{id}/scopes/{scopeId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"scopeId"}}`, encodeURIComponent(String(scopeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a role from a user with the given ID.
         * @summary Remove role from user
         * @param {string} id The unique identifier of the role.
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleUser: async (id: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRoleUser', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteRoleUser', 'userId', userId)
            const localVarPath = `/api/roles/{id}/users/{userId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get role details by ID.
         * @summary Get role
         * @param {string} id The unique identifier of the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRole', 'id', id)
            const localVarPath = `/api/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get applications that have the role assigned with pagination.
         * @summary Get role applications
         * @param {string} id The unique identifier of the role.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleApplications: async (id: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listRoleApplications', 'id', id)
            const localVarPath = `/api/roles/{id}/applications`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get API resource scopes (permissions) linked with a role.
         * @summary Get role scopes
         * @param {string} id The unique identifier of the role.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleScopes: async (id: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listRoleScopes', 'id', id)
            const localVarPath = `/api/roles/{id}/scopes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get users who have the role assigned with pagination.
         * @summary Get role users
         * @param {string} id The unique identifier of the role.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleUsers: async (id: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listRoleUsers', 'id', id)
            const localVarPath = `/api/roles/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get roles with filters and pagination.
         * @summary Get roles
         * @param {string} [excludeUserId] Exclude roles assigned to a user.
         * @param {string} [excludeApplicationId] Exclude roles assigned to an application.
         * @param {ListRolesTypeEnum} [type] Filter by role type.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles: async (excludeUserId?: string, excludeApplicationId?: string, type?: ListRolesTypeEnum, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (excludeUserId !== undefined) {
                localVarQueryParameter['excludeUserId'] = excludeUserId;
            }

            if (excludeApplicationId !== undefined) {
                localVarQueryParameter['excludeApplicationId'] = excludeApplicationId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update role details. This method performs a partial update.
         * @summary Update role
         * @param {string} id The unique identifier of the role.
         * @param {UpdateRoleRequest} updateRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole: async (id: string, updateRoleRequest: UpdateRoleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRole', 'id', id)
            // verify required parameter 'updateRoleRequest' is not null or undefined
            assertParamExists('updateRole', 'updateRoleRequest', updateRoleRequest)
            const localVarPath = `/api/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesApi - functional programming interface
 * @export
 */
export const RolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RolesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new role with the given data.
         * @summary Create a role
         * @param {CreateRoleRequest} createRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRole(createRoleRequest: CreateRoleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListApplicationRoles200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRole(createRoleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.createRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Assign a role to a list of applications. The role must have the type `Application`.
         * @summary Assign role to applications
         * @param {string} id The unique identifier of the role.
         * @param {CreateRoleApplicationRequest} createRoleApplicationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRoleApplication(id: string, createRoleApplicationRequest: CreateRoleApplicationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRoleApplication(id, createRoleApplicationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.createRoleApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Link a list of API resource scopes (permissions) to a role. The original linked scopes will be kept.
         * @summary Link scopes to role
         * @param {string} id The unique identifier of the role.
         * @param {CreateRoleScopeRequest} createRoleScopeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRoleScope(id: string, createRoleScopeRequest: CreateRoleScopeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRoleScope(id, createRoleScopeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.createRoleScope']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Assign a role to a list of users. The role must have the type `User`.
         * @summary Assign role to users
         * @param {string} id The unique identifier of the role.
         * @param {CreateRoleUserRequest} createRoleUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRoleUser(id: string, createRoleUserRequest: CreateRoleUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRoleUser(id, createRoleUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.createRoleUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a role with the given ID.
         * @summary Delete role
         * @param {string} id The unique identifier of the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRole(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRole(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.deleteRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove the role from an application with the given ID.
         * @summary Remove role from application
         * @param {string} id The unique identifier of the role.
         * @param {string} applicationId The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRoleApplication(id: string, applicationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRoleApplication(id, applicationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.deleteRoleApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unlink an API resource scope (permission) from a role with the given ID.
         * @summary Unlink scope from role
         * @param {string} id The unique identifier of the role.
         * @param {string} scopeId The unique identifier of the scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRoleScope(id: string, scopeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRoleScope(id, scopeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.deleteRoleScope']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a role from a user with the given ID.
         * @summary Remove role from user
         * @param {string} id The unique identifier of the role.
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRoleUser(id: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRoleUser(id, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.deleteRoleUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get role details by ID.
         * @summary Get role
         * @param {string} id The unique identifier of the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRole(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListApplicationRoles200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRole(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.getRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get applications that have the role assigned with pagination.
         * @summary Get role applications
         * @param {string} id The unique identifier of the role.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoleApplications(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListApplications200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoleApplications(id, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.listRoleApplications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get API resource scopes (permissions) linked with a role.
         * @summary Get role scopes
         * @param {string} id The unique identifier of the role.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoleScopes(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListRoleScopes200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoleScopes(id, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.listRoleScopes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get users who have the role assigned with pagination.
         * @summary Get role users
         * @param {string} id The unique identifier of the role.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoleUsers(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UpdateUser200Response>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoleUsers(id, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.listRoleUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get roles with filters and pagination.
         * @summary Get roles
         * @param {string} [excludeUserId] Exclude roles assigned to a user.
         * @param {string} [excludeApplicationId] Exclude roles assigned to an application.
         * @param {ListRolesTypeEnum} [type] Filter by role type.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoles(excludeUserId?: string, excludeApplicationId?: string, type?: ListRolesTypeEnum, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListRoles200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoles(excludeUserId, excludeApplicationId, type, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.listRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update role details. This method performs a partial update.
         * @summary Update role
         * @param {string} id The unique identifier of the role.
         * @param {UpdateRoleRequest} updateRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRole(id: string, updateRoleRequest: UpdateRoleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListApplicationRoles200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRole(id, updateRoleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.updateRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RolesApi - factory interface
 * @export
 */
export const RolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RolesApiFp(configuration)
    return {
        /**
         * Create a new role with the given data.
         * @summary Create a role
         * @param {CreateRoleRequest} createRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole(createRoleRequest: CreateRoleRequest, options?: any): AxiosPromise<ListApplicationRoles200ResponseInner> {
            return localVarFp.createRole(createRoleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign a role to a list of applications. The role must have the type `Application`.
         * @summary Assign role to applications
         * @param {string} id The unique identifier of the role.
         * @param {CreateRoleApplicationRequest} createRoleApplicationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoleApplication(id: string, createRoleApplicationRequest: CreateRoleApplicationRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createRoleApplication(id, createRoleApplicationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Link a list of API resource scopes (permissions) to a role. The original linked scopes will be kept.
         * @summary Link scopes to role
         * @param {string} id The unique identifier of the role.
         * @param {CreateRoleScopeRequest} createRoleScopeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoleScope(id: string, createRoleScopeRequest: CreateRoleScopeRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createRoleScope(id, createRoleScopeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign a role to a list of users. The role must have the type `User`.
         * @summary Assign role to users
         * @param {string} id The unique identifier of the role.
         * @param {CreateRoleUserRequest} createRoleUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoleUser(id: string, createRoleUserRequest: CreateRoleUserRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createRoleUser(id, createRoleUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a role with the given ID.
         * @summary Delete role
         * @param {string} id The unique identifier of the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRole(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove the role from an application with the given ID.
         * @summary Remove role from application
         * @param {string} id The unique identifier of the role.
         * @param {string} applicationId The unique identifier of the application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleApplication(id: string, applicationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRoleApplication(id, applicationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Unlink an API resource scope (permission) from a role with the given ID.
         * @summary Unlink scope from role
         * @param {string} id The unique identifier of the role.
         * @param {string} scopeId The unique identifier of the scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleScope(id: string, scopeId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRoleScope(id, scopeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a role from a user with the given ID.
         * @summary Remove role from user
         * @param {string} id The unique identifier of the role.
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleUser(id: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRoleUser(id, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get role details by ID.
         * @summary Get role
         * @param {string} id The unique identifier of the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole(id: string, options?: any): AxiosPromise<ListApplicationRoles200ResponseInner> {
            return localVarFp.getRole(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get applications that have the role assigned with pagination.
         * @summary Get role applications
         * @param {string} id The unique identifier of the role.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleApplications(id: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ListApplications200ResponseInner>> {
            return localVarFp.listRoleApplications(id, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get API resource scopes (permissions) linked with a role.
         * @summary Get role scopes
         * @param {string} id The unique identifier of the role.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleScopes(id: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ListRoleScopes200ResponseInner>> {
            return localVarFp.listRoleScopes(id, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get users who have the role assigned with pagination.
         * @summary Get role users
         * @param {string} id The unique identifier of the role.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleUsers(id: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<UpdateUser200Response>> {
            return localVarFp.listRoleUsers(id, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get roles with filters and pagination.
         * @summary Get roles
         * @param {string} [excludeUserId] Exclude roles assigned to a user.
         * @param {string} [excludeApplicationId] Exclude roles assigned to an application.
         * @param {ListRolesTypeEnum} [type] Filter by role type.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(excludeUserId?: string, excludeApplicationId?: string, type?: ListRolesTypeEnum, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ListRoles200ResponseInner>> {
            return localVarFp.listRoles(excludeUserId, excludeApplicationId, type, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Update role details. This method performs a partial update.
         * @summary Update role
         * @param {string} id The unique identifier of the role.
         * @param {UpdateRoleRequest} updateRoleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole(id: string, updateRoleRequest: UpdateRoleRequest, options?: any): AxiosPromise<ListApplicationRoles200ResponseInner> {
            return localVarFp.updateRole(id, updateRoleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export class RolesApi extends BaseAPI {
    /**
     * Create a new role with the given data.
     * @summary Create a role
     * @param {CreateRoleRequest} createRoleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public createRole(createRoleRequest: CreateRoleRequest, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).createRole(createRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assign a role to a list of applications. The role must have the type `Application`.
     * @summary Assign role to applications
     * @param {string} id The unique identifier of the role.
     * @param {CreateRoleApplicationRequest} createRoleApplicationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public createRoleApplication(id: string, createRoleApplicationRequest: CreateRoleApplicationRequest, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).createRoleApplication(id, createRoleApplicationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Link a list of API resource scopes (permissions) to a role. The original linked scopes will be kept.
     * @summary Link scopes to role
     * @param {string} id The unique identifier of the role.
     * @param {CreateRoleScopeRequest} createRoleScopeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public createRoleScope(id: string, createRoleScopeRequest: CreateRoleScopeRequest, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).createRoleScope(id, createRoleScopeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assign a role to a list of users. The role must have the type `User`.
     * @summary Assign role to users
     * @param {string} id The unique identifier of the role.
     * @param {CreateRoleUserRequest} createRoleUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public createRoleUser(id: string, createRoleUserRequest: CreateRoleUserRequest, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).createRoleUser(id, createRoleUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a role with the given ID.
     * @summary Delete role
     * @param {string} id The unique identifier of the role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public deleteRole(id: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).deleteRole(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove the role from an application with the given ID.
     * @summary Remove role from application
     * @param {string} id The unique identifier of the role.
     * @param {string} applicationId The unique identifier of the application.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public deleteRoleApplication(id: string, applicationId: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).deleteRoleApplication(id, applicationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unlink an API resource scope (permission) from a role with the given ID.
     * @summary Unlink scope from role
     * @param {string} id The unique identifier of the role.
     * @param {string} scopeId The unique identifier of the scope.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public deleteRoleScope(id: string, scopeId: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).deleteRoleScope(id, scopeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a role from a user with the given ID.
     * @summary Remove role from user
     * @param {string} id The unique identifier of the role.
     * @param {string} userId The unique identifier of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public deleteRoleUser(id: string, userId: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).deleteRoleUser(id, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get role details by ID.
     * @summary Get role
     * @param {string} id The unique identifier of the role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRole(id: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).getRole(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get applications that have the role assigned with pagination.
     * @summary Get role applications
     * @param {string} id The unique identifier of the role.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public listRoleApplications(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).listRoleApplications(id, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get API resource scopes (permissions) linked with a role.
     * @summary Get role scopes
     * @param {string} id The unique identifier of the role.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public listRoleScopes(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).listRoleScopes(id, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get users who have the role assigned with pagination.
     * @summary Get role users
     * @param {string} id The unique identifier of the role.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public listRoleUsers(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).listRoleUsers(id, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get roles with filters and pagination.
     * @summary Get roles
     * @param {string} [excludeUserId] Exclude roles assigned to a user.
     * @param {string} [excludeApplicationId] Exclude roles assigned to an application.
     * @param {ListRolesTypeEnum} [type] Filter by role type.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public listRoles(excludeUserId?: string, excludeApplicationId?: string, type?: ListRolesTypeEnum, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).listRoles(excludeUserId, excludeApplicationId, type, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update role details. This method performs a partial update.
     * @summary Update role
     * @param {string} id The unique identifier of the role.
     * @param {UpdateRoleRequest} updateRoleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public updateRole(id: string, updateRoleRequest: UpdateRoleRequest, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).updateRole(id, updateRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListRolesTypeEnum = {
    User: 'User',
    MachineToMachine: 'MachineToMachine'
} as const;
export type ListRolesTypeEnum = typeof ListRolesTypeEnum[keyof typeof ListRolesTypeEnum];


/**
 * SSOConnectorProvidersApi - axios parameter creator
 * @export
 */
export const SSOConnectorProvidersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a complete list of supported SSO connector providers.
         * @summary List all the supported SSO connector provider details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSsoConnectorProviders: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso-connector-providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SSOConnectorProvidersApi - functional programming interface
 * @export
 */
export const SSOConnectorProvidersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SSOConnectorProvidersApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a complete list of supported SSO connector providers.
         * @summary List all the supported SSO connector provider details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSsoConnectorProviders(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListSsoConnectorProviders200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSsoConnectorProviders(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SSOConnectorProvidersApi.listSsoConnectorProviders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SSOConnectorProvidersApi - factory interface
 * @export
 */
export const SSOConnectorProvidersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SSOConnectorProvidersApiFp(configuration)
    return {
        /**
         * Get a complete list of supported SSO connector providers.
         * @summary List all the supported SSO connector provider details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSsoConnectorProviders(options?: any): AxiosPromise<Array<ListSsoConnectorProviders200ResponseInner>> {
            return localVarFp.listSsoConnectorProviders(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SSOConnectorProvidersApi - object-oriented interface
 * @export
 * @class SSOConnectorProvidersApi
 * @extends {BaseAPI}
 */
export class SSOConnectorProvidersApi extends BaseAPI {
    /**
     * Get a complete list of supported SSO connector providers.
     * @summary List all the supported SSO connector provider details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SSOConnectorProvidersApi
     */
    public listSsoConnectorProviders(options?: RawAxiosRequestConfig) {
        return SSOConnectorProvidersApiFp(this.configuration).listSsoConnectorProviders(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SSOConnectorsApi - axios parameter creator
 * @export
 */
export const SSOConnectorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an new SSO connector instance for a given provider.
         * @summary Create SSO connector
         * @param {CreateSsoConnectorRequest} createSsoConnectorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSsoConnector: async (createSsoConnectorRequest: CreateSsoConnectorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createSsoConnectorRequest' is not null or undefined
            assertParamExists('createSsoConnector', 'createSsoConnectorRequest', createSsoConnectorRequest)
            const localVarPath = `/api/sso-connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSsoConnectorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an SSO connector by ID.
         * @summary Delete SSO connector
         * @param {string} id The unique identifier of the sso connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSsoConnector: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSsoConnector', 'id', id)
            const localVarPath = `/api/sso-connectors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SSO connector data by ID. In addition to the raw SSO connector data, a copy of fetched or parsed IdP configs and a copy of connector provider\'s data will be attached.
         * @summary Get SSO connector
         * @param {string} id The unique identifier of the sso connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSsoConnector: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSsoConnector', 'id', id)
            const localVarPath = `/api/sso-connectors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SSO connectors with pagination. In addition to the raw SSO connector data, a copy of fetched or parsed IdP configs and a copy of connector provider\'s data will be attached.
         * @summary List SSO connectors
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSsoConnectors: async (page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sso-connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an SSO connector by ID. This method performs a partial update.
         * @summary Update SSO connector
         * @param {string} id The unique identifier of the sso connector.
         * @param {UpdateSsoConnectorRequest} updateSsoConnectorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSsoConnector: async (id: string, updateSsoConnectorRequest: UpdateSsoConnectorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSsoConnector', 'id', id)
            // verify required parameter 'updateSsoConnectorRequest' is not null or undefined
            assertParamExists('updateSsoConnector', 'updateSsoConnectorRequest', updateSsoConnectorRequest)
            const localVarPath = `/api/sso-connectors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSsoConnectorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SSOConnectorsApi - functional programming interface
 * @export
 */
export const SSOConnectorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SSOConnectorsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an new SSO connector instance for a given provider.
         * @summary Create SSO connector
         * @param {CreateSsoConnectorRequest} createSsoConnectorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSsoConnector(createSsoConnectorRequest: CreateSsoConnectorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOrganizationJitSsoConnectors200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSsoConnector(createSsoConnectorRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SSOConnectorsApi.createSsoConnector']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an SSO connector by ID.
         * @summary Delete SSO connector
         * @param {string} id The unique identifier of the sso connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSsoConnector(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSsoConnector(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SSOConnectorsApi.deleteSsoConnector']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SSO connector data by ID. In addition to the raw SSO connector data, a copy of fetched or parsed IdP configs and a copy of connector provider\'s data will be attached.
         * @summary Get SSO connector
         * @param {string} id The unique identifier of the sso connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSsoConnector(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSsoConnectors200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSsoConnector(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SSOConnectorsApi.getSsoConnector']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SSO connectors with pagination. In addition to the raw SSO connector data, a copy of fetched or parsed IdP configs and a copy of connector provider\'s data will be attached.
         * @summary List SSO connectors
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSsoConnectors(page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListSsoConnectors200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSsoConnectors(page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SSOConnectorsApi.listSsoConnectors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an SSO connector by ID. This method performs a partial update.
         * @summary Update SSO connector
         * @param {string} id The unique identifier of the sso connector.
         * @param {UpdateSsoConnectorRequest} updateSsoConnectorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSsoConnector(id: string, updateSsoConnectorRequest: UpdateSsoConnectorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSsoConnectors200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSsoConnector(id, updateSsoConnectorRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SSOConnectorsApi.updateSsoConnector']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SSOConnectorsApi - factory interface
 * @export
 */
export const SSOConnectorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SSOConnectorsApiFp(configuration)
    return {
        /**
         * Create an new SSO connector instance for a given provider.
         * @summary Create SSO connector
         * @param {CreateSsoConnectorRequest} createSsoConnectorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSsoConnector(createSsoConnectorRequest: CreateSsoConnectorRequest, options?: any): AxiosPromise<ListOrganizationJitSsoConnectors200ResponseInner> {
            return localVarFp.createSsoConnector(createSsoConnectorRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an SSO connector by ID.
         * @summary Delete SSO connector
         * @param {string} id The unique identifier of the sso connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSsoConnector(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSsoConnector(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SSO connector data by ID. In addition to the raw SSO connector data, a copy of fetched or parsed IdP configs and a copy of connector provider\'s data will be attached.
         * @summary Get SSO connector
         * @param {string} id The unique identifier of the sso connector.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSsoConnector(id: string, options?: any): AxiosPromise<ListSsoConnectors200ResponseInner> {
            return localVarFp.getSsoConnector(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SSO connectors with pagination. In addition to the raw SSO connector data, a copy of fetched or parsed IdP configs and a copy of connector provider\'s data will be attached.
         * @summary List SSO connectors
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSsoConnectors(page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ListSsoConnectors200ResponseInner>> {
            return localVarFp.listSsoConnectors(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an SSO connector by ID. This method performs a partial update.
         * @summary Update SSO connector
         * @param {string} id The unique identifier of the sso connector.
         * @param {UpdateSsoConnectorRequest} updateSsoConnectorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSsoConnector(id: string, updateSsoConnectorRequest: UpdateSsoConnectorRequest, options?: any): AxiosPromise<ListSsoConnectors200ResponseInner> {
            return localVarFp.updateSsoConnector(id, updateSsoConnectorRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SSOConnectorsApi - object-oriented interface
 * @export
 * @class SSOConnectorsApi
 * @extends {BaseAPI}
 */
export class SSOConnectorsApi extends BaseAPI {
    /**
     * Create an new SSO connector instance for a given provider.
     * @summary Create SSO connector
     * @param {CreateSsoConnectorRequest} createSsoConnectorRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SSOConnectorsApi
     */
    public createSsoConnector(createSsoConnectorRequest: CreateSsoConnectorRequest, options?: RawAxiosRequestConfig) {
        return SSOConnectorsApiFp(this.configuration).createSsoConnector(createSsoConnectorRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an SSO connector by ID.
     * @summary Delete SSO connector
     * @param {string} id The unique identifier of the sso connector.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SSOConnectorsApi
     */
    public deleteSsoConnector(id: string, options?: RawAxiosRequestConfig) {
        return SSOConnectorsApiFp(this.configuration).deleteSsoConnector(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SSO connector data by ID. In addition to the raw SSO connector data, a copy of fetched or parsed IdP configs and a copy of connector provider\'s data will be attached.
     * @summary Get SSO connector
     * @param {string} id The unique identifier of the sso connector.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SSOConnectorsApi
     */
    public getSsoConnector(id: string, options?: RawAxiosRequestConfig) {
        return SSOConnectorsApiFp(this.configuration).getSsoConnector(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SSO connectors with pagination. In addition to the raw SSO connector data, a copy of fetched or parsed IdP configs and a copy of connector provider\'s data will be attached.
     * @summary List SSO connectors
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SSOConnectorsApi
     */
    public listSsoConnectors(page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return SSOConnectorsApiFp(this.configuration).listSsoConnectors(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an SSO connector by ID. This method performs a partial update.
     * @summary Update SSO connector
     * @param {string} id The unique identifier of the sso connector.
     * @param {UpdateSsoConnectorRequest} updateSsoConnectorRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SSOConnectorsApi
     */
    public updateSsoConnector(id: string, updateSsoConnectorRequest: UpdateSsoConnectorRequest, options?: RawAxiosRequestConfig) {
        return SSOConnectorsApiFp(this.configuration).updateSsoConnector(id, updateSsoConnectorRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SignInExperienceApi - axios parameter creator
 * @export
 */
export const SignInExperienceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the default sign-in experience settings.
         * @summary Get default sign-in experience settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignInExp: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sign-in-exp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the default sign-in experience settings with the provided data.
         * @summary Update default sign-in experience settings
         * @param {UpdateSignInExpRequest} updateSignInExpRequest 
         * @param {string} [removeUnusedDemoSocialConnector] Whether to remove unused demo social connectors. (These demo social connectors are only used during cloud user onboarding)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSignInExp: async (updateSignInExpRequest: UpdateSignInExpRequest, removeUnusedDemoSocialConnector?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateSignInExpRequest' is not null or undefined
            assertParamExists('updateSignInExp', 'updateSignInExpRequest', updateSignInExpRequest)
            const localVarPath = `/api/sign-in-exp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (removeUnusedDemoSocialConnector !== undefined) {
                localVarQueryParameter['removeUnusedDemoSocialConnector'] = removeUnusedDemoSocialConnector;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSignInExpRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SignInExperienceApi - functional programming interface
 * @export
 */
export const SignInExperienceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SignInExperienceApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the default sign-in experience settings.
         * @summary Get default sign-in experience settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignInExp(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignInExp200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignInExp(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SignInExperienceApi.getSignInExp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the default sign-in experience settings with the provided data.
         * @summary Update default sign-in experience settings
         * @param {UpdateSignInExpRequest} updateSignInExpRequest 
         * @param {string} [removeUnusedDemoSocialConnector] Whether to remove unused demo social connectors. (These demo social connectors are only used during cloud user onboarding)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSignInExp(updateSignInExpRequest: UpdateSignInExpRequest, removeUnusedDemoSocialConnector?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateSignInExp200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSignInExp(updateSignInExpRequest, removeUnusedDemoSocialConnector, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SignInExperienceApi.updateSignInExp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SignInExperienceApi - factory interface
 * @export
 */
export const SignInExperienceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SignInExperienceApiFp(configuration)
    return {
        /**
         * Get the default sign-in experience settings.
         * @summary Get default sign-in experience settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignInExp(options?: any): AxiosPromise<GetSignInExp200Response> {
            return localVarFp.getSignInExp(options).then((request) => request(axios, basePath));
        },
        /**
         * Update the default sign-in experience settings with the provided data.
         * @summary Update default sign-in experience settings
         * @param {UpdateSignInExpRequest} updateSignInExpRequest 
         * @param {string} [removeUnusedDemoSocialConnector] Whether to remove unused demo social connectors. (These demo social connectors are only used during cloud user onboarding)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSignInExp(updateSignInExpRequest: UpdateSignInExpRequest, removeUnusedDemoSocialConnector?: string, options?: any): AxiosPromise<UpdateSignInExp200Response> {
            return localVarFp.updateSignInExp(updateSignInExpRequest, removeUnusedDemoSocialConnector, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SignInExperienceApi - object-oriented interface
 * @export
 * @class SignInExperienceApi
 * @extends {BaseAPI}
 */
export class SignInExperienceApi extends BaseAPI {
    /**
     * Get the default sign-in experience settings.
     * @summary Get default sign-in experience settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignInExperienceApi
     */
    public getSignInExp(options?: RawAxiosRequestConfig) {
        return SignInExperienceApiFp(this.configuration).getSignInExp(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the default sign-in experience settings with the provided data.
     * @summary Update default sign-in experience settings
     * @param {UpdateSignInExpRequest} updateSignInExpRequest 
     * @param {string} [removeUnusedDemoSocialConnector] Whether to remove unused demo social connectors. (These demo social connectors are only used during cloud user onboarding)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignInExperienceApi
     */
    public updateSignInExp(updateSignInExpRequest: UpdateSignInExpRequest, removeUnusedDemoSocialConnector?: string, options?: RawAxiosRequestConfig) {
        return SignInExperienceApiFp(this.configuration).updateSignInExp(updateSignInExpRequest, removeUnusedDemoSocialConnector, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The traditional health check API. No authentication needed.  > **Note** > Even if 204 is returned, it does not guarantee all the APIs are working properly since they may depend on additional resources or external services.
         * @summary Health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatusApiAxiosParamCreator(configuration)
    return {
        /**
         * The traditional health check API. No authentication needed.  > **Note** > Even if 204 is returned, it does not guarantee all the APIs are working properly since they may depend on additional resources or external services.
         * @summary Health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusApi.getStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatusApiFp(configuration)
    return {
        /**
         * The traditional health check API. No authentication needed.  > **Note** > Even if 204 is returned, it does not guarantee all the APIs are working properly since they may depend on additional resources or external services.
         * @summary Health check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options?: any): AxiosPromise<void> {
            return localVarFp.getStatus(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
    /**
     * The traditional health check API. No authentication needed.  > **Note** > Even if 204 is returned, it does not guarantee all the APIs are working properly since they may depend on additional resources or external services.
     * @summary Health check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public getStatus(options?: RawAxiosRequestConfig) {
        return StatusApiFp(this.configuration).getStatus(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SwaggerJsonApi - axios parameter creator
 * @export
 */
export const SwaggerJsonApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The endpoint for the current JSON document. The JSON conforms to the [OpenAPI v3.0.1](https://spec.openapis.org/oas/v3.0.1) (a.k.a. Swagger) specification.
         * @summary Get Swagger JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwaggerJson: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/swagger.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SwaggerJsonApi - functional programming interface
 * @export
 */
export const SwaggerJsonApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SwaggerJsonApiAxiosParamCreator(configuration)
    return {
        /**
         * The endpoint for the current JSON document. The JSON conforms to the [OpenAPI v3.0.1](https://spec.openapis.org/oas/v3.0.1) (a.k.a. Swagger) specification.
         * @summary Get Swagger JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSwaggerJson(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSwaggerJson(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SwaggerJsonApi.getSwaggerJson']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SwaggerJsonApi - factory interface
 * @export
 */
export const SwaggerJsonApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SwaggerJsonApiFp(configuration)
    return {
        /**
         * The endpoint for the current JSON document. The JSON conforms to the [OpenAPI v3.0.1](https://spec.openapis.org/oas/v3.0.1) (a.k.a. Swagger) specification.
         * @summary Get Swagger JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwaggerJson(options?: any): AxiosPromise<void> {
            return localVarFp.getSwaggerJson(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SwaggerJsonApi - object-oriented interface
 * @export
 * @class SwaggerJsonApi
 * @extends {BaseAPI}
 */
export class SwaggerJsonApi extends BaseAPI {
    /**
     * The endpoint for the current JSON document. The JSON conforms to the [OpenAPI v3.0.1](https://spec.openapis.org/oas/v3.0.1) (a.k.a. Swagger) specification.
     * @summary Get Swagger JSON
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SwaggerJsonApi
     */
    public getSwaggerJson(options?: RawAxiosRequestConfig) {
        return SwaggerJsonApiFp(this.configuration).getSwaggerJson(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SystemsApi - axios parameter creator
 * @export
 */
export const SystemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the application constants.
         * @summary Get the application constants.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemApplicationConfig: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/systems/application`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemsApi - functional programming interface
 * @export
 */
export const SystemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the application constants.
         * @summary Get the application constants.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemApplicationConfig(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSystemApplicationConfig200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemApplicationConfig(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemsApi.getSystemApplicationConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SystemsApi - factory interface
 * @export
 */
export const SystemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemsApiFp(configuration)
    return {
        /**
         * Get the application constants.
         * @summary Get the application constants.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemApplicationConfig(options?: any): AxiosPromise<GetSystemApplicationConfig200Response> {
            return localVarFp.getSystemApplicationConfig(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemsApi - object-oriented interface
 * @export
 * @class SystemsApi
 * @extends {BaseAPI}
 */
export class SystemsApi extends BaseAPI {
    /**
     * Get the application constants.
     * @summary Get the application constants.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public getSystemApplicationConfig(options?: RawAxiosRequestConfig) {
        return SystemsApiFp(this.configuration).getSystemApplicationConfig(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserAssetsApi - axios parameter creator
 * @export
 */
export const UserAssetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Upload a user asset.
         * @summary Upload asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAsset: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user-assets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user assets service status.
         * @summary Get service status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAssetServiceStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user-assets/service-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserAssetsApi - functional programming interface
 * @export
 */
export const UserAssetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserAssetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Upload a user asset.
         * @summary Upload asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserAsset(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserAsset200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserAsset(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserAssetsApi.createUserAsset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user assets service status.
         * @summary Get service status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAssetServiceStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserAssetServiceStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAssetServiceStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserAssetsApi.getUserAssetServiceStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserAssetsApi - factory interface
 * @export
 */
export const UserAssetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserAssetsApiFp(configuration)
    return {
        /**
         * Upload a user asset.
         * @summary Upload asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAsset(options?: any): AxiosPromise<CreateUserAsset200Response> {
            return localVarFp.createUserAsset(options).then((request) => request(axios, basePath));
        },
        /**
         * Get user assets service status.
         * @summary Get service status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAssetServiceStatus(options?: any): AxiosPromise<GetUserAssetServiceStatus200Response> {
            return localVarFp.getUserAssetServiceStatus(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserAssetsApi - object-oriented interface
 * @export
 * @class UserAssetsApi
 * @extends {BaseAPI}
 */
export class UserAssetsApi extends BaseAPI {
    /**
     * Upload a user asset.
     * @summary Upload asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAssetsApi
     */
    public createUserAsset(options?: RawAxiosRequestConfig) {
        return UserAssetsApiFp(this.configuration).createUserAsset(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user assets service status.
     * @summary Get service status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAssetsApi
     */
    public getUserAssetServiceStatus(options?: RawAxiosRequestConfig) {
        return UserAssetsApiFp(this.configuration).getUserAssetServiceStatus(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Assign API resource roles to the user. The roles will be added to the existing roles.
         * @summary Assign roles to user
         * @param {string} userId The unique identifier of the user.
         * @param {AssignApplicationRolesRequest} assignApplicationRolesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignUserRoles: async (userId: string, assignApplicationRolesRequest: AssignApplicationRolesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('assignUserRoles', 'userId', userId)
            // verify required parameter 'assignApplicationRolesRequest' is not null or undefined
            assertParamExists('assignUserRoles', 'assignApplicationRolesRequest', assignApplicationRolesRequest)
            const localVarPath = `/api/users/{userId}/roles`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignApplicationRolesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user with the given data.
         * @summary Create user
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (createUserRequest: CreateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserRequest' is not null or undefined
            assertParamExists('createUser', 'createUserRequest', createUserRequest)
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Link authenticated user identity from a social platform to a Logto user.  The usage of this API is usually coupled with `POST /connectors/:connectorId/authorization-uri`. With the help of these pair of APIs, you can implement a user profile page with the link social account feature in your application.  Note: Currently due to technical limitations, this API does not support the following connectors that rely on Logto interaction session: `@logto/connector-apple`, `@logto/connector-saml`, `@logto/connector-oidc` and `@logto/connector-oauth`.
         * @summary Link social identity to user
         * @param {string} userId The unique identifier of the user.
         * @param {CreateUserIdentityRequest} createUserIdentityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserIdentity: async (userId: string, createUserIdentityRequest: CreateUserIdentityRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createUserIdentity', 'userId', userId)
            // verify required parameter 'createUserIdentityRequest' is not null or undefined
            assertParamExists('createUserIdentity', 'createUserIdentityRequest', createUserIdentityRequest)
            const localVarPath = `/api/users/{userId}/identities`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserIdentityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new MFA verification for a given user ID.
         * @summary Create an MFA verification for a user
         * @param {string} userId The unique identifier of the user.
         * @param {CreateUserMfaVerificationRequest} createUserMfaVerificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserMfaVerification: async (userId: string, createUserMfaVerificationRequest: CreateUserMfaVerificationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createUserMfaVerification', 'userId', userId)
            // verify required parameter 'createUserMfaVerificationRequest' is not null or undefined
            assertParamExists('createUserMfaVerification', 'createUserMfaVerificationRequest', createUserMfaVerificationRequest)
            const localVarPath = `/api/users/{userId}/mfa-verifications`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserMfaVerificationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete user with the given ID. Note all associated data will be deleted cascadingly.
         * @summary Delete user
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUser', 'userId', userId)
            const localVarPath = `/api/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a social identity from the user.
         * @summary Delete social identity from user
         * @param {string} userId The unique identifier of the user.
         * @param {string} target 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserIdentity: async (userId: string, target: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserIdentity', 'userId', userId)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('deleteUserIdentity', 'target', target)
            const localVarPath = `/api/users/{userId}/identities/{target}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an MFA verification for the user with the given verification ID. The verification ID must be associated with the given user ID.
         * @summary Delete an MFA verification for a user
         * @param {string} userId The unique identifier of the user.
         * @param {string} verificationId The unique identifier of the verification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserMfaVerification: async (userId: string, verificationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserMfaVerification', 'userId', userId)
            // verify required parameter 'verificationId' is not null or undefined
            assertParamExists('deleteUserMfaVerification', 'verificationId', verificationId)
            const localVarPath = `/api/users/{userId}/mfa-verifications/{verificationId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"verificationId"}}`, encodeURIComponent(String(verificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an API resource role from the user.
         * @summary Remove role from user
         * @param {string} userId The unique identifier of the user.
         * @param {string} roleId The unique identifier of the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserRole: async (userId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserRole', 'userId', userId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('deleteUserRole', 'roleId', roleId)
            const localVarPath = `/api/users/{userId}/roles/{roleId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user data for the given ID.
         * @summary Get user
         * @param {string} userId The unique identifier of the user.
         * @param {string} [includeSsoIdentities] If it\&#39;s provided with a truthy value (&#x60;true&#x60;, &#x60;1&#x60;, &#x60;yes&#x60;), each user in the response will include a &#x60;ssoIdentities&#x60; property containing a list of SSO identities associated with the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: string, includeSsoIdentities?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId)
            const localVarPath = `/api/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (includeSsoIdentities !== undefined) {
                localVarQueryParameter['includeSsoIdentities'] = includeSsoIdentities;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if the user with the given ID has a password set.
         * @summary Check if user has password
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserHasPassword: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserHasPassword', 'userId', userId)
            const localVarPath = `/api/users/{userId}/has-password`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get custom data for the given user ID.
         * @summary Get user custom data
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserCustomData: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listUserCustomData', 'userId', userId)
            const localVarPath = `/api/users/{userId}/custom-data`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a user\'s existing MFA verifications for a given user ID.
         * @summary Get user\'s MFA verifications
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserMfaVerifications: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listUserMfaVerifications', 'userId', userId)
            const localVarPath = `/api/users/{userId}/mfa-verifications`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all organizations that the user is a member of. In each organization object, the user\'s roles in that organization are included in the `organizationRoles` array.
         * @summary Get organizations for a user
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserOrganizations: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listUserOrganizations', 'userId', userId)
            const localVarPath = `/api/users/{userId}/organizations`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get API resource roles assigned to the user with pagination.
         * @summary Get roles for user
         * @param {string} userId The unique identifier of the user.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserRoles: async (userId: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listUserRoles', 'userId', userId)
            const localVarPath = `/api/users/{userId}/roles`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get users with filters and pagination.  Logto provides a very flexible way to query users. You can filter users by almost any fields with multiple modes. To learn more about the query syntax, please refer to [Advanced user search](https://docs.logto.io/docs/recipes/manage-users/advanced-user-search/).
         * @summary Get users
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Directly update a social identity of the user.
         * @summary Update social identity of user
         * @param {string} userId The unique identifier of the user.
         * @param {string} target 
         * @param {ReplaceUserIdentityRequest} replaceUserIdentityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceUserIdentity: async (userId: string, target: string, replaceUserIdentityRequest: ReplaceUserIdentityRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('replaceUserIdentity', 'userId', userId)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('replaceUserIdentity', 'target', target)
            // verify required parameter 'replaceUserIdentityRequest' is not null or undefined
            assertParamExists('replaceUserIdentity', 'replaceUserIdentityRequest', replaceUserIdentityRequest)
            const localVarPath = `/api/users/{userId}/identities/{target}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(replaceUserIdentityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update API resource roles assigned to the user. This will replace the existing roles.
         * @summary Update roles for user
         * @param {string} userId The unique identifier of the user.
         * @param {AssignApplicationRolesRequest} assignApplicationRolesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceUserRoles: async (userId: string, assignApplicationRolesRequest: AssignApplicationRolesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('replaceUserRoles', 'userId', userId)
            // verify required parameter 'assignApplicationRolesRequest' is not null or undefined
            assertParamExists('replaceUserRoles', 'assignApplicationRolesRequest', assignApplicationRolesRequest)
            const localVarPath = `/api/users/{userId}/roles`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignApplicationRolesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user data for the given ID. This method performs a partial update.
         * @summary Update user
         * @param {string} userId The unique identifier of the user.
         * @param {UpdateUserRequest} updateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (userId: string, updateUserRequest: UpdateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUser', 'userId', userId)
            // verify required parameter 'updateUserRequest' is not null or undefined
            assertParamExists('updateUser', 'updateUserRequest', updateUserRequest)
            const localVarPath = `/api/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update custom data for the given user ID. This method performs a partial update of the custom data object.
         * @summary Update user custom data
         * @param {string} userId The unique identifier of the user.
         * @param {UpdateUserCustomDataRequest} updateUserCustomDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserCustomData: async (userId: string, updateUserCustomDataRequest: UpdateUserCustomDataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserCustomData', 'userId', userId)
            // verify required parameter 'updateUserCustomDataRequest' is not null or undefined
            assertParamExists('updateUserCustomData', 'updateUserCustomDataRequest', updateUserCustomDataRequest)
            const localVarPath = `/api/users/{userId}/custom-data`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserCustomDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user suspension status for the given ID.
         * @summary Update user suspension status
         * @param {string} userId The unique identifier of the user.
         * @param {UpdateUserIsSuspendedRequest} updateUserIsSuspendedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserIsSuspended: async (userId: string, updateUserIsSuspendedRequest: UpdateUserIsSuspendedRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserIsSuspended', 'userId', userId)
            // verify required parameter 'updateUserIsSuspendedRequest' is not null or undefined
            assertParamExists('updateUserIsSuspended', 'updateUserIsSuspendedRequest', updateUserIsSuspendedRequest)
            const localVarPath = `/api/users/{userId}/is-suspended`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserIsSuspendedRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user password for the given ID.
         * @summary Update user password
         * @param {string} userId The unique identifier of the user.
         * @param {UpdateUserPasswordRequest} updateUserPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword: async (userId: string, updateUserPasswordRequest: UpdateUserPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserPassword', 'userId', userId)
            // verify required parameter 'updateUserPasswordRequest' is not null or undefined
            assertParamExists('updateUserPassword', 'updateUserPasswordRequest', updateUserPasswordRequest)
            const localVarPath = `/api/users/{userId}/password`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update profile for the given user ID. This method performs a partial update of the profile object.
         * @summary Update user profile
         * @param {string} userId The unique identifier of the user.
         * @param {UpdateUserProfileRequest} updateUserProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserProfile: async (userId: string, updateUserProfileRequest: UpdateUserProfileRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserProfile', 'userId', userId)
            // verify required parameter 'updateUserProfileRequest' is not null or undefined
            assertParamExists('updateUserProfile', 'updateUserProfileRequest', updateUserProfileRequest)
            const localVarPath = `/api/users/{userId}/profile`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test if the given password matches the user\'s password.
         * @summary Verify user password
         * @param {string} userId The unique identifier of the user.
         * @param {VerifyUserPasswordRequest} verifyUserPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyUserPassword: async (userId: string, verifyUserPasswordRequest: VerifyUserPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('verifyUserPassword', 'userId', userId)
            // verify required parameter 'verifyUserPasswordRequest' is not null or undefined
            assertParamExists('verifyUserPassword', 'verifyUserPasswordRequest', verifyUserPasswordRequest)
            const localVarPath = `/api/users/{userId}/password/verify`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyUserPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Assign API resource roles to the user. The roles will be added to the existing roles.
         * @summary Assign roles to user
         * @param {string} userId The unique identifier of the user.
         * @param {AssignApplicationRolesRequest} assignApplicationRolesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignUserRoles(userId: string, assignApplicationRolesRequest: AssignApplicationRolesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignUserRoles(userId, assignApplicationRolesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.assignUserRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new user with the given data.
         * @summary Create user
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(createUserRequest: CreateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(createUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.createUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Link authenticated user identity from a social platform to a Logto user.  The usage of this API is usually coupled with `POST /connectors/:connectorId/authorization-uri`. With the help of these pair of APIs, you can implement a user profile page with the link social account feature in your application.  Note: Currently due to technical limitations, this API does not support the following connectors that rely on Logto interaction session: `@logto/connector-apple`, `@logto/connector-saml`, `@logto/connector-oidc` and `@logto/connector-oauth`.
         * @summary Link social identity to user
         * @param {string} userId The unique identifier of the user.
         * @param {CreateUserIdentityRequest} createUserIdentityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserIdentity(userId: string, createUserIdentityRequest: CreateUserIdentityRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: GetJwtCustomizer200ResponseOneOfContextSampleUserIdentitiesValue; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserIdentity(userId, createUserIdentityRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.createUserIdentity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new MFA verification for a given user ID.
         * @summary Create an MFA verification for a user
         * @param {string} userId The unique identifier of the user.
         * @param {CreateUserMfaVerificationRequest} createUserMfaVerificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserMfaVerification(userId: string, createUserMfaVerificationRequest: CreateUserMfaVerificationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserMfaVerification200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserMfaVerification(userId, createUserMfaVerificationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.createUserMfaVerification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete user with the given ID. Note all associated data will be deleted cascadingly.
         * @summary Delete user
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a social identity from the user.
         * @summary Delete social identity from user
         * @param {string} userId The unique identifier of the user.
         * @param {string} target 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserIdentity(userId: string, target: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserIdentity(userId, target, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.deleteUserIdentity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an MFA verification for the user with the given verification ID. The verification ID must be associated with the given user ID.
         * @summary Delete an MFA verification for a user
         * @param {string} userId The unique identifier of the user.
         * @param {string} verificationId The unique identifier of the verification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserMfaVerification(userId: string, verificationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserMfaVerification(userId, verificationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.deleteUserMfaVerification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove an API resource role from the user.
         * @summary Remove role from user
         * @param {string} userId The unique identifier of the user.
         * @param {string} roleId The unique identifier of the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserRole(userId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserRole(userId, roleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.deleteUserRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user data for the given ID.
         * @summary Get user
         * @param {string} userId The unique identifier of the user.
         * @param {string} [includeSsoIdentities] If it\&#39;s provided with a truthy value (&#x60;true&#x60;, &#x60;1&#x60;, &#x60;yes&#x60;), each user in the response will include a &#x60;ssoIdentities&#x60; property containing a list of SSO identities associated with the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: string, includeSsoIdentities?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, includeSsoIdentities, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check if the user with the given ID has a password set.
         * @summary Check if user has password
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserHasPassword(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserHasPassword200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserHasPassword(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUserHasPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get custom data for the given user ID.
         * @summary Get user custom data
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserCustomData(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserCustomData(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.listUserCustomData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a user\'s existing MFA verifications for a given user ID.
         * @summary Get user\'s MFA verifications
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserMfaVerifications(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListUserMfaVerifications200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserMfaVerifications(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.listUserMfaVerifications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all organizations that the user is a member of. In each organization object, the user\'s roles in that organization are included in the `organizationRoles` array.
         * @summary Get organizations for a user
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserOrganizations(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListApplicationOrganizations200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserOrganizations(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.listUserOrganizations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get API resource roles assigned to the user with pagination.
         * @summary Get roles for user
         * @param {string} userId The unique identifier of the user.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserRoles(userId: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListApplicationRoles200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserRoles(userId, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.listUserRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get users with filters and pagination.  Logto provides a very flexible way to query users. You can filter users by almost any fields with multiple modes. To learn more about the query syntax, please refer to [Advanced user search](https://docs.logto.io/docs/recipes/manage-users/advanced-user-search/).
         * @summary Get users
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UpdateUser200Response>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.listUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Directly update a social identity of the user.
         * @summary Update social identity of user
         * @param {string} userId The unique identifier of the user.
         * @param {string} target 
         * @param {ReplaceUserIdentityRequest} replaceUserIdentityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaceUserIdentity(userId: string, target: string, replaceUserIdentityRequest: ReplaceUserIdentityRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: GetJwtCustomizer200ResponseOneOfContextSampleUserIdentitiesValue; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceUserIdentity(userId, target, replaceUserIdentityRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.replaceUserIdentity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update API resource roles assigned to the user. This will replace the existing roles.
         * @summary Update roles for user
         * @param {string} userId The unique identifier of the user.
         * @param {AssignApplicationRolesRequest} assignApplicationRolesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaceUserRoles(userId: string, assignApplicationRolesRequest: AssignApplicationRolesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceUserRoles(userId, assignApplicationRolesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.replaceUserRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update user data for the given ID. This method performs a partial update.
         * @summary Update user
         * @param {string} userId The unique identifier of the user.
         * @param {UpdateUserRequest} updateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(userId: string, updateUserRequest: UpdateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(userId, updateUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update custom data for the given user ID. This method performs a partial update of the custom data object.
         * @summary Update user custom data
         * @param {string} userId The unique identifier of the user.
         * @param {UpdateUserCustomDataRequest} updateUserCustomDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserCustomData(userId: string, updateUserCustomDataRequest: UpdateUserCustomDataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserCustomData(userId, updateUserCustomDataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUserCustomData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update user suspension status for the given ID.
         * @summary Update user suspension status
         * @param {string} userId The unique identifier of the user.
         * @param {UpdateUserIsSuspendedRequest} updateUserIsSuspendedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserIsSuspended(userId: string, updateUserIsSuspendedRequest: UpdateUserIsSuspendedRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserIsSuspended(userId, updateUserIsSuspendedRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUserIsSuspended']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update user password for the given ID.
         * @summary Update user password
         * @param {string} userId The unique identifier of the user.
         * @param {UpdateUserPasswordRequest} updateUserPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPassword(userId: string, updateUserPasswordRequest: UpdateUserPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserPassword(userId, updateUserPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUserPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update profile for the given user ID. This method performs a partial update of the profile object.
         * @summary Update user profile
         * @param {string} userId The unique identifier of the user.
         * @param {UpdateUserProfileRequest} updateUserProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserProfile(userId: string, updateUserProfileRequest: UpdateUserProfileRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetJwtCustomizer200ResponseOneOfContextSampleUserProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserProfile(userId, updateUserProfileRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUserProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test if the given password matches the user\'s password.
         * @summary Verify user password
         * @param {string} userId The unique identifier of the user.
         * @param {VerifyUserPasswordRequest} verifyUserPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyUserPassword(userId: string, verifyUserPasswordRequest: VerifyUserPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyUserPassword(userId, verifyUserPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.verifyUserPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Assign API resource roles to the user. The roles will be added to the existing roles.
         * @summary Assign roles to user
         * @param {string} userId The unique identifier of the user.
         * @param {AssignApplicationRolesRequest} assignApplicationRolesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignUserRoles(userId: string, assignApplicationRolesRequest: AssignApplicationRolesRequest, options?: any): AxiosPromise<void> {
            return localVarFp.assignUserRoles(userId, assignApplicationRolesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user with the given data.
         * @summary Create user
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(createUserRequest: CreateUserRequest, options?: any): AxiosPromise<UpdateUser200Response> {
            return localVarFp.createUser(createUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Link authenticated user identity from a social platform to a Logto user.  The usage of this API is usually coupled with `POST /connectors/:connectorId/authorization-uri`. With the help of these pair of APIs, you can implement a user profile page with the link social account feature in your application.  Note: Currently due to technical limitations, this API does not support the following connectors that rely on Logto interaction session: `@logto/connector-apple`, `@logto/connector-saml`, `@logto/connector-oidc` and `@logto/connector-oauth`.
         * @summary Link social identity to user
         * @param {string} userId The unique identifier of the user.
         * @param {CreateUserIdentityRequest} createUserIdentityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserIdentity(userId: string, createUserIdentityRequest: CreateUserIdentityRequest, options?: any): AxiosPromise<{ [key: string]: GetJwtCustomizer200ResponseOneOfContextSampleUserIdentitiesValue; }> {
            return localVarFp.createUserIdentity(userId, createUserIdentityRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new MFA verification for a given user ID.
         * @summary Create an MFA verification for a user
         * @param {string} userId The unique identifier of the user.
         * @param {CreateUserMfaVerificationRequest} createUserMfaVerificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserMfaVerification(userId: string, createUserMfaVerificationRequest: CreateUserMfaVerificationRequest, options?: any): AxiosPromise<CreateUserMfaVerification200Response> {
            return localVarFp.createUserMfaVerification(userId, createUserMfaVerificationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete user with the given ID. Note all associated data will be deleted cascadingly.
         * @summary Delete user
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a social identity from the user.
         * @summary Delete social identity from user
         * @param {string} userId The unique identifier of the user.
         * @param {string} target 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserIdentity(userId: string, target: string, options?: any): AxiosPromise<UpdateUser200Response> {
            return localVarFp.deleteUserIdentity(userId, target, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an MFA verification for the user with the given verification ID. The verification ID must be associated with the given user ID.
         * @summary Delete an MFA verification for a user
         * @param {string} userId The unique identifier of the user.
         * @param {string} verificationId The unique identifier of the verification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserMfaVerification(userId: string, verificationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserMfaVerification(userId, verificationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove an API resource role from the user.
         * @summary Remove role from user
         * @param {string} userId The unique identifier of the user.
         * @param {string} roleId The unique identifier of the role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserRole(userId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserRole(userId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user data for the given ID.
         * @summary Get user
         * @param {string} userId The unique identifier of the user.
         * @param {string} [includeSsoIdentities] If it\&#39;s provided with a truthy value (&#x60;true&#x60;, &#x60;1&#x60;, &#x60;yes&#x60;), each user in the response will include a &#x60;ssoIdentities&#x60; property containing a list of SSO identities associated with the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: string, includeSsoIdentities?: string, options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.getUser(userId, includeSsoIdentities, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if the user with the given ID has a password set.
         * @summary Check if user has password
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserHasPassword(userId: string, options?: any): AxiosPromise<GetUserHasPassword200Response> {
            return localVarFp.getUserHasPassword(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get custom data for the given user ID.
         * @summary Get user custom data
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserCustomData(userId: string, options?: any): AxiosPromise<object> {
            return localVarFp.listUserCustomData(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a user\'s existing MFA verifications for a given user ID.
         * @summary Get user\'s MFA verifications
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserMfaVerifications(userId: string, options?: any): AxiosPromise<Array<ListUserMfaVerifications200ResponseInner>> {
            return localVarFp.listUserMfaVerifications(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all organizations that the user is a member of. In each organization object, the user\'s roles in that organization are included in the `organizationRoles` array.
         * @summary Get organizations for a user
         * @param {string} userId The unique identifier of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserOrganizations(userId: string, options?: any): AxiosPromise<Array<ListApplicationOrganizations200ResponseInner>> {
            return localVarFp.listUserOrganizations(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get API resource roles assigned to the user with pagination.
         * @summary Get roles for user
         * @param {string} userId The unique identifier of the user.
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserRoles(userId: string, page?: number, pageSize?: number, options?: any): AxiosPromise<Array<ListApplicationRoles200ResponseInner>> {
            return localVarFp.listUserRoles(userId, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get users with filters and pagination.  Logto provides a very flexible way to query users. You can filter users by almost any fields with multiple modes. To learn more about the query syntax, please refer to [Advanced user search](https://docs.logto.io/docs/recipes/manage-users/advanced-user-search/).
         * @summary Get users
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [pageSize] Entries per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(page?: number, pageSize?: number, options?: any): AxiosPromise<Array<UpdateUser200Response>> {
            return localVarFp.listUsers(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Directly update a social identity of the user.
         * @summary Update social identity of user
         * @param {string} userId The unique identifier of the user.
         * @param {string} target 
         * @param {ReplaceUserIdentityRequest} replaceUserIdentityRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceUserIdentity(userId: string, target: string, replaceUserIdentityRequest: ReplaceUserIdentityRequest, options?: any): AxiosPromise<{ [key: string]: GetJwtCustomizer200ResponseOneOfContextSampleUserIdentitiesValue; }> {
            return localVarFp.replaceUserIdentity(userId, target, replaceUserIdentityRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update API resource roles assigned to the user. This will replace the existing roles.
         * @summary Update roles for user
         * @param {string} userId The unique identifier of the user.
         * @param {AssignApplicationRolesRequest} assignApplicationRolesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceUserRoles(userId: string, assignApplicationRolesRequest: AssignApplicationRolesRequest, options?: any): AxiosPromise<void> {
            return localVarFp.replaceUserRoles(userId, assignApplicationRolesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user data for the given ID. This method performs a partial update.
         * @summary Update user
         * @param {string} userId The unique identifier of the user.
         * @param {UpdateUserRequest} updateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(userId: string, updateUserRequest: UpdateUserRequest, options?: any): AxiosPromise<UpdateUser200Response> {
            return localVarFp.updateUser(userId, updateUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update custom data for the given user ID. This method performs a partial update of the custom data object.
         * @summary Update user custom data
         * @param {string} userId The unique identifier of the user.
         * @param {UpdateUserCustomDataRequest} updateUserCustomDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserCustomData(userId: string, updateUserCustomDataRequest: UpdateUserCustomDataRequest, options?: any): AxiosPromise<object> {
            return localVarFp.updateUserCustomData(userId, updateUserCustomDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user suspension status for the given ID.
         * @summary Update user suspension status
         * @param {string} userId The unique identifier of the user.
         * @param {UpdateUserIsSuspendedRequest} updateUserIsSuspendedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserIsSuspended(userId: string, updateUserIsSuspendedRequest: UpdateUserIsSuspendedRequest, options?: any): AxiosPromise<UpdateUser200Response> {
            return localVarFp.updateUserIsSuspended(userId, updateUserIsSuspendedRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user password for the given ID.
         * @summary Update user password
         * @param {string} userId The unique identifier of the user.
         * @param {UpdateUserPasswordRequest} updateUserPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword(userId: string, updateUserPasswordRequest: UpdateUserPasswordRequest, options?: any): AxiosPromise<UpdateUser200Response> {
            return localVarFp.updateUserPassword(userId, updateUserPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update profile for the given user ID. This method performs a partial update of the profile object.
         * @summary Update user profile
         * @param {string} userId The unique identifier of the user.
         * @param {UpdateUserProfileRequest} updateUserProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserProfile(userId: string, updateUserProfileRequest: UpdateUserProfileRequest, options?: any): AxiosPromise<GetJwtCustomizer200ResponseOneOfContextSampleUserProfile> {
            return localVarFp.updateUserProfile(userId, updateUserProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Test if the given password matches the user\'s password.
         * @summary Verify user password
         * @param {string} userId The unique identifier of the user.
         * @param {VerifyUserPasswordRequest} verifyUserPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyUserPassword(userId: string, verifyUserPasswordRequest: VerifyUserPasswordRequest, options?: any): AxiosPromise<void> {
            return localVarFp.verifyUserPassword(userId, verifyUserPasswordRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Assign API resource roles to the user. The roles will be added to the existing roles.
     * @summary Assign roles to user
     * @param {string} userId The unique identifier of the user.
     * @param {AssignApplicationRolesRequest} assignApplicationRolesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public assignUserRoles(userId: string, assignApplicationRolesRequest: AssignApplicationRolesRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).assignUserRoles(userId, assignApplicationRolesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user with the given data.
     * @summary Create user
     * @param {CreateUserRequest} createUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(createUserRequest: CreateUserRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUser(createUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Link authenticated user identity from a social platform to a Logto user.  The usage of this API is usually coupled with `POST /connectors/:connectorId/authorization-uri`. With the help of these pair of APIs, you can implement a user profile page with the link social account feature in your application.  Note: Currently due to technical limitations, this API does not support the following connectors that rely on Logto interaction session: `@logto/connector-apple`, `@logto/connector-saml`, `@logto/connector-oidc` and `@logto/connector-oauth`.
     * @summary Link social identity to user
     * @param {string} userId The unique identifier of the user.
     * @param {CreateUserIdentityRequest} createUserIdentityRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUserIdentity(userId: string, createUserIdentityRequest: CreateUserIdentityRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUserIdentity(userId, createUserIdentityRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new MFA verification for a given user ID.
     * @summary Create an MFA verification for a user
     * @param {string} userId The unique identifier of the user.
     * @param {CreateUserMfaVerificationRequest} createUserMfaVerificationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUserMfaVerification(userId: string, createUserMfaVerificationRequest: CreateUserMfaVerificationRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUserMfaVerification(userId, createUserMfaVerificationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete user with the given ID. Note all associated data will be deleted cascadingly.
     * @summary Delete user
     * @param {string} userId The unique identifier of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a social identity from the user.
     * @summary Delete social identity from user
     * @param {string} userId The unique identifier of the user.
     * @param {string} target 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUserIdentity(userId: string, target: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUserIdentity(userId, target, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an MFA verification for the user with the given verification ID. The verification ID must be associated with the given user ID.
     * @summary Delete an MFA verification for a user
     * @param {string} userId The unique identifier of the user.
     * @param {string} verificationId The unique identifier of the verification.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUserMfaVerification(userId: string, verificationId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUserMfaVerification(userId, verificationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove an API resource role from the user.
     * @summary Remove role from user
     * @param {string} userId The unique identifier of the user.
     * @param {string} roleId The unique identifier of the role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUserRole(userId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUserRole(userId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user data for the given ID.
     * @summary Get user
     * @param {string} userId The unique identifier of the user.
     * @param {string} [includeSsoIdentities] If it\&#39;s provided with a truthy value (&#x60;true&#x60;, &#x60;1&#x60;, &#x60;yes&#x60;), each user in the response will include a &#x60;ssoIdentities&#x60; property containing a list of SSO identities associated with the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(userId: string, includeSsoIdentities?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUser(userId, includeSsoIdentities, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if the user with the given ID has a password set.
     * @summary Check if user has password
     * @param {string} userId The unique identifier of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserHasPassword(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserHasPassword(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get custom data for the given user ID.
     * @summary Get user custom data
     * @param {string} userId The unique identifier of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUserCustomData(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).listUserCustomData(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a user\'s existing MFA verifications for a given user ID.
     * @summary Get user\'s MFA verifications
     * @param {string} userId The unique identifier of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUserMfaVerifications(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).listUserMfaVerifications(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all organizations that the user is a member of. In each organization object, the user\'s roles in that organization are included in the `organizationRoles` array.
     * @summary Get organizations for a user
     * @param {string} userId The unique identifier of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUserOrganizations(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).listUserOrganizations(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get API resource roles assigned to the user with pagination.
     * @summary Get roles for user
     * @param {string} userId The unique identifier of the user.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUserRoles(userId: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).listUserRoles(userId, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get users with filters and pagination.  Logto provides a very flexible way to query users. You can filter users by almost any fields with multiple modes. To learn more about the query syntax, please refer to [Advanced user search](https://docs.logto.io/docs/recipes/manage-users/advanced-user-search/).
     * @summary Get users
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [pageSize] Entries per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUsers(page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).listUsers(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Directly update a social identity of the user.
     * @summary Update social identity of user
     * @param {string} userId The unique identifier of the user.
     * @param {string} target 
     * @param {ReplaceUserIdentityRequest} replaceUserIdentityRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public replaceUserIdentity(userId: string, target: string, replaceUserIdentityRequest: ReplaceUserIdentityRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).replaceUserIdentity(userId, target, replaceUserIdentityRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update API resource roles assigned to the user. This will replace the existing roles.
     * @summary Update roles for user
     * @param {string} userId The unique identifier of the user.
     * @param {AssignApplicationRolesRequest} assignApplicationRolesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public replaceUserRoles(userId: string, assignApplicationRolesRequest: AssignApplicationRolesRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).replaceUserRoles(userId, assignApplicationRolesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user data for the given ID. This method performs a partial update.
     * @summary Update user
     * @param {string} userId The unique identifier of the user.
     * @param {UpdateUserRequest} updateUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(userId: string, updateUserRequest: UpdateUserRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUser(userId, updateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update custom data for the given user ID. This method performs a partial update of the custom data object.
     * @summary Update user custom data
     * @param {string} userId The unique identifier of the user.
     * @param {UpdateUserCustomDataRequest} updateUserCustomDataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserCustomData(userId: string, updateUserCustomDataRequest: UpdateUserCustomDataRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserCustomData(userId, updateUserCustomDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user suspension status for the given ID.
     * @summary Update user suspension status
     * @param {string} userId The unique identifier of the user.
     * @param {UpdateUserIsSuspendedRequest} updateUserIsSuspendedRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserIsSuspended(userId: string, updateUserIsSuspendedRequest: UpdateUserIsSuspendedRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserIsSuspended(userId, updateUserIsSuspendedRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user password for the given ID.
     * @summary Update user password
     * @param {string} userId The unique identifier of the user.
     * @param {UpdateUserPasswordRequest} updateUserPasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserPassword(userId: string, updateUserPasswordRequest: UpdateUserPasswordRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserPassword(userId, updateUserPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update profile for the given user ID. This method performs a partial update of the profile object.
     * @summary Update user profile
     * @param {string} userId The unique identifier of the user.
     * @param {UpdateUserProfileRequest} updateUserProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserProfile(userId: string, updateUserProfileRequest: UpdateUserProfileRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserProfile(userId, updateUserProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test if the given password matches the user\'s password.
     * @summary Verify user password
     * @param {string} userId The unique identifier of the user.
     * @param {VerifyUserPasswordRequest} verifyUserPasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public verifyUserPassword(userId: string, verifyUserPasswordRequest: VerifyUserPasswordRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).verifyUserPassword(userId, verifyUserPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VerificationCodesApi - axios parameter creator
 * @export
 */
export const VerificationCodesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Request a verification code for the provided identifier (email/phone). if you\'re using email as the identifier, you need to setup your email connector first. if you\'re using phone as the identifier, you need to setup your SMS connector first.
         * @summary Request and send a verification code
         * @param {ApiInteractionVerificationVerificationCodePostRequest} apiInteractionVerificationVerificationCodePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVerificationCode: async (apiInteractionVerificationVerificationCodePostRequest: ApiInteractionVerificationVerificationCodePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiInteractionVerificationVerificationCodePostRequest' is not null or undefined
            assertParamExists('createVerificationCode', 'apiInteractionVerificationVerificationCodePostRequest', apiInteractionVerificationVerificationCodePostRequest)
            const localVarPath = `/api/verification-codes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiInteractionVerificationVerificationCodePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify a verification code for a specified identifier. if you\'re using email as the identifier, you need to setup your email connector first. if you\'re using phone as the identifier, you need to setup your SMS connector first.
         * @summary Verify a verification code
         * @param {VerifyVerificationCodeRequest} verifyVerificationCodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyVerificationCode: async (verifyVerificationCodeRequest: VerifyVerificationCodeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyVerificationCodeRequest' is not null or undefined
            assertParamExists('verifyVerificationCode', 'verifyVerificationCodeRequest', verifyVerificationCodeRequest)
            const localVarPath = `/api/verification-codes/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ManagementApi required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyVerificationCodeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VerificationCodesApi - functional programming interface
 * @export
 */
export const VerificationCodesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VerificationCodesApiAxiosParamCreator(configuration)
    return {
        /**
         * Request a verification code for the provided identifier (email/phone). if you\'re using email as the identifier, you need to setup your email connector first. if you\'re using phone as the identifier, you need to setup your SMS connector first.
         * @summary Request and send a verification code
         * @param {ApiInteractionVerificationVerificationCodePostRequest} apiInteractionVerificationVerificationCodePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVerificationCode(apiInteractionVerificationVerificationCodePostRequest: ApiInteractionVerificationVerificationCodePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVerificationCode(apiInteractionVerificationVerificationCodePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VerificationCodesApi.createVerificationCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verify a verification code for a specified identifier. if you\'re using email as the identifier, you need to setup your email connector first. if you\'re using phone as the identifier, you need to setup your SMS connector first.
         * @summary Verify a verification code
         * @param {VerifyVerificationCodeRequest} verifyVerificationCodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyVerificationCode(verifyVerificationCodeRequest: VerifyVerificationCodeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyVerificationCode(verifyVerificationCodeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VerificationCodesApi.verifyVerificationCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VerificationCodesApi - factory interface
 * @export
 */
export const VerificationCodesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VerificationCodesApiFp(configuration)
    return {
        /**
         * Request a verification code for the provided identifier (email/phone). if you\'re using email as the identifier, you need to setup your email connector first. if you\'re using phone as the identifier, you need to setup your SMS connector first.
         * @summary Request and send a verification code
         * @param {ApiInteractionVerificationVerificationCodePostRequest} apiInteractionVerificationVerificationCodePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVerificationCode(apiInteractionVerificationVerificationCodePostRequest: ApiInteractionVerificationVerificationCodePostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.createVerificationCode(apiInteractionVerificationVerificationCodePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify a verification code for a specified identifier. if you\'re using email as the identifier, you need to setup your email connector first. if you\'re using phone as the identifier, you need to setup your SMS connector first.
         * @summary Verify a verification code
         * @param {VerifyVerificationCodeRequest} verifyVerificationCodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyVerificationCode(verifyVerificationCodeRequest: VerifyVerificationCodeRequest, options?: any): AxiosPromise<void> {
            return localVarFp.verifyVerificationCode(verifyVerificationCodeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VerificationCodesApi - object-oriented interface
 * @export
 * @class VerificationCodesApi
 * @extends {BaseAPI}
 */
export class VerificationCodesApi extends BaseAPI {
    /**
     * Request a verification code for the provided identifier (email/phone). if you\'re using email as the identifier, you need to setup your email connector first. if you\'re using phone as the identifier, you need to setup your SMS connector first.
     * @summary Request and send a verification code
     * @param {ApiInteractionVerificationVerificationCodePostRequest} apiInteractionVerificationVerificationCodePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationCodesApi
     */
    public createVerificationCode(apiInteractionVerificationVerificationCodePostRequest: ApiInteractionVerificationVerificationCodePostRequest, options?: RawAxiosRequestConfig) {
        return VerificationCodesApiFp(this.configuration).createVerificationCode(apiInteractionVerificationVerificationCodePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify a verification code for a specified identifier. if you\'re using email as the identifier, you need to setup your email connector first. if you\'re using phone as the identifier, you need to setup your SMS connector first.
     * @summary Verify a verification code
     * @param {VerifyVerificationCodeRequest} verifyVerificationCodeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationCodesApi
     */
    public verifyVerificationCode(verifyVerificationCodeRequest: VerifyVerificationCodeRequest, options?: RawAxiosRequestConfig) {
        return VerificationCodesApiFp(this.configuration).verifyVerificationCode(verifyVerificationCodeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WellKnownApi - axios parameter creator
 * @export
 */
export const WellKnownApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the full sign-in experience configuration.
         * @summary Get full sign-in experience
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignInExperienceConfig: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/.well-known/sign-in-exp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get localized phrases based on the specified language.
         * @summary Get localized phrases
         * @param {string} [lng] The language tag for localization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignInExperiencePhrases: async (lng?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/.well-known/phrases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (lng !== undefined) {
                localVarQueryParameter['lng'] = lng;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WellKnownApi - functional programming interface
 * @export
 */
export const WellKnownApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WellKnownApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the full sign-in experience configuration.
         * @summary Get full sign-in experience
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignInExperienceConfig(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSignInExperienceConfig200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignInExperienceConfig(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WellKnownApi.getSignInExperienceConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get localized phrases based on the specified language.
         * @summary Get localized phrases
         * @param {string} [lng] The language tag for localization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignInExperiencePhrases(lng?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: GetSignInExperiencePhrases200ResponseValue; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignInExperiencePhrases(lng, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WellKnownApi.getSignInExperiencePhrases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WellKnownApi - factory interface
 * @export
 */
export const WellKnownApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WellKnownApiFp(configuration)
    return {
        /**
         * Get the full sign-in experience configuration.
         * @summary Get full sign-in experience
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignInExperienceConfig(options?: any): AxiosPromise<GetSignInExperienceConfig200Response> {
            return localVarFp.getSignInExperienceConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * Get localized phrases based on the specified language.
         * @summary Get localized phrases
         * @param {string} [lng] The language tag for localization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignInExperiencePhrases(lng?: string, options?: any): AxiosPromise<{ [key: string]: GetSignInExperiencePhrases200ResponseValue; }> {
            return localVarFp.getSignInExperiencePhrases(lng, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WellKnownApi - object-oriented interface
 * @export
 * @class WellKnownApi
 * @extends {BaseAPI}
 */
export class WellKnownApi extends BaseAPI {
    /**
     * Get the full sign-in experience configuration.
     * @summary Get full sign-in experience
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WellKnownApi
     */
    public getSignInExperienceConfig(options?: RawAxiosRequestConfig) {
        return WellKnownApiFp(this.configuration).getSignInExperienceConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get localized phrases based on the specified language.
     * @summary Get localized phrases
     * @param {string} [lng] The language tag for localization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WellKnownApi
     */
    public getSignInExperiencePhrases(lng?: string, options?: RawAxiosRequestConfig) {
        return WellKnownApiFp(this.configuration).getSignInExperiencePhrases(lng, options).then((request) => request(this.axios, this.basePath));
    }
}



